<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Azure on 伊果的沒人看筆記本</title>
    <link>https://igouist.github.io/categories/azure/</link>
    <description>Recent content in Azure on 伊果的沒人看筆記本</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hant-TW</language>
    <managingEditor>Igouist (Igouist)</managingEditor>
    <webMaster>Igouist (Igouist)</webMaster>
    <follow_challenge>
      <feedId>56200764111934464</feedId>
      <userId>41821085092905984</userId>
    </follow_challenge>
    <lastBuildDate>Mon, 12 Sep 2022 23:51:00 +0800</lastBuildDate><atom:link href="https://igouist.github.io/categories/azure/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>使用 Azure Functions &#43; Line Notify 來定時提醒公車到站時間</title>
      <link>https://igouist.github.io/post/2022/09/bus-reminder-2-azure-functions-timetrigger-with-line-notify/</link>
      <pubDate>Mon, 12 Sep 2022 23:51:00 +0800</pubDate>
      <author>Igouist (Igouist)</author>
      <guid>https://igouist.github.io/post/2022/09/bus-reminder-2-azure-functions-timetrigger-with-line-notify/</guid>
      <description>&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/WX17auT.webp&#34;
  alt=&#34;Image&#34;width=&#34;600&#34; height=&#34;1014&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;在上週的 &lt;a href=&#34;https://igouist.github.io/post/2022/09/bus-reminder-1-powershell-and-windows-task-scheduler&#34;&gt;使用 Powershell + 工作排程器 + Line Notify 來定時提醒公車到站時間&lt;/a&gt;，我們利用工作排程器來定時觸發腳本，藉此用 Line 提醒我下班的公車還有多久才來。&lt;/p&gt;
&lt;p&gt;做完之後靈機一動，對呀！最近上班挺常接觸到 &lt;a href=&#34;https://azure.microsoft.com/zh-tw/services/functions/&#34;&gt;Azure Functions&lt;/a&gt; 這個方便東東，不如就把這個小提醒給架設到 Azure Functions 上吧！&lt;/p&gt;
&lt;p&gt;這樣就省卻了特定主機要開著掛工作排程器的困擾，又可以用香香的 Azure 工具來控制監聽的開關，豈不美哉。&lt;/p&gt;
&lt;p&gt;如此如此這般這般，讓我們開始建立 Azure Functions 服務吧！&lt;/p&gt;
&lt;h2 id=&#34;建立-azure-functions-資源&#34;&gt;建立 Azure Functions 資源&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Azure Functions 是 Azure 推出的一款無伺服器（Serverless）服務，簡單來說就是伺服器之類的麻煩事就交給 Azure 去處理，我們只要專心寫功能就好&lt;/strong&gt;。對我這種愛寫小腳本的偷懶工程師來說，可以說是香到爆的服務。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小提醒：Azure Functions 是一款收費服務，使用前請務必確認&lt;a href=&#34;https://azure.microsoft.com/zh-tw/pricing/details/functions/&#34;&gt;定價&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在這篇文章撰寫當下，Azure Functions 有提供每月免費執行一百萬次的授權，對我們每天一次的公車通知來說綽綽有餘了（我們應該不會搭這麼多趟吧…？）&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;首先讓我們到 &lt;a href=&#34;https://portal.azure.com/#home&#34;&gt;Azure&lt;/a&gt; 建立一個函數應用程式（如果用英文，請找 Azure Functions）：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/9SJklpx.webp&#34;
  alt=&#34;Image&#34;width=&#34;444&#34; height=&#34;165&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/emG0G65.webp&#34;
  alt=&#34;Image&#34;width=&#34;891&#34; height=&#34;357&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;接著進到建立 Functions 的頁面，讓我們先選好資源群組，並取個好名字&lt;/p&gt;
&lt;p&gt;因為「MyFunctions」之類的都被取走了，這邊就直接取「林北ㄟ Functions」：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/pyi77OX.webp&#34;
  alt=&#34;Image&#34;width=&#34;743&#34; height=&#34;911&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;執行階段堆疊請選擇自己開發用的語言，我這邊使用 .Net 6 進行開發，作業系統則按照建議的選擇。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這邊要稍微注意方案的選擇！如同前面提到的&lt;a href=&#34;https://azure.microsoft.com/zh-tw/pricing/details/functions/&#34;&gt;定價&lt;/a&gt;，也可以參照 Microsoft Docs 的&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/azure-functions/functions-consumption-costs?tabs=portal&#34;&gt;預估 Azure Functions 中的取用方案成本&lt;/a&gt;說明，裡面會有使用量、進階等方案的說明。&lt;/p&gt;
&lt;p&gt;這次我們要做的只是簡單的提醒通知，所以就選費用最低的使用量計價就好囉～&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;按下確認後就會開始部屬：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/HAk5hdD.webp&#34;
  alt=&#34;Image&#34;width=&#34;1132&#34; height=&#34;505&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;部屬完成就可以前往我們建立的資源囉，可以在這裡確認記憶體、執行次數等資訊：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/xBbnNbB.webp&#34;
  alt=&#34;Image&#34;width=&#34;887&#34; height=&#34;314&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/pHteaUf.webp&#34;
  alt=&#34;Image&#34;width=&#34;1488&#34; height=&#34;840&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;從左側的「函式」可以確認我們現在有哪些 Functions，當然目前還是空的：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/WWLtsFG.webp&#34;
  alt=&#34;Image&#34;width=&#34;949&#34; height=&#34;410&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;接著就讓我們來撰寫第一個 Function 吧！&lt;/p&gt;
&lt;h2 id=&#34;使用-azure-functions-開發公車到站提醒服務&#34;&gt;使用 Azure Functions 開發公車到站提醒服務&lt;/h2&gt;
&lt;p&gt;因為這篇的功能完全是&lt;a href=&#34;https://igouist.github.io/post/2022/09/bus-reminder-1-powershell-and-windows-task-scheduler&#34;&gt;使用 Powershell + 工作排程器 + Line Notify 來定時提醒公車到站時間&lt;/a&gt;的完美復刻版，因此我們要做的事情還是一樣：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每天下班前十分鐘（定時執行）&lt;/li&gt;
&lt;li&gt;告訴我（通知功能）&lt;/li&gt;
&lt;li&gt;下一班到達的公車時間（查詢資訊）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只是這次的功能使用 .Net 6 撰寫，並且使用 Visual Studio 為範例來記錄，定時功能則從臭臭又綁電腦的工作排程器改用香香 Azure Functions 的定時觸發功能。&lt;/p&gt;
&lt;h3 id=&#34;建立-azure-funtcions-專案&#34;&gt;建立 Azure Funtcions 專案&lt;/h3&gt;
&lt;p&gt;首先讓我們新增專案，內建已經有 Azure Functions 的範例可以使用：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/gqnprvJ.webp&#34;
  alt=&#34;Image&#34;width=&#34;1008&#34; height=&#34;672&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;取個好名字，這邊沿用剛剛開資源的命名：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/bJtncZx.webp&#34;
  alt=&#34;Image&#34;width=&#34;1008&#34; height=&#34;672&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;接著就要選擇版本，這邊&lt;strong&gt;要注意 Azure Function 目前還有分出隔離版（Isolated）&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/6LpLjZX.webp&#34;
  alt=&#34;Image&#34;width=&#34;1008&#34; height=&#34;672&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;簡單來說，原本的 Azure Functions 和主機環境太耦合了，如果用到同一個套件不同版本就有可能翻車。因此推出了隔離式的 Azure Functions 讓我們可以乾乾淨淨地用。&lt;/p&gt;
&lt;p&gt;想更了解隔離式版本的差異，可以參見：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/azure-functions/dotnet-isolated-process-guide#why-net-isolated-process&#34;&gt;在隔離式程序中執行 C# Azure Functions 的指南 | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://markheath.net/post/azure-functions-isolated&#34;&gt;Is it time to start creating C# Azure Functions in isolated mode? (markheath.net)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由於 &lt;a href=&#34;https://techcommunity.microsoft.com/t5/apps-on-azure-blog/net-on-azure-functions-roadmap/ba-p/2197916&#34;&gt;.NET on Azure Functions Roadmap&lt;/a&gt; 的示意圖：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/bS0yMTk3OTE2LTI2MjMxOGk0MjM0QjEzMkM3NDI1MDlD?image-dimensions=999x340&amp;amp;revision=8&#34;
  alt=&#34;&#34;width=&#34;998&#34; height=&#34;340&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;明確指出將來的主軸會是隔離式（Isolated），因此我們這邊專案也選擇 .Net 6 已隔離的版本。&lt;del&gt;這樣我往後抄起來比較方便&lt;/del&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小提示：查詢 Azure Functions 相關資料時也要注意版本的差異！&lt;strong&gt;在 .Net 開發隔離式的 SDK 並不一樣&lt;/strong&gt;，連最基本標示 Function 的語法，原本是 &lt;code&gt;[FunctionName()]&lt;/code&gt;，隔離式也改成了更簡潔的 &lt;code&gt;[Function()]&lt;/code&gt;，&lt;strong&gt;因此查資料或開發時要特別注意版本差異&lt;/strong&gt;，避免被 IDE 畫了紅線卻搞不懂為什麼。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;接著我們就可以選擇 Function 的觸發條件，因為我們要定時提醒，因此這邊選擇 Timer Trigger 就可以了：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/eIzaYSc.webp&#34;
  alt=&#34;Image&#34;width=&#34;1008&#34; height=&#34;672&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;同樣常用的還有當成 API 打的 Http Trigger，以及和我們上一次介紹過的 &lt;a href=&#34;https://igouist.github.io/post/2022/08/azure-service-bus/&#34;&gt;ServiceBus&lt;/a&gt; 一起使用的 Service Bus Queue/Topic Trigger 等等。&lt;/p&gt;
&lt;p&gt;關於提供的觸發方式和程式碼範例，可以參照 Microsoft Docs 的 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/azure-functions/functions-triggers-bindings?tabs=csharp#supported-bindings&#34;&gt;Azure Functions 中的觸發程序和繫結&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最後因為我們選擇了 Timer Trigger，這邊提供我們直接設定時間。使用的是 NCrontab 格式，可以參考 &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-timer?tabs=in-process&amp;amp;pivots=programming-language-csharp#cron-expressions&#34;&gt;NCRONTAB expressions&lt;/a&gt; 的說明，Visuat Studio 上也有簡短地介紹：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/6OB1Qrs.webp&#34;
  alt=&#34;Image&#34;width=&#34;932&#34; height=&#34;126&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;按照需求，我們希望下班前，也就是每天的 17:45 左右能提醒公車預估到站的時間。&lt;/p&gt;
&lt;p&gt;NCrontab 和常見的 Crontab 差在多了第一個欄位來控制秒，因此這邊果斷直接使用 &lt;a href=&#34;https://crontab.guru/#*_*_*_*_*&#34;&gt;Cronitor&lt;/a&gt; 查一下，再往前加上一欄當作秒數即可。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;補充：另一個香香工具 &lt;a href=&#34;https://igouist.github.io/post/2022/08/devtoys/&#34;&gt;DevToys&lt;/a&gt; 也能迅速組裝和確認 Cron 語法呦！&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;每天的 17:45 在 Crontab 表示為「45 17 * * *」：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/o5k9Jvl.webp&#34;
  alt=&#34;Image&#34;width=&#34;1041&#34; height=&#34;259&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;我們希望在 0 秒的時候觸發，因此轉 NCrontab 時需要在秒的位置指定 0，也就是「0 45 17 * * *」&lt;/p&gt;
&lt;p&gt;但在填到 Azure Functions 要注意，&lt;strong&gt;在伺服器的時間會是 UTC+0&lt;/strong&gt;。為了在台灣，也就是 UTC+8 的 17:45 觸發，因此將時間更改為「0 45 9 * * *」，否則 Line 就會在半夜通知你起來搭公車&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/bDNvzhE.webp&#34;
  alt=&#34;Image&#34;width=&#34;1059&#34; height=&#34;237&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;這樣其他資訊的頁面就填寫完了，可以按下建立囉！&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/STp7otF.webp&#34;
  alt=&#34;Image&#34;width=&#34;1008&#34; height=&#34;672&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;建立後會看到 Visual Studio 已經使用我們剛剛的設置建立了一個 Function 及 Timer Trigger，時間也填好了（如果後續還要調整時間，就修改 &lt;code&gt;TimerTrigger&lt;/code&gt; 的值就好）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Function1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;readonly&lt;/span&gt; ILogger _logger;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Function1(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ILoggerFactory loggerFactory)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        _logger = loggerFactory.CreateLogger&amp;lt;Function1&amp;gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;    [Function(&amp;#34;Function1&amp;#34;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Run([TimerTrigger(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0 45 9 * * *&amp;#34;&lt;/span&gt;)] MyInfo myTimer)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        _logger.LogInformation(&lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;C# Timer trigger function executed at: {DateTime.Now}&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        _logger.LogInformation(&lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;Next timer schedule at: {myTimer.ScheduleStatus.Next}&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;為了後續管理方便，我們先改個名。這邊就叫做 &lt;code&gt;BusReminderFunctions&lt;/code&gt; 吧：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BusReminderFunctions&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;readonly&lt;/span&gt; ILogger _logger;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; BusReminderFunctions(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ILoggerFactory loggerFactory)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        _logger = loggerFactory.CreateLogger&amp;lt;BusReminderFunctions&amp;gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;    [Function(&amp;#34;BusReminder-TimerTrigger&amp;#34;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; RunTimerTrigger([TimerTrigger(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0 45 9 * * *&amp;#34;&lt;/span&gt;)] MyInfo myTimer)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        _logger.LogInformation(&lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;C# Timer trigger function executed at: {DateTime.Now}&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        _logger.LogInformation(&lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;Next timer schedule at: {myTimer.ScheduleStatus.Next}&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;並且為了測試方便，我們再增加一個 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/azure-functions/functions-bindings-http-webhook-trigger?tabs=isolated-process%2Cfunctionsv2&amp;amp;pivots=programming-language-csharp&#34;&gt;HttpTrigger&lt;/a&gt;，這時候會需要先去 Nuget 安裝相關的套件&lt;/p&gt;
&lt;p&gt;搜尋 &lt;code&gt;Microsoft.Azure.Functions.Worker.Extensions&lt;/code&gt; 就會看到各種 Trigger，這邊就安裝一下 Http 需要的套件吧：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/d4WDrue.webp&#34;
  alt=&#34;Image&#34;width=&#34;1002&#34; height=&#34;455&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;現在讓我們回到 Functions，增加一個 &lt;code&gt;HttpTrigger&lt;/code&gt;，調整一下非同步，並建立一個私有方法 &lt;code&gt;TrackBusAsync&lt;/code&gt;，讓 &lt;code&gt;HttpTrigger&lt;/code&gt; 和 &lt;code&gt;TimerTrigger&lt;/code&gt; 都去呼叫這個方法，這樣我們就可以定時觸發也可以手動觸發它，後續測試起來也比較方便：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[Function(&amp;#34;BusReminder-TimerTrigger&amp;#34;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task RunTimerTrigger([TimerTrigger(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0 45 9 * * *&amp;#34;&lt;/span&gt;)] MyInfo myTimer)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; TrackBusAsync();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[Function(&amp;#34;BusReminder&amp;#34;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task&amp;lt;HttpResponseData&amp;gt; HttpTrigger(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;    [HttpTrigger(AuthorizationLevel.Anonymous, &amp;#34;get&amp;#34;, &amp;#34;post&amp;#34;)]&lt;/span&gt; HttpRequestData req,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    FunctionContext executionContext)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; TrackBusAsync();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; response = req.CreateResponse(HttpStatusCode.OK);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; response.WriteAsJsonAsync&amp;lt;&lt;span style=&#34;color:#66d9ef&#34;&gt;object&lt;/span&gt;&amp;gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; { result = &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt; });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; response;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task TrackBusAsync()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; NotImplementedException();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;補充：HttpTrigger 的參數有三個部份，可以拆分成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;授權層級：Anonymous, Admin 之類的，可參照&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/azure-functions/functions-bindings-http-webhook-trigger?tabs=isolated-process%2Cfunctionsv2&amp;amp;pivots=programming-language-csharp#http-auth&#34;&gt;授權層級&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;方法：Get, Post 之類的，沒指定就會是不限方法&lt;/li&gt;
&lt;li&gt;路由：用來定義 API 路由，預設會拿 FunctionName，在這例子就是 &lt;code&gt;BusReminder&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;都有指定的樣子會像這樣：&lt;br/&gt;&lt;code&gt;[HttpTrigger(AuthorizationLevel.Anonymous, &amp;quot;get&amp;quot;, &amp;quot;post&amp;quot;, Route = null)]&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;這樣事前準備就差不多了，讓我們開始撰寫邏輯部分吧！&lt;/p&gt;
&lt;h3 id=&#34;呼叫-motc-api-查詢公車到站預估時間&#34;&gt;呼叫 MOTC Api 查詢公車到站預估時間&lt;/h3&gt;
&lt;p&gt;首先我們需要取得公車到站預估時間，這部分跟上一期一樣就直接從公共運輸動態服務 MOTC Transport API 的「市區公車之預估到站資料」（&lt;code&gt;EstimatedTimeOfArrival/City/{City}/{RouteName}&lt;/code&gt;） 這支 API 取得就行了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2024.11.25 更新：發現 MOTC 的 API 已經下架了，現在公車資訊已經被整合到運輸資料服務 &lt;a href=&#34;https://tdx.transportdata.tw/api-service/swagger/basic/2998e851-81d0-40f5-b26d-77e2f5ac4118#/&#34;&gt;TDX (Transport Data eXchange)&lt;/a&gt;，有要動手串公車資訊的朋友可能得觀察新版 API 再進行調整了 QQ&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;註：為了避免被查水表，以下就用台北的 307 號公車為例，並假設目標站點是「台北車站（忠孝）」&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;嘗試把縣市和公車路線名稱代入後，可以取得公車行經的站牌資訊，其中就有我們最想要的估計到站時間（秒）：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/GQ9wdqG.webp&#34;
  alt=&#34;Image&#34;width=&#34;1000&#34; height=&#34;586&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;在這個步驟我們還會需要調整 &lt;code&gt;$top&lt;/code&gt; 參數的筆數，順便取得我們要監聽公車到站的站牌 ID（StopId）以及行進方向（Direction） 在這個例子中「台北車站（忠孝）」的站牌 ID 會是 15250&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/mixE42V.webp&#34;
  alt=&#34;Image&#34;width=&#34;994&#34; height=&#34;576&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;確保了資料來源之後，讓我們回到專案裡。&lt;/p&gt;
&lt;p&gt;這次為了之後方便擴展，決定將公車名稱、站牌 ID 等查詢資訊放到組態裡。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;註：接下來會使用到 &lt;a href=&#34;https://igouist.github.io/post/2021/11/newbie-6-dependency-injection/&#34;&gt;依賴注入&lt;/a&gt; 以及讀取 Config 的 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/aspnet/core/fundamentals/configuration/options?view=aspnetcore-6.0&#34;&gt;IOptions&lt;/a&gt;；對這兩項不太熟悉的朋友可以先看過去，並且在後續 BusReminderFunctions 的建構式裡把公車資訊寫死就好，並不會影響功能。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;一般的 .Net 6 API 專案我們會把組態設定放到 &lt;code&gt;appsettings.json&lt;/code&gt; 中，而在開發 Azure Functions 的時候，則會需要用到 &lt;code&gt;host.json&lt;/code&gt; 和 &lt;code&gt;local.settings.json&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/oeWBtKj.webp&#34;
  alt=&#34;Image&#34;width=&#34;621&#34; height=&#34;288&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;host.json&lt;/code&gt; 用來設定站台相關的組態，例如在先前&lt;a href=&#34;https://igouist.github.io/post/2022/08/azure-function-servicebus-trigger-max-auto-renew-duration/&#34;&gt;調整 ServiceBus Trigger 的時候&lt;/a&gt;，我們就是在 &lt;code&gt;host.json&lt;/code&gt; 修改重新傳遞訊息到 Azure Functions 的時間。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;local.settings.json&lt;/code&gt; 則是讓我們在本機開發時使用，對應到線上的組態設定：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/LOjCKc3.webp&#34;
  alt=&#34;Image&#34;width=&#34;1829&#34; height=&#34;888&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以看到 Azure 上的組態有「應用程式設定」和「連接字串」兩個區塊，而在本機開發時會對應到「Values」以及「ConnectionStrings」&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/c4y1dQy.webp&#34;
  alt=&#34;Image&#34;width=&#34;964&#34; height=&#34;279&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;有個大概的認識之後，現在讓我們填入一些值吧。&lt;/p&gt;
&lt;p&gt;現在我希望能從組態中，使用 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/aspnet/core/fundamentals/configuration/options?view=aspnetcore-6.0&#34;&gt;IOptions&lt;/a&gt; 取得查詢公車估計時間相關的設定，因此我先建立了一個 Class &lt;code&gt;BusTrackerOption&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// 公車到站監聽設定&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BusTrackerOption&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/// 公車路線名稱&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; RouteName { &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/// 要預估到站的站牌 ID&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; StopId { &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/// 公車路線行進方向&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Direction { &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt;; } = &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;並且到 &lt;code&gt;local.settings.json&lt;/code&gt; 加上組態。這邊要特別提到的是：原本我們在 &lt;code&gt;appsettings.json&lt;/code&gt; 加上組態，會用這種階層式的寫法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;BusTracker&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;RouteName&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;307&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;StopId&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#ae81ff&#34;&gt;15250&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;Direction&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但我們前面已經看到了，&lt;strong&gt;在 Azure 上的組態實際上是一個單層的列表。因此我們會使用 &lt;code&gt;__&lt;/code&gt; 當作分隔符號來將設定攤平，並放到 &lt;code&gt;local.settings.json&lt;/code&gt; 的 &lt;code&gt;Values&lt;/code&gt; 裡&lt;/strong&gt;（如果是連線字串就放到 &lt;code&gt;ConnectionStrings&lt;/code&gt; 裡），也就是像這樣：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;Values&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ...這裡會有其他組態設定
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 加上 BusTracker 的 參數，用 __ 來表示階層
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;BusTracker__RouteName&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;307&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;BusTracker__StopId&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;15250&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;BusTracker__Direction&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接著讓我們到 &lt;code&gt;Program.cs&lt;/code&gt; 來將 json 的設定值繫結到 &lt;code&gt;BusTrackerOption&lt;/code&gt;，Section 名稱要記得和 json 中的階層名稱對上&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 注意 Azure Functions 的 settings.json 的階層要用 __ 來區隔&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;services.AddOptions();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;services.Configure&amp;lt;BusTrackerOption&amp;gt;(hostContext.Configuration.GetSection(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;BusTracker&amp;#34;&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;註：如果像我一樣開 .Net 6，只看到 &lt;code&gt;HostBuilder&lt;/code&gt; 的朋友，可以自行加入 &lt;code&gt;ConfigureServices((hostContext, services) =&amp;gt; {})&lt;/code&gt; 的部份來註冊，如下：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/I6DFiRl.webp&#34;
  alt=&#34;Image&#34;width=&#34;962&#34; height=&#34;339&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;接著就可以回到我們的 &lt;code&gt;BusReminderFunctions&lt;/code&gt; 來把 &lt;code&gt;IOptions&amp;lt;BusTrackerOption&amp;gt;&lt;/code&gt; 注入進來：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BusReminderFunctions&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;readonly&lt;/span&gt; ILogger _logger;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;readonly&lt;/span&gt; BusTrackerOption _busTrackerOption;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; BusReminderFunctions(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ILoggerFactory loggerFactory,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        IOptions&amp;lt;BusTrackerOption&amp;gt; busTrackerOption)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        _logger = loggerFactory.CreateLogger&amp;lt;BusReminderFunctions&amp;gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        _busTrackerOption = busTrackerOption.Value;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ...略&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;對依賴注入還不太熟悉的朋友，可以在這邊的建構式裡宣告出 &lt;code&gt;BusTrackerOption&lt;/code&gt; 並賦值即可。但還是推薦閱讀&lt;a href=&#34;https://igouist.github.io/post/2021/11/newbie-6-dependency-injection/&#34;&gt;依賴注入&lt;/a&gt;的筆記來了解一下呦&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;現在公車路線等組態都準備得差不多了，只剩下回傳時候要用來接收資料的 Model 還沒開。這時候就直接偷懶，拿 &lt;a href=&#34;https://ptx.transportdata.tw/MOTC?t=Bus&amp;amp;v=2#&#34;&gt;MOTC Transport API&lt;/a&gt; 的 Swagger 打回來的 Json，直接到 &lt;a href=&#34;https://json2csharp.com/&#34;&gt;Json2Cshrp&lt;/a&gt; 之類的轉換網站直接產生 C# Class 就好了：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/NJ6HTbA.webp&#34;
  alt=&#34;Image&#34;width=&#34;1002&#34; height=&#34;711&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/RXzItDb.webp&#34;
  alt=&#34;Image&#34;width=&#34;705&#34; height=&#34;530&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;記得轉換結果的 &lt;code&gt;Class Root&lt;/code&gt; 要改個名稱，這邊就直接取名叫做 &lt;code&gt;BusEstimateInfo&lt;/code&gt; 吧：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/9SoUyu9.webp&#34;
  alt=&#34;Image&#34;width=&#34;540&#34; height=&#34;422&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;現在我們有傳過去的參數，也有接回來的 Model 了，讓我們來開一個私有方法，從 MOTC API 取回資料吧：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// 查詢公車估計到站時間&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;param name=&amp;#34;routeName&amp;#34;&amp;gt;路線名稱&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;param name=&amp;#34;stopId&amp;#34;&amp;gt;站牌 ID&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;param name=&amp;#34;direction&amp;#34;&amp;gt;去返程&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task&amp;lt;BusEstimateInfo&amp;gt; FetchBusEstimateTime(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; routeName,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; stopId,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; direction = &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; api = &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;https://ptx.transportdata.tw/MOTC/v2/Bus/EstimatedTimeOfArrival/City/Taipei/{routeName}&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 將站牌 ID 及路線方向 加入到查詢參數中&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; filter = &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;stopId eq &amp;#39;{stopId}&amp;#39;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (direction != &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        filter += &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34; and direction eq {direction}&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; query = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;&amp;gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;        [&amp;#34;$filter&amp;#34;]&lt;/span&gt; = filter,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;        [&amp;#34;$top&amp;#34;]&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;1.&lt;/span&gt;ToString(),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;        [&amp;#34;$format&amp;#34;]&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;JSON&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 使用套件 Microsoft.AspNetCore.WebUtilities 提供的 QueryHelpers &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 直接組出帶 QueryString 的 Url&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; url = QueryHelpers.AddQueryString(api, query);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 建立 request；注意直接呼叫 API 會要求驗證&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 必須將 Header 掛成瀏覽器才能吃到每日 50 次的呼叫額度&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; request = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; HttpRequestMessage
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Method = HttpMethod.Get,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        RequestUri = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Uri(url)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    request.Headers.Add(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;User-Agent&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64)&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var client = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; HttpClient();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; response = &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; client.SendAsync(request);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (response.IsSuccessStatusCode &lt;span style=&#34;color:#66d9ef&#34;&gt;is&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Exception(response.StatusCode.ToString());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; body = &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; response.Content.ReadAsStringAsync();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; result = JsonSerializer.Deserialize&amp;lt;IEnumerable&amp;lt;BusEstimateInfo&amp;gt;&amp;gt;(body)?.FirstOrDefault();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result ?? &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Exception(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;呼叫 API 失敗，無法取得估計到站資訊&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這支呼叫 API 的 Method 步驟相當簡單：組出參數，呼叫 API，取回資料。&lt;/p&gt;
&lt;p&gt;這邊有偷懶不想組字串，直接使用 &lt;code&gt;Microsoft.AspNetCore.WebUtilities&lt;/code&gt; 的 &lt;code&gt;QueryHelpers.AddQueryString&lt;/code&gt; 來把 GET 的 QueryString 參數組到 Url 裡，不想多安裝一個套件的朋友也可以自己手動組。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;註：&lt;a href=&#34;https://motc-ptx-api-documentation.gitbook.io/motc-ptx-api-documentation/hui-yuan-shen-qing/membertype&#34;&gt;MOTC 的 文件&lt;/a&gt; 有提到非會員一天有 50 次的免費 Swagger 呼叫次數，實測如果是從程式呼叫時會需要吃驗證，要掛 Header 假裝成瀏覽器才能取得資料，不確定是不是還有其他限制。如果是要給自己開發的工具或產品使用的話，還是可以考慮了解一下 MOTC 的會員制度。&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;註：這邊的 HttpClient 也可以直接改用注入 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests&#34;&gt;HttpClientFactory&lt;/a&gt; 的方式來製作。可以參照 Yowko&amp;rsquo;s Notes 的這篇：&lt;a href=&#34;https://blog.yowko.com/httpclient/&#34;&gt;在 .NET Core 與 .NET Framework 上使用 HttpClientFactory&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;現在取得公車資料的 &lt;code&gt;FetchBusEstimateTime&lt;/code&gt; 已經建好了，讓我們調整一下外面的 Trigger 和共通的私有方法，來把 &lt;code&gt;BusTrackerOption&lt;/code&gt; 的資訊帶到參數裡吧：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; BusReminderFunctions(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    IOptions&amp;lt;BusTrackerOption&amp;gt; busTrackerOption,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ILoggerFactory loggerFactory)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    _busTrackerOption = busTrackerOption.Value;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    _logger = loggerFactory.CreateLogger&amp;lt;BusReminderFunctions&amp;gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[Function(&amp;#34;BusReminder-TimerTrigger&amp;#34;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task RunTimerTrigger([TimerTrigger(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0 45 9 * * *&amp;#34;&lt;/span&gt;)] MyInfo myTimer)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; routeName = &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;._busTrackerOption.RouteName;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; stopId = &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;._busTrackerOption.StopId;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; direction = &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;._busTrackerOption.Direction;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; TrackBusAsync(routeName, stopId, direction);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[Function(&amp;#34;BusReminder&amp;#34;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task&amp;lt;HttpResponseData&amp;gt; HttpTrigger(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;    [HttpTrigger(AuthorizationLevel.Anonymous, &amp;#34;get&amp;#34;, &amp;#34;post&amp;#34;)]&lt;/span&gt; HttpRequestData req,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    FunctionContext executionContext)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; routeName = &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;._busTrackerOption.RouteName;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; stopId = &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;._busTrackerOption.StopId;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; direction = &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;._busTrackerOption.Direction;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; TrackBusAsync(routeName, stopId, direction);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; response = req.CreateResponse(HttpStatusCode.OK);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; response.WriteAsJsonAsync&amp;lt;&lt;span style=&#34;color:#66d9ef&#34;&gt;object&lt;/span&gt;&amp;gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; { result = &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt; });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; response;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task TrackBusAsync(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; routeName,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; stopId,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; direction = &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; busEstimateInfo = &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; FetchBusEstimateTime(routeName, stopId, direction);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; NotImplementedException();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;就像前面提到的，我們在這邊讓 &lt;code&gt;TimerTrigger&lt;/code&gt; 和 &lt;code&gt;HttpTrigger&lt;/code&gt; 取出 &lt;code&gt;BusTrackerOption&lt;/code&gt; 的公車相關參數，例如公車路線名稱後，再傳遞到共用的 &lt;code&gt;TrackBusAsync&lt;/code&gt;，現在第一部份的查詢公車資訊已經完工，就讓我們先添加上去。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;註：這邊之所以要讓查詢參數交由外面決定，就是以後如果我想把 &lt;code&gt;HttpTrigger&lt;/code&gt; 改成可以從外部呼叫 API 時可以指定公車路線之類的參數，又或者是將來要註冊多組公車路線到資料庫之類的改動時，可以不用再動「查詢公車到站資訊」之類的邏輯。&lt;del&gt;畢竟懶惰的訣竅在於提早準備&lt;/del&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;發送-line-notify&#34;&gt;發送 Line Notify&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;2024.10 更新: Line Notify 將於 2025 年 3 月停止服務（&lt;a href=&#34;https://notify-bot.line.me/closing-announce&#34;&gt;LINE Notify 結束服務公告&lt;/a&gt;），有看到這篇的朋朋請選擇一組新的通知服務來串吧 QQ&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;現在搞定取得公車資訊的段落了，接著就讓我們來撰寫發送 Line Notify 的部份吧。&lt;/p&gt;
&lt;p&gt;這邊為了過程完整一點，就重播一下上次衝刺去申請 Line Notify Token 的過程吧：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;當下一個直衝 &lt;a href=&#34;https://notify-bot.line.me/zh_TW/&#34;&gt;Line Notify&lt;/a&gt; 高速申請權杖：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/StPJo9W.webp&#34;
  alt=&#34;Image&#34;width=&#34;264&#34; height=&#34;210&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/W43nwLq.webp&#34;
  alt=&#34;Image&#34;width=&#34;506&#34; height=&#34;304&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/Ahl9FoN.webp&#34;
  alt=&#34;Image&#34;width=&#34;511&#34; height=&#34;357&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;好的回想完畢，現在讓我們把拿到的 Line Notify Token 也丟到 &lt;code&gt;local.settings.json&lt;/code&gt; 的 &lt;code&gt;Values&lt;/code&gt; 裡方便管理：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;Values&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ...這裡會有其他組態設定
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 加上 LineNotify 的 Token，用 __ 來表示階層
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;LineNotify__Token&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR LINE NOTIFY TOKEN&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一樣建立一個 Class，方便後續用 &lt;code&gt;IOption&lt;/code&gt; 從組態中取得值：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LineNotifyOptions&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; Token { &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接著到 &lt;code&gt;Program.cs&lt;/code&gt; 來將 json 的設定值繫結到 &lt;code&gt;LineNotifyOptions&lt;/code&gt;，Section 名稱要記得和 json 中的名稱對上：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;services.Configure&amp;lt;LineNotifyOption&amp;gt;(hostContext.Configuration.GetSection(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;LineNotify&amp;#34;&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/61Fs36d.webp&#34;
  alt=&#34;Image&#34;width=&#34;971&#34; height=&#34;365&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;接著就可以回到我們的 &lt;code&gt;BusReminderFunctions&lt;/code&gt; 來把 &lt;code&gt;IOptions&amp;lt;LineNotifyOptions&amp;gt;&lt;/code&gt; 注入進來：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/aYwNOod.webp&#34;
  alt=&#34;Image&#34;width=&#34;679&#34; height=&#34;425&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;這樣從 Config 取得 Token 的準備就完成了，現在讓我們來撰寫傳送訊息的方法本體吧&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;發送 Line Notify 實際上就是傳送一個 Post 請求到 &lt;code&gt;/api/notify&lt;/code&gt;，並將 Token 放到 Header 的 &lt;code&gt;Authorization&lt;/code&gt;、訊息丟到 Body 就行了&lt;/strong&gt;，因此我們可以直接把這方法包裝成接收到訊息就傳遞給 API：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// 發送 Line Notify 通知&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;param name=&amp;#34;message&amp;#34;&amp;gt;The message.&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;exception cref=&amp;#34;System.Exception&amp;#34;&amp;gt;發送失敗&amp;lt;/exception&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task SendLineNotify(&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; message)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;.IsNullOrEmpty(_lineNotifyOptions.Token))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Exception(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;取得 Line Notify Token 失敗&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; lineNotifyApi = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;https://notify-api.line.me/api/notify&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; requestBody = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;        [&amp;#34;message&amp;#34;]&lt;/span&gt; = message
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; request = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; HttpRequestMessage
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Method = HttpMethod.Post,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        RequestUri = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Uri(lineNotifyApi),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Content = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; FormUrlEncodedContent(requestBody)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    request.Headers.Add(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Authorization&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;Bearer {_lineNotifyOptions.Token}&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var client = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; HttpClient();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; response = &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; client.SendAsync(request);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (response.IsSuccessStatusCode &lt;span style=&#34;color:#66d9ef&#34;&gt;is&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Exception(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Line Notify 發送失敗&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;現在我們也已經有了傳送訊息的方法，是時候把它們倆串起來了！&lt;/p&gt;
&lt;h3 id=&#34;組合查詢公車資訊與發送到站通知&#34;&gt;組合查詢公車資訊與發送到站通知&lt;/h3&gt;
&lt;p&gt;先把鏡頭回到我們讓 Trigger 們共用的 &lt;code&gt;TrackBusAsync&lt;/code&gt; 方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task TrackBusAsync(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; routeName,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; stopId,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; direction = &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; busEstimateInfo = &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; FetchBusEstimateTime(routeName, stopId, direction);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; NotImplementedException();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到我們已經嘗試取得公車資訊，現在我們要組裝訊息，然後傳遞到剛剛撰寫的 Line Notify 通知方法裡。&lt;/p&gt;
&lt;p&gt;而我想要的訊息是這樣的：「您追蹤的公車 307 將在 10 分鐘後（18:00）抵達 台北車站（忠孝）」&lt;/p&gt;
&lt;p&gt;因此我會需要計算出剩餘的分數，以及抵達時間，再從前面拿到的公車資訊來組成訊息並傳遞到方法中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task TrackBusAsync(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; routeName,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; stopId,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; direction = &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; busEstimateInfo = &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; FetchBusEstimateTime(routeName, stopId, direction);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 將預估幾秒後抵達 轉換成 預估幾分鐘後抵達&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; estimateMin = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; TimeSpan(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, busEstimateInfo.EstimateTime).Minutes;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 取得台北時區的目前時間，並和預估秒數計算出預估抵達時間&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; timeZone = TimeZoneInfo.FindSystemTimeZoneById(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Taipei Standard Time&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; convertedTime = TimeZoneInfo.ConvertTime(DateTime.UtcNow, timeZone);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; estimateTime = convertedTime.AddSeconds(busEstimateInfo.EstimateTime).ToString(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;HH:mm&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;您追蹤的公車 {busEstimateInfo.RouteName.Zh_tw} 將在 {estimateMin} 分鐘後（{estimateTime}）抵達 {busEstimateInfo.StopName.Zh_tw}&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; SendLineNotify(message);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這邊要特別注意取得時間的部份，因為在伺服器的時間會是 UTC+0，因此我們這邊使用 &lt;code&gt;TimeZoneInfo.ConvertTime&lt;/code&gt; 轉換成台北時區的時間。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;註：像這種丟到雲端平台的服務，會時常遇到時區時間的轉換。單純的時間轉換可以參照之前筆記的 &lt;a href=&#34;https://igouist.github.io/post/2020/08/csharp-timezone/&#34;&gt;C#: 時區轉換、民國西元、國曆農曆、中文月份週期&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;或是可以嘗試更優雅的 DateTimeOffset，請參考 &lt;a href=&#34;https://demo.tc/post/%E9%82%84%E5%9C%A8%E7%94%A8%20DateTime%20%E5%97%8E%EF%BC%9F%E8%A9%A6%E8%A9%A6%20DateTimeOffset%20%E5%90%A7&#34;&gt;還在用 DateTime 嗎？試試 DateTimeOffset 吧 - demo小鋪&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;現在我們已經將前面撰寫的兩個小方法組裝起來，是時候來測試看看了！&lt;/p&gt;
&lt;h3 id=&#34;本機測試-functions&#34;&gt;本機測試 Functions&lt;/h3&gt;
&lt;p&gt;總之，啟動鍵先用力給它按下去：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/1U9G9IP.webp&#34;
  alt=&#34;Image&#34;width=&#34;154&#34; height=&#34;34&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;接著就會看到小黑窗跑起來，告訴你已經啟動了哪些 Functions：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/DCiEz7z.webp&#34;
  alt=&#34;Image&#34;width=&#34;840&#34; height=&#34;540&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;可以看到我們的 Http Trigger 以及 Timer Trigger&lt;/p&gt;
&lt;p&gt;因為我們的 Http Trigger 有支援 GET，所以這邊直接複製 Api 網址丟到瀏覽器打看看就可以試囉：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/oJjtbAg.webp&#34;
  alt=&#34;Image&#34;width=&#34;399&#34; height=&#34;135&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/mcji7B5.webp&#34;
  alt=&#34;Image&#34;width=&#34;709&#34; height=&#34;116&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;這時候小黑窗也會記錄到這次呼叫：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/yENwGQm.webp&#34;
  alt=&#34;Image&#34;width=&#34;841&#34; height=&#34;540&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;看起來運行良好，該放上 Azure 上啦！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;補充：在 Azure 上要看小黑窗的話，可以從左邊選單找到「監視 &amp;gt; 紀錄資料流」：



&lt;img
  src=&#34;https://image.igouist.net/PPonKeW.webp&#34;
  alt=&#34;Image&#34;width=&#34;901&#34; height=&#34;604&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;使用-visual-studio-發佈到-azure-functions&#34;&gt;使用 Visual Studio 發佈到 Azure Functions&lt;/h2&gt;
&lt;p&gt;現在讓我們把寫好的 Functions 佈到前面申請的 Azure Functions 服務上運行。為了方便這邊就使用 Visual Studio 來示範，首先讓我們對專案點選發佈：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/I99j6Ul.webp&#34;
  alt=&#34;Image&#34;width=&#34;621&#34; height=&#34;334&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;接著選取發佈目標，我們想要發到 Azure 雲端上：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/1Kh4BNi.webp&#34;
  alt=&#34;Image&#34;width=&#34;804&#34; height=&#34;564&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;接著會讓我們選擇目標，因為我們前面建立時的作業系統是選用建議的 Windows，因此選擇 Azure Functions (Windows)：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/2uslDph.webp&#34;
  alt=&#34;Image&#34;width=&#34;804&#34; height=&#34;564&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;接著就可以選取符合條件的 Azure Functions，這邊當然是選擇我們前面建立好的「林北ㄟ Functions」&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/7bMyFxY.webp&#34;
  alt=&#34;Image&#34;width=&#34;804&#34; height=&#34;564&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;註：如果先前沒有建立過 Azure Functions 服務，發佈的時候也可以從 Visual Studio 中建立，可以說是相當貼心：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/PWQvV8K.webp&#34;
  alt=&#34;Image&#34;width=&#34;229&#34; height=&#34;61&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;按下完成之後，我們的發佈檔就建立完囉！&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/eOyR58Z.webp&#34;
  alt=&#34;Image&#34;width=&#34;1013&#34; height=&#34;715&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;這邊要特別注意的是，我們先前有在 &lt;code&gt;local.settings.json&lt;/code&gt; 加入一些設定值，例如 BusTracker 的公車路線等設定。因此我們這邊可以順手同步到目標服務上，在裝載的右上角點開「管理 Azure App Service 設定」：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/ojWSenU.webp&#34;
  alt=&#34;Image&#34;width=&#34;1066&#34; height=&#34;376&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;就可以看到我們目前在 Local 的組態設定值，以及 Azure 服務裡的組態設定值。這邊為了將 Local 的設定值同步上去，就直接按下「插入本機的值」：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/zxCxX9z.webp&#34;
  alt=&#34;Image&#34;width=&#34;600&#34; height=&#34;450&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;註：按下「插入本機的值」並確定後，設定值就會同步到 Azure Functions 服務的組態中：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/750ONx8.webp&#34;
  alt=&#34;Image&#34;width=&#34;975&#34; height=&#34;808&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;反過來說，如果沒有從本機同步上去，而是在 Azure 上設定組態也是完全 OK 的&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;現在一切就緒，讓我們按下發佈吧！&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/KMZYA70.webp&#34;
  alt=&#34;Image&#34;width=&#34;1031&#34; height=&#34;534&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;接著就可以看到我們撰寫的 Functions 被發佈上去，並且幫我們重啟了 Azure Functions 服務：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/OImQVyw.webp&#34;
  alt=&#34;Image&#34;width=&#34;606&#34; height=&#34;151&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;現在讓我們回到 Azure Functions 服務的函式看看：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/ux7MrMs.webp&#34;
  alt=&#34;Image&#34;width=&#34;940&#34; height=&#34;435&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;可以確認我們撰寫的 Functions 已經出現囉！&lt;/p&gt;
&lt;p&gt;回到概觀來複製一下我們 Azure Functions 的 Url：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/FsFomcm.webp&#34;
  alt=&#34;Image&#34;width=&#34;1554&#34; height=&#34;380&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;並且加上我們的 HttpTrigger 路由 &lt;code&gt;api/BusReminder&lt;/code&gt; 呼叫看看：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/HQQVi1t.webp&#34;
  alt=&#34;Image&#34;width=&#34;609&#34; height=&#34;137&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/3O0rAbZ.webp&#34;
  alt=&#34;Image&#34;width=&#34;709&#34; height=&#34;116&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;大功告成！&lt;/p&gt;
&lt;h2 id=&#34;小結&#34;&gt;小結&lt;/h2&gt;
&lt;p&gt;終於把這個小提醒給上雲啦！唉呀不得不說 Azure Functions 真是香。&lt;/p&gt;
&lt;p&gt;接下來只要下班前收到公車到站通知，然後在公車來之前下班就可以啦！&lt;/p&gt;
&lt;p&gt;……只要在公車來之前下班，就可以……吧？&lt;/p&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;公司前輩的 Azure Functions 範例&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10202960&#34;&gt;Azure Functions ⚡ 介紹及Serverless入門輕鬆學 - iT 邦幫忙&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/armycoding/2019/03/02/155945&#34;&gt;使用 Azure Function 輕易打造屬於自己的Web API | 工程良田的小球場 - 點部落 (dotblogs.com.tw)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mybaseball52.medium.com/build-a-function-app-732eecec39a1&#34;&gt;建立一個 function App. 使用 Azure Functions | by (KJH) Kuan-Jung, Huang | Medium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://markheath.net/post/azure-functions-isolated&#34;&gt;Is it time to start creating C# Azure Functions in isolated mode? (markheath.net)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://techcommunity.microsoft.com/t5/apps-on-azure-blog/net-on-azure-functions-roadmap/ba-p/2197916&#34;&gt;.NET on Azure Functions Roadmap - Microsoft Tech Community&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>菜雞抓蟲：Azure Functions ServiceBus Trigger 執行過久時會重複觸發 Functions</title>
      <link>https://igouist.github.io/post/2022/08/azure-function-servicebus-trigger-max-auto-renew-duration/</link>
      <pubDate>Sat, 27 Aug 2022 10:09:00 +0800</pubDate>
      <author>Igouist (Igouist)</author>
      <guid>https://igouist.github.io/post/2022/08/azure-function-servicebus-trigger-max-auto-renew-duration/</guid>
      <description>&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/00WQGqR.webp&#34;
  alt=&#34;Image&#34;width=&#34;600&#34; height=&#34;337&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;h2 id=&#34;tldr&#34;&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;當發現&lt;strong&gt;需要執行很久的 ServiceBus Trigger Function 有重複執行的情況&lt;/strong&gt;出現時，可以嘗試到&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/azure-functions/functions-bindings-service-bus?tabs=in-process%2Cextensionv5%2Cextensionv3&amp;amp;pivots=programming-language-csharp#hostjson-settings&#34;&gt;官方的 Host.json 設定指引&lt;/a&gt;，按照 SDK 版本找到對應的「&lt;strong&gt;訊息鎖定最大持續時間&lt;/strong&gt;」設定，例如 maxAutoLockRenewalDuration（延伸模組 5.x+）或 maxAutoRenewDuration（Functions 2.x），並加入專案的 Host.json&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因為 ServiceBus 在傳遞訊息之後，如果超過一段時間（MaxAutoRenewDuration）內沒有得到回應，就會解除信件的鎖並嘗試重新傳遞&lt;/strong&gt;，這時候如果原先的 Function 仍在執行，就會一前一後重複執行 Function 並發生許多光怪陸離的事，例如寫入兩筆資訊、重複複製資料之類的。&lt;/p&gt;
&lt;p&gt;建議如果調整了有 ServiceBus Trigger Function 的 Azure Functions Timeout 設定時，或是發現某支 ServiceBus Trigger 的 Functions 執行時間過長，就要一併注意 MaxAutoRenewDuration 的設定，避免重複執行的情況出現。&lt;/p&gt;
&lt;h2 id=&#34;事發原由&#34;&gt;事發原由&lt;/h2&gt;
&lt;p&gt;工作時將一段需要呼叫其他 API、執行相當久的程式片段搬上 &lt;a href=&#34;https://igouist.github.io/post/2022/09/bus-reminder-2-azure-functions-timetrigger-with-line-notify/&#34;&gt;Azure Functions&lt;/a&gt;，並使用 &lt;a href=&#34;https://igouist.github.io/post/2022/08/azure-service-bus&#34;&gt;Service Bus&lt;/a&gt; 來傳遞訊息觸發 Functions 執行，這時卻發現 &lt;strong&gt;Function 被執行了兩次&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;現在就讓我們來重建當時的情況吧。首先我們有個 Service Bus Trigger 的 Azure Function，這邊就直接從 Visual Studio 提供的&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/azure-functions/dotnet-isolated-process-guide&#34;&gt;已隔離（Isolated）&lt;/a&gt;範本進行建立。&lt;/p&gt;
&lt;p&gt;為了重現執行很久的特點，我們讓它 Delay 個八分鐘，並在開始和結束的時候告訴我們一下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// ServiceBus Trigger 測試用 Function&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;param name=&amp;#34;myQueueItem&amp;#34;&amp;gt;My queue item.&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[Function(&amp;#34;ServiceBusTriggerSample&amp;#34;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task Run(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;    [ServiceBusTrigger(
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;        queueName: &amp;#34;%QueueName%&amp;#34;,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;        Connection = &amp;#34;ServiceBus&amp;#34;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; myQueueItem)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    _logger.LogInformation(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;開始處理訊息: {myQueueItem}&amp;#34;&lt;/span&gt;, myQueueItem);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; Task.Delay(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; TimeSpan(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    _logger.LogInformation(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;結束處理訊息: {myQueueItem}&amp;#34;&lt;/span&gt;, myQueueItem);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;並且簡單地用之前 &lt;a href=&#34;https://igouist.github.io/post/2022/08/azure-service-bus&#34;&gt;Service Bus 文章&lt;/a&gt; 的範例送個 &amp;ldquo;Hello&amp;rdquo; 進去 Queue 裡，準備觸發 Function：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task Main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; context = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello!&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var client = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ServiceBusClient(_connectionString);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var sender = client.CreateSender(_queueName);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ServiceBusMessage(context);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; sender.SendMessageAsync(message);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 Function 接收到訊息後，讓我們觀察 Console：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/dBFWz2p.webp&#34;
  alt=&#34;Image&#34;width=&#34;1033&#34; height=&#34;261&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以發現第一次執行尚未結束的時候，大概經過五分鐘就又執行了第二次！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;調整訊息鎖定最大持續時間&#34;&gt;調整訊息鎖定最大持續時間&lt;/h2&gt;
&lt;p&gt;原先以為是 Function 執行失敗導致 ServiceBus 重新傳遞之類的狀況，但找了老半天沒有頭緒，嘗試了調整一些設定也沒有起色，陷入了深深的混亂&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/UY3EhoA.webp&#34;
  alt=&#34;Image&#34;width=&#34;586&#34; height=&#34;483&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;幸好天無絕人之路，最終在 &lt;a href=&#34;https://stackoverflow.com/questions/62752905/azure-function-service-bus-trigger-running-multiple-times&#34;&gt;Stackoverflow&lt;/a&gt; 海巡的時候了發現一線生機！&lt;/p&gt;
&lt;p&gt;原來 Azure Functions 的 Service Bus Trigger 有個「&lt;strong&gt;訊息鎖定最大持續時間&lt;/strong&gt;」設定！&lt;/p&gt;
&lt;p&gt;當 Service Bus 傳遞訊息到 Function 的時候，Function 會根據執行結果告訴 Service Bus 該訊息要標記成功或是失敗；但如果訊息就這麼一去不回時，Service Bus 會先觀望一下，&lt;strong&gt;直到超過了「訊息鎖定最大持續時間」就會下令解除訊息的鎖定，嘗試重新傳遞&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這次的事件就是因為我們即使調長了 Timeout 時間，但當該 Function 執行超過預設的鎖定時間（五分鐘）時，Service Bus 再度傳遞了訊息，才導致 Function 重複被執行而造成各種奇怪的資料錯誤&lt;/p&gt;
&lt;p&gt;那麼這個「訊息鎖定最大持續時間」怎麼設定呢？我們可以參照&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/azure-functions/functions-bindings-service-bus?tabs=in-process%2Cextensionv5%2Cextensionv3&amp;amp;pivots=programming-language-csharp#hostjson-settings&#34;&gt;官方的 Host.json 設定指引&lt;/a&gt;，按照 SDK 版本找到對應的「訊息鎖定最大持續時間」設定，例如 maxAutoLockRenewalDuration（延伸模組 5.x+）或 maxAutoRenewDuration（Functions 2.x），並加入專案的 Host.json。&lt;/p&gt;
&lt;p&gt;現在讓我們在範例專案加入 maxAutoRenewDuration 的設定，這邊就改成比前面的執行時間八分鐘更長的十分鐘：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/TTpXELd.webp&#34;
  alt=&#34;Image&#34;width=&#34;550&#34; height=&#34;298&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;接著再重新傳遞一次訊息：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/2epGiF9.webp&#34;
  alt=&#34;Image&#34;width=&#34;1043&#34; height=&#34;257&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;可以看到過程中沒有重新傳遞訊息了，大功告成！&lt;/p&gt;
&lt;p&gt;總之，學到了調整 ServiceBus Trigger Function 的 Azure Functions Timeout 設定時，或是發現某支 ServiceBus Trigger 的 Functions 執行時間過長，就要一併注意 MaxAutoRenewDuration 的設定，避免重複執行。&lt;/p&gt;
&lt;p&gt;如此如此，這般這般，一天又平安的過去了，感謝 Stackoverflow 大大們的努力。&lt;/p&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/62752905/azure-function-service-bus-trigger-running-multiple-times&#34;&gt;Azure function service bus trigger running multiple times - Stockoverflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/azure-functions/functions-bindings-service-bus?tabs=in-process%2Cfunctionsv2%2Cextensionv3&amp;amp;pivots=programming-language-csharp#hostjson-settings&#34;&gt;Azure Functions 的 Azure 服務匯流排繫結 | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>使用 Azure Service Bus 來建立簡單的訊息佇列（Message Queue）吧</title>
      <link>https://igouist.github.io/post/2022/08/azure-service-bus/</link>
      <pubDate>Sat, 13 Aug 2022 16:50:00 +0800</pubDate>
      <author>Igouist (Igouist)</author>
      <guid>https://igouist.github.io/post/2022/08/azure-service-bus/</guid>
      <description>&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/5Vube9E.webp&#34;
  alt=&#34;Image&#34;width=&#34;598&#34; height=&#34;565&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;在工作上遇到在兩個 Azure 工具間建立訊息佇列（Message Queue）的需求，因此接觸到了 Azure Service Bus（中文：服務匯流排 &lt;del&gt;燴牛排？&lt;/del&gt;），在前輩的協助下建立了一組簡單的 Demo，這就來筆記一下。&lt;/p&gt;
&lt;h2 id=&#34;什麼是訊息佇列message-queue-mq&#34;&gt;什麼是訊息佇列（Message Queue, MQ）&lt;/h2&gt;
&lt;p&gt;首先讓我們簡單認識一下訊息佇列。假設我們有生產者和消費者兩個服務，其中&lt;strong&gt;生產者負責產生資料，而消費者負責消費這些資料&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/mg4lXJk.webp&#34;
  alt=&#34;Image&#34;width=&#34;1200&#34; height=&#34;485&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;各位也可以這樣理解：生產者就像是壽司師傅，他會不斷的捏壽司出來；而這時候來了一位大胃王顧客，他就是消費者，會不斷地把壽司吃掉&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/Sk16WdC.webp&#34;
  alt=&#34;Image&#34;width=&#34;1138&#34; height=&#34;465&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;大概對這兩個角色有點認識就行了。那麼，假設我們有兩組 API 服務：其中一個是負責寫入 Log 的服務，而另一個是產品服務。&lt;/p&gt;
&lt;p&gt;產品服務會將 Log 內容丟給 Log 服務去紀錄 Log，這時候產生了這些日誌資料的產品服務就是生產者，而消費這些日誌資料去寫 Log 的服務就是消費者。&lt;/p&gt;
&lt;p&gt;也就是：&lt;strong&gt;&lt;code&gt;產品服務（生產者） —— 資料 —&amp;gt; Log 服務（消費者）&lt;/code&gt;&lt;/strong&gt; 這樣的狀況。&lt;/p&gt;
&lt;p&gt;然而像這樣&lt;strong&gt;直接相依的兩個服務，可能就會遇到一些問題：像是消費者突然掛掉，導致生產者也跟著掛掉；又或是消費者的變動和擴展會連帶影響到生產者必須跟著變動等等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;這樣說可能有些模糊。就以上面提到的 Log 服務來說，在直接呼叫 API 的情況下，我們常常會需要在產品服務中直接明確寫出 Log 服務的資訊，像是站台位址、API 路由之類的。&lt;/p&gt;
&lt;p&gt;但當 Log 服務的站台或方法有變動，我們就被迫要修改產品服務對應的程式碼；而如果我們今天想要擴展 Log 服務的站台，就會需要修改產品服務裡關於 Log 服務的資訊。&lt;/p&gt;
&lt;p&gt;而今天如果 Log 服務短暫掛掉了，可能就會連帶讓我們的產品服務一起掛掉，就算有進行簡單的錯誤處理，當時該記的 Log 內容也就遺失了。&lt;/p&gt;
&lt;p&gt;那面對這些問題的時候怎麼辦呢？這時候我們就可以&lt;strong&gt;在中間加一條佇列&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/zrgm8JC.webp&#34;
  alt=&#34;Image&#34;width=&#34;1199&#34; height=&#34;203&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;用前面的壽司店來說就是這樣（很堅持要用壽司舉例）：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/J6aksgo.webp&#34;
  alt=&#34;Image&#34;width=&#34;1200&#34; height=&#34;202&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;我們加入訊息佇列之後得到的好處有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;解除耦合&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;生產者不需要知道消費者的資訊，消費者的變動也不會直接影響到生產者&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高擴展性&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;即使我們要增加消費者的數量，變成三個消費者來處理這些資料，也只要讓佇列處理轉發就好，而不用影響生產者&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非同步&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;生產者現在只要把訊息丟到佇列就可以回頭繼續做自己的事了，不用管也不用等待消費者處理這些訊息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;緩衝&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;佇列讓消費者多了一段緩衝區，即使消費者忙不過來，也有佇列可以讓訊息好好排隊&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外還可以玩一些花式處理，例如藉由佇列來做到限制流量等等，此處先按下不表。&lt;/p&gt;
&lt;p&gt;現在我們大概知道訊息佇列在幹嘛了。接著就讓我們來玩玩 Azure Service Bus 這個訊息佇列服務吧！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;想更了解 Message Queue 的朋友，也可以閱讀以下的參考資料呦：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/starbugs/%E8%AE%93%E4%BB%BB%E5%8B%99%E6%8E%92%E9%9A%8A%E5%90%A7-message-queue-1-de949e274c43&#34;&gt;[基礎觀念系列] 讓任務排隊吧：Message Queue — (1) - 莫力全 Kyle Mo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;amp;mid=2247485080&amp;amp;idx=1&amp;amp;sn=f223feb9256727bde4387d918519766b&#34;&gt;什么是消息队列？ - Java3y (qq.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ningg.top/message-queue-intro/&#34;&gt;消息队列（Message Queue）基本概念 | NingG 个人博客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10238631&#34;&gt;Message Queue - (1) - iT 邦幫忙 (ithome.com.tw)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10209296&#34;&gt;Producer Consumer 模式 - iT 邦幫忙 (ithome.com.tw)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/tw/message-queue/&#34;&gt;什麼是訊息佇列？ (amazon.com)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;建立-azure-service-bus-資源&#34;&gt;建立 Azure Service Bus 資源&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;小提示：Azure Service Bus 是一項收費服務，你可能會想先了解&lt;a href=&#34;https://azure.microsoft.com/zh-tw/pricing/details/service-bus/&#34;&gt;定價&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;首先讓我們先到 &lt;a href=&#34;https://portal.azure.com/#home&#34;&gt;Azure&lt;/a&gt;，建立一個新的資源：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/s0klgGc.webp&#34;
  alt=&#34;Image&#34;width=&#34;502&#34; height=&#34;302&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;找到 Service Bus 並新建它：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/ngSiiJm.webp&#34;
  alt=&#34;Image&#34;width=&#34;614&#34; height=&#34;254&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/2TepYi8.webp&#34;
  alt=&#34;Image&#34;width=&#34;492&#34; height=&#34;304&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;接著選擇要掛資源的帳戶和群組後，替我們的 Service Bus 取個好記的名字。&lt;/p&gt;
&lt;p&gt;這邊示範的方案當然就直接選最便宜的 XD&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/6N744Nr.webp&#34;
  alt=&#34;Image&#34;width=&#34;774&#34; height=&#34;554&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;除了基本設定以外，這邊還能變更最低 TLS 版本（維護老舊專案者注意，或是準備&lt;a href=&#34;https://blog.darkthread.net/blog/net35-tls12-issue/&#34;&gt;踩雷&lt;/a&gt;）等等，可以頁籤都戳一戳。&lt;/p&gt;
&lt;p&gt;確認之後就可以勇敢按下「審核 + 建立」囉！&lt;/p&gt;
&lt;p&gt;按下後會部署個幾分鐘，部屬完畢之後就可以直接前往資源：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/oPmqwpi.webp&#34;
  alt=&#34;Image&#34;width=&#34;700&#34; height=&#34;390&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;抵達我們的 Service Bus 資源頁面：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/CvH4MgL.webp&#34;
  alt=&#34;Image&#34;width=&#34;1077&#34; height=&#34;734&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;這樣我們就成功建立 Service Bus 啦！&lt;/p&gt;
&lt;h2 id=&#34;建立佇列queue&#34;&gt;建立佇列（Queue）&lt;/h2&gt;
&lt;p&gt;接著就讓我們來建立一條佇列吧，首先讓我們再看一眼微軟把拔提供的佇列概念圖：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/Oi1GOqz.webp&#34;
  alt=&#34;Image&#34;width=&#34;780&#34; height=&#34;137&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;回到 Azure 的 Service Bus 資源頁面，讓我們在畫面上點選建立佇列：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/lwNmNQR.webp&#34;
  alt=&#34;Image&#34;width=&#34;577&#34; height=&#34;169&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;並且取個好名字，等等發訊息的時候會用到：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/6ONWYWT.webp&#34;
  alt=&#34;Image&#34;width=&#34;424&#34; height=&#34;525&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這邊會需要注意一下「最大傳遞計數」（Maximum Delivery Count），簡單來說就是這封訊息會嘗試傳遞幾次，如果超過次數都沒有傳遞成功就會被丟到無效信件。可以參閱&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/service-bus-messaging/service-bus-dead-letter-queues#maximum-delivery-count&#34;&gt;服務匯流排寄不出的信件佇列的概觀&lt;/a&gt;中的「最大傳遞計數」小節&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;這篇我們不會用到下面選項的&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/service-bus-messaging/service-bus-partitioning&#34;&gt;資料分割&lt;/a&gt;、到期自動轉&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/service-bus-messaging/service-bus-dead-letter-queues&#34;&gt;無效信件&lt;/a&gt;等功能，有興趣的朋友可以再自己研究一下呦～&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;建立完就會出現在我們 Service Bus 的頁面下方囉：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/Jbzbei8.webp&#34;
  alt=&#34;Image&#34;width=&#34;472&#34; height=&#34;159&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;h2 id=&#34;取得-servicebus-的連線字串&#34;&gt;取得 ServiceBus 的連線字串&lt;/h2&gt;
&lt;p&gt;接著為了讓我們後續可以順利連線，先到左邊的 &lt;strong&gt;「設定 &amp;gt; 共用存取原則」拿到我們的連線字串&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/zYkN3cQ.webp&#34;
  alt=&#34;Image&#34;width=&#34;940&#34; height=&#34;701&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;這邊直接使用預設的原則，如果有需要控管不同使用者的權限，例如說某組連線字串只能接收或讀取等等，也可以在這邊新增原則來管理。&lt;/p&gt;
&lt;h2 id=&#34;將訊息放入佇列&#34;&gt;將訊息放入佇列&lt;/h2&gt;
&lt;p&gt;現在 Queue 已經建立起來了，接著就是要嘗試把訊息丟到 Queue 裡面囉！&lt;/p&gt;
&lt;p&gt;為了方便測試，這邊就採用 Visual Studio 內建的 API 樣板，直接在 Controller 簡單建立一個範例，要實際應用在專案中的朋友請再依據專案架構自行調整。&lt;/p&gt;
&lt;p&gt;那麼就讓我們開始吧，首先我們會需要安裝 &lt;strong&gt;Azure.Messaging.ServiceBus&lt;/strong&gt; 這個套件包：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/zXuFLdw.webp&#34;
  alt=&#34;Image&#34;width=&#34;942&#34; height=&#34;221&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;接著是我們本次的範例用 Controller，以及尚未實作傳送訊息的 Function：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// Service Bus Queue 示範用 Controller&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[ApiController]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[Route(&amp;#34;[controller]&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;)]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;QueueController&lt;/span&gt; : ControllerBase
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/// 將訊息放入佇列&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;    [HttpPost]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task Enqueue([FromBody] &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; context)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 我們要在這裡實作傳送訊息到 Queue 的方法&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;傳送一則訊息到佇列&#34;&gt;傳送一則訊息到佇列&lt;/h3&gt;
&lt;p&gt;接著讓我們來傳送訊息吧，這邊會需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用 ServiceBus 的連線字串建立 &lt;code&gt;ServiceBusClient&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用 Queue 的名稱，從 &lt;code&gt;ServiceBusClient&lt;/code&gt; 建立 &lt;code&gt;ServiceBusSender&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;ServiceBusSender&lt;/code&gt; 來傳送訊息到 Queue&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// 將訊息放入佇列&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[HttpPost]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task Enqueue([FromBody] &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; context)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 用 ServiceBus 的連線字串建立 Client&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 連線字串可以在 Azure ServiceBus 頁面的共用存取原則找到&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ServiceBusClient 用完記得要呼叫 DisposeAsync() 來關掉&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 或是直接使用 await using 包起來&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; connectionString = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR SERVICE BUS CONNECTION STRING&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var client = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ServiceBusClient(connectionString);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 傳遞 Queue 的名字給 CreateSender 方法來建立 Sender&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 和 ServiceBusClient 一樣，有提供 DisposeAsync 方法來關閉&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 或是直接使用 await using 包起來&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; queueName = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR QUEUE NAME&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var sender = client.CreateSender(queueName);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 將要傳送的訊息包裝成 ServiceBusMessage&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 並使用 ServiceBusSender.SendMessageAsync 傳送出去&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ServiceBusMessage(context);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; sender.SendMessageAsync(message);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;提醒一下將來會跑回來複製貼上的我和各位朋朋：記得把連線字串跟佇列名稱改成你的！&lt;/p&gt;
&lt;p&gt;現在讓我們來呼叫ＡＰＩ，丟個 &lt;code&gt;&amp;quot;Hello&amp;quot;&lt;/code&gt; 進去試試：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/ioXGear.webp&#34;
  alt=&#34;Image&#34;width=&#34;1167&#34; height=&#34;883&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;接著到 Azure Service Bus 的 Queue 介面瞧瞧：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/1zTEnWt.webp&#34;
  alt=&#34;Image&#34;width=&#34;800&#34; height=&#34;328&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;Queue 也確實收到一則訊息了，看來我們成功把 Hello 丟進去啦！&lt;/p&gt;
&lt;h3 id=&#34;傳送一批訊息到佇列&#34;&gt;傳送一批訊息到佇列&lt;/h3&gt;
&lt;p&gt;當然在實務上，我們有時候會想要傳一卡車的訊息；例如我們剛處理完一批客戶，想把它們丟到佇列去讓另一個服務做點事，這時候如果還得一封一封塞訊息就有點怪怪的。&lt;/p&gt;
&lt;p&gt;雖然我們可以直接粗暴地把 Sender 的 &lt;code&gt;SendMessageAsync&lt;/code&gt; 加個 &lt;code&gt;s&lt;/code&gt; 變成 &lt;code&gt;SendMessagesAsync&lt;/code&gt;，這樣它就能接收串列的 &lt;code&gt;IEnumerable&amp;lt;ServiceBusMessage&amp;gt;&lt;/code&gt; 了（真貼心啊 Azure）&lt;/p&gt;
&lt;p&gt;不過，我們還可以選擇使用 &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/api/azure.messaging.servicebus.servicebusmessagebatch&#34;&gt;ServiceBusMessageBatch&lt;/a&gt; 這個工具來幫我們一次發他個一批訊息。&lt;/p&gt;
&lt;p&gt;這邊也示範一下。&lt;del&gt;讓我之後可以回來抄&lt;/del&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// 將一堆訊息放入佇列&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;param name=&amp;#34;context&amp;#34;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[HttpPost(&amp;#34;Batch&amp;#34;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task EnqueueBatch([FromBody] &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; context)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 把訊息重複個十次，假裝我們有很多訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; contexts = Enumerable.Repeat(context, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 和單則訊息的場合一樣：先建立 Client 及 Sender&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; connectionString = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR SERVICE BUS CONNECTION STRING&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var client = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ServiceBusClient(connectionString);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; queueName = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR QUEUE NAME&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var sender = client.CreateSender(queueName);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 從 Sender 來建立一批訊息（類似郵差包的感覺）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var messageBatch = &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; sender.CreateMessageBatchAsync();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 將訊息逐一嘗試放到這批訊息中（把信塞到郵差包的感覺）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;foreach&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; text &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; contexts)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ServiceBusMessage(text);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (messageBatch.TryAddMessage(message) &lt;span style=&#34;color:#66d9ef&#34;&gt;is&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Exception(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;放入訊息失敗&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 把整個郵差包丟出去&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; sender.SendMessagesAsync(messageBatch);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;直接多十條訊息，看起來沒問題：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/iZxuUqu.webp&#34;
  alt=&#34;Image&#34;width=&#34;249&#34; height=&#34;104&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;h3 id=&#34;傳送物件到佇列&#34;&gt;傳送物件到佇列&lt;/h3&gt;
&lt;p&gt;Ｑ：我要傳的東西不是 string 而是物件怎麼辦？&lt;/p&gt;
&lt;p&gt;Ａ：山不轉路轉，就用 &lt;code&gt;JsonSerializer.Serialize&lt;/code&gt; 轉成 Json 再傳。&lt;/p&gt;
&lt;p&gt;好的結案。&lt;/p&gt;
&lt;h2 id=&#34;從佇列取出訊息&#34;&gt;從佇列取出訊息&lt;/h2&gt;
&lt;p&gt;現在我們已經可以把訊息丟到 Queue 中了，接下來當然就是要拿出來囉！&lt;/p&gt;
&lt;p&gt;拿出來的時候也有幾個不同的姿勢，接著就讓我們一一介紹下：&lt;/p&gt;
&lt;h3 id=&#34;從佇列中讀取一則訊息&#34;&gt;從佇列中讀取一則訊息&lt;/h3&gt;
&lt;p&gt;就像我們要寫入訊息的時候，要從 &lt;code&gt;ServiceBusClient&lt;/code&gt; 建立一個 &lt;code&gt;ServiceBusSender&lt;/code&gt; 一樣，當我們要寄送訊息的時候，也要從 &lt;code&gt;ServiceBusClient&lt;/code&gt; 建立一個 &lt;code&gt;ServiceBusReceiver&lt;/code&gt; 來幫我們處理訊息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// 取出佇列中的單則訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[HttpGet(&amp;#34;Receive&amp;#34;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task&amp;lt;&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;&amp;gt; Receive()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 和發送訊息的場合差不多：先建立 Client 及 Receiver&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; connectionString = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR SERVICE BUS CONNECTION STRING&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var client = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ServiceBusClient(connectionString);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 和前面的 ServiceBusSender 一樣，有提供 DisposeAsync 方法讓我們用完時關閉&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 或是直接使用 await using 包起來&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; queueName = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR QUEUE NAME&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var receiver = client.CreateReceiver(queueName);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 使用 ReceiveMessageAsync 來把訊息讀取出來&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; receiver.ReceiveMessageAsync();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; body = message.Body.ToString();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 告訴 Service Bus 這個訊息有成功處理了&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; receiver.CompleteMessageAsync(message);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; body;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;過程相當的簡單，只需要叫 &lt;code&gt;ServiceBusReceiver&lt;/code&gt; 幫忙拿出來就好。現在讓我們呼叫試試：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/H9v2PdJ.webp&#34;
  alt=&#34;Image&#34;width=&#34;722&#34; height=&#34;613&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;成功取得我們前面放進去的訊息囉！&lt;/p&gt;
&lt;h3 id=&#34;從佇列中持續讀取訊息&#34;&gt;從佇列中持續讀取訊息&lt;/h3&gt;
&lt;p&gt;前面提到的 &lt;code&gt;ServiceBusReceiver&lt;/code&gt; 可以從佇列中取出一則訊息，但大多時候訊息的接收方是被動的，也就說接收方其實並不知道發送方傳訊息了沒、現在有沒有訊息，更不用說主動去取出訊息了。&lt;/p&gt;
&lt;p&gt;因此通常的作法是採用被動接收訊息再進行處理的方式：&lt;strong&gt;事先註冊好處理訊息的事件，當有訊息進來的時候就按照指示去進行處理&lt;/strong&gt;，這時候我們就會需要用到 &lt;code&gt;ServiceBusProcessor&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;並且當 &lt;code&gt;ServiceBusProcessor&lt;/code&gt; 建立之後，我們會需要告訴他兩件事：我們想怎麼處理訊息、出錯的時候該怎麼辦。&lt;/p&gt;
&lt;p&gt;這些都設定完之後，&lt;code&gt;ServiceBusProcessor&lt;/code&gt; 就會上工站崗。只要有訊息進來，它就會按照我們給的小抄去執行&lt;/p&gt;
&lt;p&gt;整理一下，我們接收 Service Queue 的訊息時會需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用 ServiceBus 的連線字串建立 &lt;code&gt;ServiceBusClient&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用 Queue 的名稱，從 &lt;code&gt;ServiceBusClient&lt;/code&gt; 建立 &lt;code&gt;ServiceBusProcessor&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;設定接收到訊息之後的處理方式 &lt;code&gt;ProcessMessageAsync&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;設定出錯時的處理方式 &lt;code&gt;ProcessErrorAsync&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;讓 &lt;code&gt;ServiceBusProcessor&lt;/code&gt; 持續接收訊息&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// 取出佇列中的訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task Dequeue()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 和發送訊息的場合差不多：先建立 Client 及 Processor&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; connectionString = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR SERVICE BUS CONNECTION STRING&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var client = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ServiceBusClient(connectionString);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 和前面的 ServiceBusSender 一樣，有提供 DisposeAsync 方法讓我們用完時關閉&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 或是直接使用 await using 包起來&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; queueName = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR QUEUE NAME&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var processor = client.CreateProcessor(queueName);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 告訴 Processor 我們想怎麼處理訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    processor.ProcessMessageAsync += MessageHandler;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    processor.ProcessErrorAsync += ErrorHandler;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 讓 Processor 上工，開始接收訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; processor.StartProcessingAsync();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 實際上會掛著讓 processor 一直處理送來的訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 這邊示範而已就意思意思跑個一下下&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; Task.Delay(&lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 讓 Processor 下班休息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; processor.StopProcessingAsync();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// 處理佇列訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task MessageHandler(ProcessMessageEventArgs args)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 從訊息的 Body 取出我們發送時塞進去的內容&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = args.Message.Body.ToString();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 對訊息內容做你想做的事&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 這邊就印出來看個一眼意思意思&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Console.WriteLine(message);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 告訴 Service Bus 這個訊息有成功處理了&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; args.CompleteMessageAsync(args.Message);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// 處理佇列錯誤訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task ErrorHandler(ProcessErrorEventArgs args)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 從訊息中取出錯誤訊息$$&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; exception = args.Exception.ToString();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 對訊息做一些錯誤處理，例如存到日誌系統之類的&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 這邊也印出來看個一眼意思意思&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Console.WriteLine(exception);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接著就讓我們呼叫看看：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/hKoP1bD.webp&#34;
  alt=&#34;Image&#34;width=&#34;877&#34; height=&#34;421&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;可以看見我們確實收到了前面發送的「Hello」，接收大成功！&lt;/p&gt;
&lt;h3 id=&#34;補充在-servicebus-explorer-確認訊息&#34;&gt;補充：在 ServiceBus Explorer 確認訊息&lt;/h3&gt;
&lt;p&gt;除了直接在程式中接收訊息以外，我們在 Azure 的頁面上其實也能確認傳遞中的訊息內容。&lt;/p&gt;
&lt;p&gt;首先到佇列左側的列表找到「&lt;strong&gt;Service Bus Explorer&lt;/strong&gt;」，就可以確認目前佇列和無效信件中的訊息數量。&lt;/p&gt;
&lt;p&gt;點下從頭查看後，就可以看見訊息列表的內容，並點擊訊息查看本文和屬性：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/Uy6MDui.webp&#34;
  alt=&#34;Image&#34;width=&#34;1003&#34; height=&#34;668&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;在找問題的時候還蠻好用，想確認訊息內容的時候可以試試。&lt;/p&gt;
&lt;h2 id=&#34;建立主題topic&#34;&gt;建立主題（Topic）&lt;/h2&gt;
&lt;p&gt;除了佇列（Queue）以外，Service Bus 還提供了另一種傳輸模式：主題（Topic）&lt;/p&gt;
&lt;p&gt;讓我們看一下微軟把拔提供的主題概念圖，可以和前面佇列的圖做一下比較：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/9DwGFgL.webp&#34;
  alt=&#34;Image&#34;width=&#34;780&#34; height=&#34;266&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;簡單來說就是傳送出去之後，會有&lt;strong&gt;多個接收者&lt;/strong&gt;等著收訊息。&lt;/p&gt;
&lt;p&gt;現在就讓我們回到 Azure Service Bus 的頁面，點選上方的「＋主題」來建立新主題吧：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/pHdPOvz.webp&#34;
  alt=&#34;Image&#34;width=&#34;668&#34; height=&#34;375&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小提示：主題（Topic）是標準定價層才提供的功能。如果是使用最便宜的基本定價層的朋友，「＋主題」的按鈕應該會反灰的，這時候就要需要從 Service Bus 概觀頁面的「定價層」變更到標準（Standard）才能建立主題。&lt;/p&gt;
&lt;p&gt;當然不同定價層的價格也會不一樣，要記得確認一下價格呦！&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;接著就和前面的佇列一樣取個好名字：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/r51t3f8.webp&#34;
  alt=&#34;Image&#34;width=&#34;420&#34; height=&#34;405&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;建立完就會出現在我們的 ServiceBus 服務中囉：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/kF998IO.webp&#34;
  alt=&#34;Image&#34;width=&#34;423&#34; height=&#34;154&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;和單純一對一的佇列不一樣，我們還會需要替主題建立訂用帳戶（Subscriptions）&lt;/strong&gt;，這樣主題才知道它到底要把訊息送給哪些對象。&lt;/p&gt;
&lt;p&gt;現在讓我們進入主題的頁面，並找到訂用帳戶：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/vNJpXfl.webp&#34;
  alt=&#34;Image&#34;width=&#34;881&#34; height=&#34;467&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;進去之後讓我們來新增訂用帳戶：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/wRUeMO2.webp&#34;
  alt=&#34;Image&#34;width=&#34;688&#34; height=&#34;266&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;首先當然是要取個好名字，這邊就先用 Sub1 來當作一號訂閱者的暱稱吧：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/rQvOrlM.webp&#34;
  alt=&#34;Image&#34;width=&#34;608&#34; height=&#34;489&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這邊和佇列的時候一樣，要注意「最大傳遞計數」（Maximum Delivery Count），簡單來說就是這封訊息會嘗試傳遞幾次，如果超過次數都沒有傳遞成功就會被丟到無效信件。可以參閱 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/service-bus-messaging/service-bus-dead-letter-queues#maximum-delivery-count&#34;&gt;服務匯流排寄不出的信件佇列的概觀&lt;/a&gt;。&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;另一個要注意的部份是「啟用工作階段」（Session）：簡單來說就是保證訊息的先進先出（FIFO），藉由在訊息中傳遞 SessionID，然後根據訊息的 SessionID 和接收者建立連線之後發送，讓同個工作階段的訊息按照順序發送到同個對象進行處理。&lt;/p&gt;
&lt;p&gt;這功能在佇列和主題都可以使用，但要定價層在標準和以上才支援。當你有多台機器在接收訊息時會對工作階段比較有感覺（例如說 SessionID 寫死然後開了很多台來處理訊息，結果因為工作階段會全部卡在同一台囧）&lt;/p&gt;
&lt;p&gt;詳細可以參閱 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/service-bus-messaging/message-sessions#session-features&#34;&gt;Azure 服務匯流排訊息工作階段&lt;/a&gt;，圖片說明會比較好理解。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;建立完畢之後回到訂用帳戶就會看到囉，這邊為了等等能夠示範傳遞訊息給多個訂用者，所以也順便開了 Sub2：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/q3xkzdQ.webp&#34;
  alt=&#34;Image&#34;width=&#34;439&#34; height=&#34;200&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;這樣就完成了主題的建立啦！接著讓我們回到程式中來撰寫訊息吧～&lt;/p&gt;
&lt;h3 id=&#34;將訊息放入主題&#34;&gt;將訊息放入主題&lt;/h3&gt;
&lt;p&gt;基本上來說，訊息放入主題的方式就和放入佇列的方式一樣：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// 將訊息放入主題&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[HttpPost]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task Enqueue([FromBody] &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; context)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 用 ServiceBus 的連線字串建立 Client&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 連線字串可以在 Azure ServiceBus 頁面的共用存取原則找到&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ServiceBusClient 用完記得要呼叫 DisposeAsync() 來關掉&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 或是直接使用 await using 包起來&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; connectionString = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR SERVICE BUS CONNECTION STRING&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var client = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ServiceBusClient(connectionString);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 傳遞 Topic 的名字給 CreateSender 方法來建立 Sender&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 和 ServiceBusClient 一樣，有提供 DisposeAsync 方法來關閉&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 或是直接使用 await using 包起來&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; topicName = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR TOPIC NAME&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var sender = client.CreateSender(topicName);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 將要傳送的訊息包裝成 ServiceBusMessage&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 並使用 ServiceBusSender.SendMessageAsync 傳送出去&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ServiceBusMessage(context);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; sender.SendMessageAsync(message);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;不用當成大家來找碴，因為真的就是一樣的放法。畢竟 &lt;code&gt;CreateSender&lt;/code&gt; 的參數名稱是這樣的：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/nvj36PO.webp&#34;
  alt=&#34;Image&#34;width=&#34;850&#34; height=&#34;151&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;事不宜遲，我們馬上就來傳一封訊息試試：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/oiL6TD9.webp&#34;
  alt=&#34;Image&#34;width=&#34;309&#34; height=&#34;330&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;這時候再到我們的主題下的訂用帳戶，可以看見訂用帳戶中已經有訊息囉：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/quyH7n9.webp&#34;
  alt=&#34;Image&#34;width=&#34;896&#34; height=&#34;395&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;因為主題會傳送給所有訂用帳戶，所以兩個訂用帳戶都會分別收到這則訊息，讓我們也確認一眼吧：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/uoy84gu.webp&#34;
  alt=&#34;Image&#34;width=&#34;908&#34; height=&#34;395&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;看來我們很順利地把訊息傳送出去啦！那因為整批放入的方式也和佇列一樣，這邊就不再贅述。接下來就讓我們把訊息取出來試試吧～&lt;/p&gt;
&lt;h3 id=&#34;從主題中讀取訊息&#34;&gt;從主題中讀取訊息&lt;/h3&gt;
&lt;p&gt;就像前面寫入訊息到主題和寫入佇列長得九成像一樣，讀取也是差不多的。最大的差別是在&lt;strong&gt;建立 Processor 時，需要多給訂用帳戶名稱&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 需要同時告訴 Processor 主題名稱和訂用帳戶名稱&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; queueName = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR QUEUE NAME&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; subscriptionName = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Sub1&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var processor = client.CreateProcessor(topicName, subscriptionName);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;讓我們修改成 Topic 名稱以及剛剛的訂用帳戶 Sub1 之後執行看看：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/udHkpxn.webp&#34;
  alt=&#34;Image&#34;width=&#34;1008&#34; height=&#34;800&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;可以看見訂用帳戶 Sub1 的訊息也消耗掉了：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/lpLy4Rd.webp&#34;
  alt=&#34;Image&#34;width=&#34;650&#34; height=&#34;311&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;而訂用帳戶 Sub2 的訊息還在，當我們使用 Sub2 來建立 Processor 並接收訊息之後才會消失：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/MvOgIL5.webp&#34;
  alt=&#34;Image&#34;width=&#34;944&#34; height=&#34;389&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;其餘的部份都和處理佇列的時候一樣。但為了版面一致 &lt;del&gt;我之後回來複製的時候方便&lt;/del&gt; 這邊還是附上程式碼：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// 取出主題中的訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[HttpGet]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task Dequeue()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 和發送訊息的場合差不多：先建立 Client 及 Processor&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; connectionString = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR SERVICE BUS CONNECTION STRING&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var client = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ServiceBusClient(connectionString);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 和前面的 ServiceBusSender 一樣，有提供 DisposeAsync 方法讓我們用完時關閉&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 或是直接使用 await using 包起來&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 和佇列不一樣的是：需要同時告訴 Processor 主題名稱和訂用帳戶名稱&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; topicName = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR TOPIC NAME&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; subscriptionName = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR SUBSCRIPTION NAME&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var processor = client.CreateProcessor(topicName, subscriptionName);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 告訴 Processor 我們想怎麼處理訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    processor.ProcessMessageAsync += MessageHandler;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    processor.ProcessErrorAsync += ErrorHandler;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 讓 Processor 上工，開始接收訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; processor.StartProcessingAsync();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 實際上會掛著讓 processor 一直處理送來的訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 這邊就意思意思跑個一下下&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; Task.Delay(&lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 讓 Processor 下班休息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; processor.StopProcessingAsync();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// 處理主題訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task MessageHandler(ProcessMessageEventArgs args)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 從訊息的 Body 取出我們發送時塞進去的內容&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = args.Message.Body.ToString();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 對訊息內容做你想做的事。這邊就印出來看個一眼意思意思&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Console.WriteLine(message);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 告訴 Service Bus 這個訊息有成功處理了&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; args.CompleteMessageAsync(args.Message);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// 處理主題錯誤訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task ErrorHandler(ProcessErrorEventArgs args)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 從訊息中取出錯誤訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; exception = args.Exception.ToString();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 對訊息做錯誤處理，例如存到日誌系統之類的。這邊也印出來看個一眼意思意思&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Console.WriteLine(exception);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;稍作整理&#34;&gt;稍作整理&lt;/h2&gt;
&lt;p&gt;我們已經介紹完了 ServiceBus 的兩種主要工具：佇列和主題的基本操作。&lt;/p&gt;
&lt;p&gt;接下來我將稍微對現在的範例程式碼做點簡單的整理，給有興趣的朋友參考。&lt;/p&gt;
&lt;p&gt;其餘的朋友可以直接跳到最後的&lt;a href=&#34;#%E5%B0%8F%E7%B5%90&#34;&gt;小結&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;使用-iazureclientfactory-搭配依賴注入來建立-azure-client&#34;&gt;使用 IAzureClientFactory 搭配依賴注入來建立 Azure Client&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;這一小節會用到 .Net Core 的依賴注入，還沒有概念的朋友可以參照 &lt;a href=&#34;https://igouist.github.io/post/2021/11/newbie-6-dependency-injection&#34;&gt;使用 依賴注入 (Dependency Injection) 來解除強耦合吧&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;在範例中我們總是直接 &lt;code&gt;new ServiceBusClient&lt;/code&gt;。但根據&lt;a href=&#34;https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-performance-improvements?tabs=net-standard-sdk-2#reusing-factories-and-clients&#34;&gt;官方建議&lt;/a&gt;，ServiceBusClient 應該只建立一份並重複使用，以避免重新連線之類的效能損失。&lt;/p&gt;
&lt;p&gt;針對 &lt;code&gt;ServiceBusClient&lt;/code&gt; 的建立和管理，我們可以使用 &lt;code&gt;IAzureClientFactory&lt;/code&gt; 來讓它自動控制，替我們管理 Client 的實例和連線，用起來就像 &lt;code&gt;HttpClientFactory&lt;/code&gt; 一樣。&lt;/p&gt;
&lt;p&gt;要使用 &lt;code&gt;IAzureClientFactory&lt;/code&gt;，我們需要先安裝 &lt;code&gt;Microsoft.Extensions.Azure&lt;/code&gt; 套件：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/vvFZGCE.webp&#34;
  alt=&#34;Image&#34;width=&#34;541&#34; height=&#34;170&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;p&gt;現在讓我們移動到 &lt;code&gt;Program.cs&lt;/code&gt; 並加上 ServiceBusClient 的註冊：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;builder.Services.AddAzureClients(clientsBuilder =&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; connectionString = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR SERVICE BUS CONNECTION STRING&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    clientsBuilder
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .AddServiceBusClient(connectionString)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .WithName(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ServiceBusClient&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;看起來應該會像這樣：&lt;/p&gt;
&lt;p&gt;


&lt;img
  src=&#34;https://image.igouist.net/Uo0IR1g.webp&#34;
  alt=&#34;Image&#34;width=&#34;737&#34; height=&#34;509&#34; style=&#34;width: auto; max-width: 100%; height: auto;&#34;fetchpriority=&#34;high&#34; loading=&#34;auto&#34; decoding=&#34;async&#34;&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;註：示範專案是使用 .Net 6。如果是使用其他版本或其他 DI 工具的朋友，請再按照自己的狀況調整吧！&lt;/p&gt;
&lt;p&gt;例如在 &lt;code&gt;HostBuilder&lt;/code&gt; 的場合，可能就要在 &lt;code&gt;ConfigureServices&lt;/code&gt; 中進行配置等等，只能祝各位好運。&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;註：除了 &lt;code&gt;WithName&lt;/code&gt; 替 Client 實例取名以外，也可以呼叫 &lt;code&gt;ConfigureOptions&lt;/code&gt; 來對 ServiceBusClient 進行各式各樣的設定&lt;/p&gt;
&lt;p&gt;關於 ServiceBusClient 的設定內容可以參閱 &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/api/azure.messaging.servicebus.servicebusclientoptions&#34;&gt;ServiceBusClientOptions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而關於 AddAzureClients 的註冊則可以參閱 &lt;a href=&#34;https://stackoverflow.com/questions/68688838/how-to-register-servicebusclient-for-dependency-injection&#34;&gt;How to register ServiceBusClient for dependency injection? - stackoverflow&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;現在我們註冊完了。接著只需要回到使用的類別讓 &lt;code&gt;IAzureClientFactory&lt;/code&gt; 注入進來就可以囉：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// Service Bus Queue + IAzureClientFactory 示範用 Controller&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[ApiController]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[Route(&amp;#34;[controller]&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;)]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;QueueWithDiController&lt;/span&gt; : ControllerBase
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;readonly&lt;/span&gt; ServiceBusClient _serviceBusClient;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; QueueWithDiController(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        IAzureClientFactory&amp;lt;ServiceBusClient&amp;gt; azureClientFactory)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 使用注入進來的 IAzureClientFactory 來建立 ServiceBusClient&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        _serviceBusClient = azureClientFactory.CreateClient(name: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ServiceBusClient&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接著我們就可以把原本範例中的呼叫也改成使用這個 Client 來操作囉：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; queueName = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR QUEUE NAME&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var sender = _serviceBusClient.CreateSender(queueName);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;註：在前面的&lt;a href=&#34;https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-performance-improvements?tabs=net-standard-sdk-2#reusing-factories-and-clients&#34;&gt;官方建議&lt;/a&gt;中，除了 &lt;code&gt;ServiceBusClient&lt;/code&gt; 以外，其實也建議 &lt;code&gt;ServiceBusSender&lt;/code&gt;、&lt;code&gt;ServiceBusReceiver&lt;/code&gt;、&lt;code&gt;ServiceBusProcessor&lt;/code&gt; 這幾個也應該要維持單例，保持和伺服器的連線以減少建立連線的效能和時間損失。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ServiceBusClient&lt;/code&gt; 已經藉由前面提到的 &lt;code&gt;IAzureClientFactory&lt;/code&gt; 來解決；而像是 &lt;code&gt;ServiceBusSender&lt;/code&gt; 的後面三項，我們就需要根據專案的狀況來規劃如何重複使用。&lt;/p&gt;
&lt;p&gt;例如只需要一個 Sender 的場合，我們可以直接在注入的時候註冊成單例；而要和多個 Queue 連線所以需要多個 Sender 的時候，就可以考慮建立一個工廠來管理，並且在工廠裡面優先返回已經建好的實例等等。這部份就請再各位朋友保持柔軟的彈性來處理。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;將連線字串抽取到-config&#34;&gt;將連線字串抽取到 Config&lt;/h3&gt;
&lt;p&gt;把鏡頭回到我們註冊的地方：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;builder.Services.AddAzureClients(clientsBuilder =&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; connectionString = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR SERVICE BUS CONNECTION STRING&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    clientsBuilder
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .AddServiceBusClient(connectionString)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .WithName(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ServiceBusClient&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到現在的連線字串是寫死在 &lt;code&gt;Program.cs&lt;/code&gt; 中的（即使是前面的範例也是直接寫死在 Controller）&lt;/p&gt;
&lt;p&gt;但實務上我們大多會將連線字串放在設定檔，例如 Config 或 Appsettings，方便在正式環境或是 Azure 服務上運行時，能夠由外部去設定 or 變更組態來置換連線字串。因此這邊也應該要改成從組態中進行讀取。&lt;/p&gt;
&lt;p&gt;首先讓我們把連線字串丟到 &lt;code&gt;appsettings.json&lt;/code&gt; 的 &lt;code&gt;ConnectionStrings&lt;/code&gt; 區塊：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ConnectionStrings&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;:&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;ServiceBus&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR SERVICE BUS CONNECTION STRING&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那麼我們就可以更彈性靈活地使用連線字串來註冊 Client 囉：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;builder.Services.AddAzureClients(clientsBuilder =&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; connectionString = builder.Configuration
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .GetConnectionString(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ServiceBus&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    clientsBuilder
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .AddServiceBusClient(connectionString)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .WithName(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ServiceBusClient&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;小結&#34;&gt;小結&lt;/h2&gt;
&lt;p&gt;這篇我們稍微紀錄了訊息佇列（Message Queue）的用途：拆分生產者和消費者的直接依賴，在中間架設佇列來傳遞訊息。以及這樣做的幾個好處：解除耦合、提高擴展、非同步和提供了緩衝區。&lt;/p&gt;
&lt;p&gt;接著介紹了 Azure 的訊息佇列服務：Azure Service Bus，並對其中的兩種模式：佇列和主題，各做了簡單的操作範例。&lt;/p&gt;
&lt;p&gt;最後補充了一些範例能優化的方向；使用 IAzureClientFactory 來注入 Client、保持 Sender 等連線重複使用，以及將連線字串拆出到組態處理。&lt;/p&gt;
&lt;p&gt;當然還有一些進階的使用場景，例如&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/service-bus-messaging/service-bus-transactions&#34;&gt;交易處理&lt;/a&gt;、&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/service-bus-messaging/service-bus-geo-dr&#34;&gt;異地複寫&lt;/a&gt;等等，但因為這邊還沒有接觸過，就交給需要深入了解的朋朋自行研究囉。&lt;/p&gt;
&lt;p&gt;這算是我第一次接觸 Azure 相關的工具，加減筆記一下簡單的使用場景（傳入訊息到佇列／從佇列取出訊息），範例也已經丟到 &lt;a href=&#34;https://github.com/Igouist/Demo.AzureServiceBus&#34;&gt;Github&lt;/a&gt; 上囉，有缺漏的也歡迎各位朋朋幫忙補充，感謝感謝。&lt;/p&gt;
&lt;p&gt;那麼今天的紀錄就到這邊囉，希望以後還能回來抄。&lt;del&gt;總不會筆記寫完就要改用 RabbitMQ 了吧囧&lt;/del&gt;&lt;/p&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.dotblogs.com.tw/supershowwei/2022/02/13/221639&#34;&gt;[食譜好菜] 比 Azure Queue Storage 功能更完整的 Message Queue 服務 - Azure Service Bus | 軟體主廚的程式料理廚房 - 點部落 (dotblogs.com.tw)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10240878&#34;&gt;訊息服務站 - ServiceBus - iT 邦幫忙：：一起幫忙解決難題，拯救 IT 人的一天 (ithome.com.tw)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/service-bus-messaging/service-bus-dotnet-get-started-with-queues&#34;&gt;開始使用 Azure 服務匯流排佇列 (.NET) - Azure Service Bus | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/MicrosoftDocs/azure-docs.zh-tw/blob/master/articles/service-bus-messaging/service-bus-dotnet-get-started-with-queues.md&#34;&gt;在 Azure 服務匯流排佇列 (.NET) 中傳送和接收訊息 (github.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10161086&#34;&gt;使用 Python 操作 Azure Service Bus Queues - iT 邦幫忙 (ithome.com.tw)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10161209&#34;&gt;使用 Python 操作 Service Bus Topics/Subscriptions - iT 邦幫忙 (ithome.com.tw)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/AllenMaster/p/14000933.html&#34;&gt;Azure Service Bus（一）入门简介 - Grant_Allen - 博客园 (cnblogs.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/AceLee/2019/07/18/195448&#34;&gt;建立 Azure Service Bus | 程式碼學習不歸路 - 點部落 (dotblogs.com.tw)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/AceLee/2019/07/18/205733&#34;&gt;透過 Service Bus Queue trigger Azure Function | 程式碼學習不歸路 - 點部落 (dotblogs.com.tw)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/service-bus-messaging/service-bus-azure-and-service-bus-queues-compared-contrasted&#34;&gt;比較 Azure 佇列儲存體和服務匯流排佇列 - Azure Service Bus | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/event-grid/compare-messaging-services&#34;&gt;比較 Azure 傳訊服務 - Azure Event Grid | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>