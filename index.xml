<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>伊果的沒人看筆記本</title>
    <link>https://igouist.github.io/</link>
    <description>Recent content on 伊果的沒人看筆記本</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hant-TW</language>
    <lastBuildDate>Fri, 05 Apr 2024 23:58:00 +0800</lastBuildDate><atom:link href="https://igouist.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【每天轉貼一篇文章】我是想睡覺的工程師，我想要提神，所以我需要打翻咖啡</title>
      <link>https://igouist.github.io/repost/2024/04/0405-user-story-and-coffee/</link>
      <pubDate>Fri, 05 Apr 2024 23:58:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/repost/2024/04/0405-user-story-and-coffee/</guid>
      <description>&lt;p&gt;前兩天跟朋友聊到 User Story，馬上翻出之前收藏的這篇：&lt;br/&gt;
&lt;a href=&#34;https://blog.akanelee.me/2020/08/14/user-story-and-coffee/&#34;&gt;打翻咖啡不能解決問題，談 User Story - 嫁給 RD 的 UI Designer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我們先簡單地認識一下 User Story：&lt;br/&gt;「我是 囗囗囗，我需要一個方法來幫助我 囗囗囗，這樣我就能 囗囗囗」&lt;/p&gt;
&lt;p&gt;例如說「我是工程師，我需要一個方法來減少參與沒卵用的會議，這樣我就能專心開發」(?)&lt;/p&gt;
&lt;p&gt;有了這個 User Story 香香東西，我們大家就可以&lt;strong&gt;先對焦好需求，再來討論解決方案&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;備註：對 User Story 想進一步了解的朋友，可以參考這篇：&lt;a href=&#34;https://medium.com/3pm-lab/3-use-cases-for-writing-effective-user-stories-cd42625fef53&#34;&gt;產品管理流程中，使用者故事（User Story）常見的三種使用情境 - Anne Hsiao&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而今天要推薦的這篇，就是用非常精準的方式告訴你&lt;br/&gt;「&lt;strong&gt;當 User Story 寫歪的時候&lt;/strong&gt;」會有什麼結果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A. 我想要抽菸。&lt;br/&gt;
B. 我是疲倦想睡覺的上班族，想要提神。&lt;br/&gt;
C. 我是疲倦想睡覺的工程師，想要提神，好讓我能專心認真寫程式。&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;句型分析：&lt;br/&gt;
Ａ句是業界最常見寫法，不知道使用者是誰、也不知道為啥要做這件事，只講了「功能」，然後就要開工。&lt;br/&gt;
Ｂ句稍微好一些，勉強能猜測是誰要做這件事，功能開發出來要給誰用，猜歪的機率不低。&lt;br/&gt;
Ｃ句完整地說明是誰、想要做什麼、做這事的動機，腦海裡浮現的會是創意而不是創傷。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;上面的例子中，A 的場景粗暴，什麼資訊都沒有，只能通靈&lt;br/&gt;
（之前遇過更扯的，投影片丟出來啥也沒解釋，馬上就開始問功能什麼時候會做好）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你習慣用 A 句和專案成員討論功能，恭喜你，改來改去的日子永無止境，絕對是一條邁向通靈王的偉大航道。而且這條道路註定是孤獨的，同事都會討厭你。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而 B 雖然抓到場景了，但是非常容易翻車。&lt;br/&gt;
畢竟，&lt;strong&gt;如果你只是想提神，那打翻咖啡的確比喝咖啡更加提神&lt;/strong&gt;，對吧？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你習慣用 B 句和專案成員討論功能，那你會得到一杯咖啡然後被當面打翻它。沒錯啊～打翻咖啡超級提神！絕對比只給你一杯咖啡更有效，絕對能超越競品，使用者肯定超喜歡的！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，從這杯咖啡中我們可以學到：即使不是撰寫 User Story，&lt;br/&gt;討論需求時仍然要注意「&lt;strong&gt;使用者、情境、需求、動機&lt;/strong&gt;」這些必要資訊，才更有機會有效溝通。&lt;/p&gt;
&lt;p&gt;否則，我們就只能邊通靈邊倒咖啡了 xD&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【每天轉貼一篇文章】從動圖認識負載平衡（Load Balancing）</title>
      <link>https://igouist.github.io/repost/2024/04/0404-load-balancing/</link>
      <pubDate>Thu, 04 Apr 2024 23:38:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/repost/2024/04/0404-load-balancing/</guid>
      <description>&lt;p&gt;今天想轉貼有香香動畫(?)的科普文：
&lt;a href=&#34;https://samwho.dev/load-balancing/&#34;&gt;Load Balancing - Sam Rose&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這篇文章用了簡單的動畫，讓讀者能直觀地了解當下 Request 的傳送狀況（看著球被丟給伺服器，意外地蠻療癒的）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/xhY79Hx.gif&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;從最簡單的 1 個來源發送給 1 台伺服器（=只要一直把球丟過去給伺服器就好）開始&lt;/p&gt;
&lt;p&gt;接著，伺服器開始吃不下了。我們想要增加伺服器數量，但就需要把 Request 分配給他們兩台伺服器，這時候最簡單粗暴的做法就是&lt;strong&gt;輪詢（=輪流發球給他們）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然後再加入一些會在實務上遇到的狀況：每顆球（Request）要處理的工可能不一樣大，伺服器也不一定都一樣強。&lt;/p&gt;
&lt;p&gt;這樣一來，單純平均發球的輪詢作戰很快就會遇到胃口比較小的伺服器開始吃不下的尷尬狀況&lt;/p&gt;
&lt;p&gt;為了減輕這個狀況，我們可以在每個伺服器前面加個小小的&lt;strong&gt;排隊區（Request Queues）&lt;/strong&gt;，雖然要排隊勢必會拉長時間，但至少掉球的狀況就減少了&lt;/p&gt;
&lt;p&gt;再進一步的話，我們可以&lt;strong&gt;針對伺服器的消化能力來替他們加個權重&lt;/strong&gt;，不過手動標權重很容易翻車，所以要想辦法讓他自動調整權重，也就是要能「動態加權輪詢」&lt;/p&gt;
&lt;p&gt;例如根據最近三次的執行時間來計算伺服器的胃口(?)，再決定要發幾顆球給伺服器，比較餓吃比較快的就多發一點(??)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;除了吃不下把球吐掉以外，如果吃太久吃到 Timeout 也是不行的。而針對延遲問題，這篇最後介紹了「峰值指數加權移動平均（PEWMA）」&lt;/p&gt;
&lt;p&gt;做法其實也很直覺：抓一下最近這些伺服器的延遲如何、都處理了多久，然後再經過一些數學魔法(?) 來算出下一個 Request 給哪台伺服器比較好、看能不能讓延遲更少&lt;/p&gt;
&lt;p&gt;ps. 附上數學魔法的段落給那些看得懂的朋友：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For each server, the algorithm keeps track of the latency from the last N requests. Instead of using this to calculate an average, it sums the values but with an exponentially decreasing scale factor. This results in a value where the older a latency is, the less it contributes to the sum. Recent requests influence the calculation more than old ones.&lt;br/&gt;
對於每個伺服器，該演算法會追蹤從最後 N 個請求開始的延遲時間。不同於使用此來計算平均值，它將這些值相加，但使用指數遞減的比例因子。這導致一個值，其中較舊的延遲對總和的貢獻較小。最近的請求比舊的請求更影響計算。&lt;/p&gt;
&lt;p&gt;That value is then taken and multiplied by the number of open connections to the server and the result is the value we use to choose which server to send the next request to. Lower is better.&lt;br/&gt;
然後，將該值乘以與伺服器的開放連接數，結果就是我們用來選擇下一個請求要發送到哪個伺服器的值。數值越低越好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;但是相較前面著重在不要把球吐掉的「動態加權輪詢」，這套注重延遲問題的「峰值指數加權移動平均」就比較有可能發生更嚴重的吃不下問題&lt;/p&gt;
&lt;p&gt;作者有進行一些測試並繪製圖表，有興趣的朋友可以參考看看。感覺還是要根據狀況、評估對延遲或掉包的容忍程度，再決定採用怎樣的負載平衡策略會比較好&lt;/p&gt;
&lt;p&gt;那麼，今天的轉貼就到這邊，我們明天（大概）見～&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【每天轉貼一篇文章】用 Microsoft Clarity 觀察使用者行為</title>
      <link>https://igouist.github.io/repost/2024/04/0402-microsoft-clarity/</link>
      <pubDate>Tue, 02 Apr 2024 23:58:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/repost/2024/04/0402-microsoft-clarity/</guid>
      <description>&lt;p&gt;這兩天在幫部落格加上新玩具，來轉貼一篇寫得挺完善的介紹文：&lt;br/&gt;
&lt;a href=&#34;https://www.letswrite.tw/microsoft-clarity/&#34;&gt;用 Microsoft Clarity 網站分析工具，觀察使用者行為 - Let&amp;rsquo;s Write&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Clarity 是微軟把拔推出的免費網站分析工具，其中有些特別的地方，例如&lt;strong&gt;憤怒點擊&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這個也很有趣，光看名稱就覺得有趣了 XD~&lt;/p&gt;
&lt;p&gt;一般我們自己在看別人家的頁面，比方看到個「點我下載懶人包」之類的按鈕，如果點了發現沒反應後，我們會怎麼做？我們會一直點、繼續點、猛點 10 次、怒點 100 次！&lt;/p&gt;
&lt;p&gt;這個就是 Rage clicks&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另一個讓我覺得小驚豔的功能是&lt;strong&gt;側錄（Recordings）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;這個功能可以直接看使用者在你的畫面上是怎麼操作的&lt;/strong&gt;，有種看使用者開著直播看自己文章的感覺，相當新奇。&lt;del&gt;所以也能很明顯地看到使用者複製了文章裡的程式碼然後跳窗走人……&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/hO6LQPH.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;另外，側錄紀錄上也只有一些模糊的識別內容，所以可以不用擔心錄得太超過(?)的問題&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;左邊是清單，可以照想要的方式來排列順序，右側就是點擊清單後會看得到的側錄影片。&lt;/p&gt;
&lt;p&gt;這邊可以看到，清單上會顯示的是：裝置、作業系統、國家，這三個跟使用者比較相關，是一個比較模糊的分類。&lt;/p&gt;
&lt;p&gt;畢竟如果可以看到「這個人就是王小明，就是他，這就是錄他在幹什麼」的情況，那個資及隱私的問題就大了。&lt;/p&gt;
&lt;p&gt;所以只提供一個模糊的分類是可以理解及接受的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其他功能可能要等子彈飛一會兒再來探探。&lt;br/&gt;有興趣的朋友也可以先戳戳看官方給的 &lt;a href=&#34;https://clarity.microsoft.com/demo/projects/view/3t0wlogvdz/dashboard&#34;&gt;Demo 頁面&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那麼，今天的轉貼就到這邊。我們明天見～&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【每天推薦一篇文章】可觀測性 30 天</title>
      <link>https://igouist.github.io/repost/2024/04/observability-in-devops-30-days/</link>
      <pubDate>Mon, 01 Apr 2024 23:46:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/repost/2024/04/observability-in-devops-30-days/</guid>
      <description>&lt;p&gt;看見前輩貼了「可觀測性」的鐵人賽筆記，翻了一輪發現挺香的，馬上轉貼上來：&lt;br/&gt;
&lt;a href=&#34;https://github.com/marcustung/Observability-in-DevOps/blob/main/README.md&#34;&gt;marcustung/Observability-in-DevOps: Observability 101 (github.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這些文章（我感覺）能切成幾個部份：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一些系統穩定性的東東。例如災害復原、高可用性和高可靠性之類的&lt;/li&gt;
&lt;li&gt;可觀測性 Observability&lt;/li&gt;
&lt;li&gt;好像很猛的新標準 OpenTelemetry&lt;/li&gt;
&lt;li&gt;香香的 Grafana Cloud&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每篇文章的開場都會先說明重點、結束的時候也有知識點小結，非常貼心&lt;/p&gt;
&lt;p&gt;因為系列文本身蠻長的，能延伸的知識點也蠻多的。這邊就按照慣例，列一些我印象比較深刻的點&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我在看到主題的時候，第一個疑問其實是：&lt;strong&gt;所以我的團隊有了可觀測性可以幹啥吃？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而在 Day 10 的可觀測性介紹裡，這一段回答了我的問題：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;白話點背後是希望可以回答以下問題：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;請求經過哪些服務 ? 系統中哪個部分 loading 最大&lt;/li&gt;
&lt;li&gt;當服務發生緩慢時，哪裡慢(Bottlenecks)以及可能原因是什麼&lt;/li&gt;
&lt;li&gt;當服務無法使用時，錯誤及可能異常的原因是什麼&lt;/li&gt;
&lt;li&gt;當使用者反映操作 timeout，但在 Dashboard 上顯示平均請求都很快，要如何找到其可能緩慢原因&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;目的是希望工程團隊可以理解並解釋系統的現況（增加系統透明度，而不是靠通靈），當系統出現問題時，可以第一時間了解爆炸範圍，進行緊急問題的處理已加速恢復的時間。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;身為通靈師的一員，看到這段開始覺得「哦，好像不錯哦，竟然不是靠直覺嗎🤔」&lt;/p&gt;
&lt;p&gt;而在 Day 28 的時候又看到了更強烈的對比：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你是開發或是運維團隊人員，當線上系統或負責應用程式遇到問題時，會做哪些事情來協助定位問題&lt;/p&gt;
&lt;p&gt;警報 (Alert) : &lt;br/&gt;
當系統監控偵測到異常或是特定指標 (Metrics) 超過預定的閥值或水位時，系統會產生告警警報，對於 RD 及團隊來說，這是首先被告知問題的方式。&lt;/p&gt;
&lt;p&gt;儀錶板 (Dashboard) :&lt;br/&gt;
收到警報後，RD 可能會先查看 Dashboard 了解異常背後的數據。Dashboard 提供即時的數據視覺化，幫助 RD 快速定位問題範圍和影響程度。&lt;/p&gt;
&lt;p&gt;查詢 (Adhoc Query) : &lt;br/&gt;
若 Dashboard 所提供的資訊不足，或是為了要更精準確定問題原因，RD 會使用 adhoc Query 進一步的來查找特定時間的數據資料來確認問題。&lt;/p&gt;
&lt;p&gt;日誌 (Log Aggregation) : &lt;br/&gt;
確認問題範圍後，RD 會查找相關的系統或是應用程式 Log，Log 中可能包含更明確的應用程式執行資訊，或是問題的詳細描述與錯誤訊息，幫助 RD 更有機會找到問題的具體原因&lt;/p&gt;
&lt;p&gt;分散式追蹤 (Distributed Tracing) : &lt;br/&gt;
如果應用程式架構是分散式系統，RD 會使用分散式工具來找特定請求式如何在多個服務間流動過程，有助於找到性能瓶頸或可能失敗的原因。&lt;/p&gt;
&lt;p&gt;修復 (Fix) : &lt;br/&gt;
一旦問題被定位，就有機會定位問題並進行緊急修復的動作。可能解決方式式調整配置設定檔、修正錯誤的程式或是重新啟動服務(重開治百病)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;感覺是專業工程師的抓蟲流程。但像我們專業靈媒團隊，平時出事的反應更接近 Day 29 的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;口而相傳，緣分到了就會修好&lt;br/&gt;
各自通靈&lt;br/&gt;
(文件)定義流程 + 系統&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通著通著就哭了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;另一組記憶點是來自於我原先的誤會：&lt;strong&gt;「可觀測性不就是插一狗票 Log 嗎？」&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Day 11 的「從哨塔到全景地圖」有稍微讓我認識了一點：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;舉個玩世紀帝國的例子，&lt;strong&gt;監控就像是在已經打開的地圖前提下，在覺得危險的位子設立哨塔及哨兵&lt;/strong&gt;，當有人來攻擊時就會有叮叮叮聲響來提醒玩家派兵防守&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可觀測性就是一打開地圖就已經全開&lt;/strong&gt;，當別的玩家派兵攻打自己的範就可以看到派人的兵種是甚麼及人數，可以做更有效的化解對方玩家的攻擊&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好像有點懂了：插監控就像是深入敵方野區插眼，可觀測性是想直接開圖&lt;/p&gt;
&lt;p&gt;&lt;del&gt;而我們團隊都是銅牌瞎子，所以小地圖根本是黑的&lt;/del&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;同樣讓我長知識的還有「三本柱 Metrics、Logging 與 Tracing」&lt;/p&gt;
&lt;p&gt;這邊直接節錄文章中的介紹：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Metrics : 指標&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用來衡量和監控系統性能的關鍵數據指標，通常是數字化的方式呈現(可聚合數字)。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;這些數據通常用於即時監控系統，以確保它們在正常運行範圍內。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;例如 : CPU使用率、記憶體使用率、請求速率、錯誤率等都可以通過指標來衡量&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Structured Log : 結構化日誌&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;日誌包含有關離散事件的結構化或可讀的詳細資訊。用於提供請求的細節與上下文。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;日誌通常被用來瞭解系統中特定事件的發生情況，以及在事件發生時提供上下文。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;例如，錯誤日誌、訪問日誌、應用程式日誌等都是常見的日誌類型。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Distributed Tracing : 分散式追蹤&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用於追蹤複雜分佈式系統中請求的過程，以便了解請求從一個元件到另一個元件的傳遞情況。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;它有助於識別性能問題和瓶頸，並提供有關請求流程的詳細信息。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;通常，追蹤由一個唯一的標識符（例如 traceID）來關聯相關事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的理解是這樣，供參考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果服務 CPU 狂噴猛噴，直接噴到 100% 120% 500%，這個是 Metrics&lt;/li&gt;
&lt;li&gt;如果在程式碼裡面偷寫紙條印出來，例如 &amp;ldquo;Oops, ERROR!&amp;quot;，這個是 Logging&lt;/li&gt;
&lt;li&gt;如果跨了三四個服務只好摸一串粽子找過去，這個是 Tracing&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在這之前我基本上都一律叫成 Log，同事問問題也是兩手一攤：你去查 Log 啊= =&lt;/p&gt;
&lt;p&gt;想起一臉疑惑的朋友們，原來混在一起搞撒尿牛丸的是我🥲&lt;/p&gt;
&lt;p&gt;補充：今天和朋友(?)詢問了一些 Metrics、Logging 與 Tracing 的例子，這個對比貼上來給各位參考：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/bqleCrv.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/2WJ0Gyy.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;總覺得其中一種做法特別熟悉🤐&lt;/del&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;後面還有蠻多記憶點的，但寫到這邊發現篇幅有點爆，Discord 竟然發不出去了= = 加速一下&lt;/p&gt;
&lt;p&gt;中間段（Day 17~）的主角都是&lt;strong&gt;不明覺厲(?)的可觀測性全新標準 OpenTelemetry&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如介紹 OpenTelemetry 的規範和實作，例如協定和 API 規格，接著逛了一圈 Demo&lt;/p&gt;
&lt;p&gt;能夠理解有個大一統規範能對可觀測性有多大的幫助，但因為我個人沒玩過，看這段的時候基本上就是「哦哦這新標準好像猛猛的」&lt;/p&gt;
&lt;p&gt;可能之後找時間碰才會有更深的心得，已經摸過的朋友也歡迎幫忙補充資訊上來&lt;/p&gt;
&lt;p&gt;&lt;del&gt;最後的 Day 20+ 開始介紹 Grafana Cloud，離我就更遠了，這邊就略過 xD&lt;/del&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;除了上面的兩大塊深水區以外，我還有兩個小小點特別有印象：&lt;/p&gt;
&lt;p&gt;Day04 的 SLA -&amp;gt; SLO -&amp;gt; SLI 這條：&lt;/p&gt;
&lt;p&gt;我們在 3/19 轉貼&lt;a href=&#34;https://igouist.github.io/repost/2024/03/0319-reorder-message&#34;&gt;德魯大大的 Re-Order Message&lt;/a&gt; 文章時，裡面有提到「對整個系統的 SLO 期待」這一段。在這裡串了起來：&lt;/p&gt;
&lt;p&gt;我們跟客戶簽了 SLA 說我們 99.99% 穩。然後我們為了達標（=不要賠錢），就訂了更具體的 SLO，而為了衡量這些指標，就搞了 SLI&lt;/p&gt;
&lt;p&gt;啊如果 SLI 量下去，抱歉沒達到 SLO，就準備按照 SLA 簽的東西跪地開賠。大概是這樣(?)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;另一個小小點是 Day 30 的可觀測性驅動開發（Observability Driven Development ,ODD）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;就像 TDD 測試驅動開發強調在寫程式碼前要先寫測試案例，以提高程式碼的保護與品質。ODD 在建立可觀測性系統方面也是如此，&lt;strong&gt;可觀察性驅動開發意味著開發人員在編寫程式碼之前考慮可觀察性信號或是監控方法&lt;/strong&gt;，適用於元件級別或是整個系統。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也許，我是說也許，我們開發之前的確就該想好後續該怎麼監測跟維護，而不是把鍋端給後面的苦主來通靈。對吧？對吧前輩們？&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;三十天太長了，很難在這篇推薦文裡介紹完。我已經列了許多我有筆記的部份，但像是 OpenTelemetry 這些硬東西，我個人力有未逮(?)&lt;/p&gt;
&lt;p&gt;還是推薦有興趣的朋友直接閱讀，畢竟文章結構簡單直接，有大綱有小結，拆成每一天的話也不算長，有名詞或觀念也能再自己延伸，感覺不虧&lt;/p&gt;
&lt;p&gt;不說了我要去拆文章內容到我的筆記庫了= =&amp;rdquo;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【每天推薦一篇文章】寫給工程師看的減肥指南</title>
      <link>https://igouist.github.io/repost/2024/03/0329-a-weight-loss-guide-for-engineers/</link>
      <pubDate>Fri, 29 Mar 2024 23:59:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/repost/2024/03/0329-a-weight-loss-guide-for-engineers/</guid>
      <description>&lt;p&gt;今天還在持續厭世，來轉貼前天看&lt;a href=&#34;https://igouist.github.io/repost/2024/03/0327-human-system-optimization&#34;&gt;延壽指南&lt;/a&gt;的時候撿到的工程師減肥指南(?)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@threath/%E5%AF%AB%E7%B5%A6%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9C%8B%E7%9A%84%E6%B8%9B%E8%82%A5%E6%8C%87%E5%8D%97-part-1-%E4%B8%8D%E9%81%8B%E5%8B%95%E6%B8%9B%E6%8E%89-16kg-79c8871cd5f5&#34;&gt;寫給工程師看的減肥指南 — Part 1 不運動減掉 16kg - Sean Cheng&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@threath/%E5%AF%AB%E7%B5%A6%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9C%8B%E7%9A%84%E6%B8%9B%E8%82%A5%E6%8C%87%E5%8D%97-part-2-%E7%94%9F%E9%85%AE%E7%90%86%E8%AB%96-%E8%83%B0%E5%B3%B6%E7%B4%A0%E7%90%86%E8%AB%96-16280c0de7ee&#34;&gt;寫給工程師看的減肥指南 — Part 2 生酮理論 + 胰島素理論 - Sean Cheng&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@threath/%E5%AF%AB%E7%B5%A6%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9C%8B%E7%9A%84%E6%B8%9B%E8%82%A5%E6%8C%87%E5%8D%97-part-3-%E8%85%B8%E9%81%93%E8%8F%8C%E7%90%86%E8%AB%96-d27c65b82249&#34;&gt;寫給工程師看的減肥指南 — Part 3 腸道菌理論 - Sean Cheng&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我喜歡這系列的點在於，第一篇作者就直接列出影響他最大的幾個減肥理論，然後還分享了從 2020 到 2022 的歷程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在前面半年我就擬定了大方向，後面則是陸續補齊完整概念、建立專屬於自己個人的理論。&lt;br/&gt;總結起來，影響我最大的三個減肥理論是：&lt;/p&gt;
&lt;p&gt;生酮理論 + 胰島素理論：&lt;br/&gt;人可以使用油脂當作身體能量，因此幾乎不吃澱粉也能活的好好的。&lt;/p&gt;
&lt;p&gt;腸道菌理論：&lt;br/&gt;每個人的腸道菌相不同，因此即使吃入相同的東西，吸收的熱量、營養成分卻不會一樣。&lt;/p&gt;
&lt;p&gt;細胞層級的代謝理論：&lt;br/&gt;人使用油脂當身體能量的能力，和呼吸習慣、細胞油脂組成、粒線體數量有關。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;針對這些理論，在後續也逐項進行說明。並且引用了一些影片（或是說，很多影片），可以馬上就連出去科普科普：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=VzPD009qTN4&#34;&gt;How Bacteria Rule Over Your Body – The Microbiome - youtube&lt;/a&gt;&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/VzPD009qTN4&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;在第一篇也有把要做的事、別做的事情清楚地列出來，而第二篇、第三篇也有很好懂的說明。例如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;勞力工作者主要使用醣類當作日常能量，在活動時使用肌肉、肝臟中的儲存的肝醣，並在吃飯時透過進食澱粉、水果、肉類(可轉換成醣)補充回來，每天的生活循環可能如下：&lt;/p&gt;
&lt;p&gt;吃午飯(醣類補充到 80%) → 勞力工作(醣類降低到 30%) → 吃晚餐 (醣類補充到 80%) → 睡覺8小時(醣類降低到 60%) → 吃早餐(醣類補充到80%)…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;但在國家發展到以知識型產業為工作主體的情況下，大多數人的生活型態已經完全不適合每天吃大量澱粉，因為其醣類循環狀況會變成下面這樣：&lt;/p&gt;
&lt;p&gt;吃午飯(醣類補充到 110%) → 坐著工作(醣類降低到 100%) → 吃晚餐 (醣類補充到 120%) → 睡覺8小時(醣類降低到 95%) → 吃早餐(醣類補充到110%)…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我個人還有下午茶、點心跟宵夜，都不知道補充到幾 % 去了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;前陣子體檢一卡車紅字，最近也一直覺得身體怪怪的。在前天翻延壽指南的時候，順著找到了這篇，感覺多少認識了一些新知識（當然，有沒有身體力行又是另一回事 xD），也轉貼上來給各位朋朋們參考。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【每天推薦一篇文章】寫了無限 alert 迴圈竟然要被抓？！</title>
      <link>https://igouist.github.io/repost/2024/03/0328-alert-alert-alert/</link>
      <pubDate>Thu, 28 Mar 2024 21:05:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/repost/2024/03/0328-alert-alert-alert/</guid>
      <description>&lt;p&gt;今天頭還是很暈，簡單分享一下今天看到的有趣文章：&lt;br/&gt;
&lt;a href=&#34;https://blog.kalan.dev/posts/2022-01-23-infinite-alert-loop&#34;&gt;無限 alert 迴圈事件 - Kalan&amp;rsquo;s Blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這件事發生在日本：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 2019 年三月，兵庫縣警以在電子留言板上放上有惡意程式碼的連結有不正指令電磁的記録供用未遂之疑，到女國中生家搜索，並搜查兩名男性後送檢。3/25，日本黑客協會開始募集兩名男性的律師費用及官司費用，總共募到了 553 人共 700 萬日圓的金額。 在同年 5/29 兩位男性以緩起訴處分，此案件沒有任何受害者。&lt;/p&gt;
&lt;p&gt;根據其中一位男性的說法，檢察官認為「對某些手機型號來說，一旦點擊連結後有可能沒辦法關閉畫面，或是需要拿去維修甚至是拜託專家，&lt;strong&gt;違反了電腦病毒罪當中的要件『反意圖性』&lt;/strong&gt;。」，對於「不正指令電磁的記録供用罪」的主張沒有改變。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;竟然違反了「不正指令電磁的記録供用罪」，究竟是怎樣的程式呢：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;window.alert&lt;/code&gt; 能夠接收指定的字串，並顯示一個具有 OK 按鈕的對話框。按下 OK 按鈕之後就能夠把對話框關閉。&lt;/p&gt;
&lt;p&gt;這個程式是無限迴圈，因此關閉對話框之後，又會再出現對話框，這個行為會持續到使用者關閉瀏覽器分頁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就是這樣。還敢寫出無限彈跳窗啊 xD&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【每天推薦一篇文章】人體系統優化指南</title>
      <link>https://igouist.github.io/repost/2024/03/0327-human-system-optimization/</link>
      <pubDate>Wed, 27 Mar 2024 23:29:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/repost/2024/03/0327-human-system-optimization/</guid>
      <description>&lt;p&gt;今天頭超暈的，想說來貼個相關的文章(?)&lt;br/&gt;
&lt;a href=&#34;https://github.com/zijie0/HumanSystemOptimization&#34;&gt;人体系统调优不完全指南 (zijie0/HumanSystemOptimization) - Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這篇整理了要健健康康活下去(?)的一些相關知識，例如睡眠、飲食、動力、學習。&lt;/p&gt;
&lt;p&gt;並且每個小節都有原理說明和實踐方式。例如睡眠這一小節，就會先提到生物鐘、光照和體溫。接著列出該做的內容，像是起床需要先接觸陽光、晚上要減少光源接觸等等&lt;/p&gt;
&lt;p&gt;而心態和動力這節，就會提到我們 &lt;a href=&#34;https://igouist.github.io/repost/2024/03/0320-dopamine&#34;&gt;3/20 轉貼過的多巴胺&lt;/a&gt;、會影響的飲食，然後接到利用多巴胺的機制來提升自我等等&lt;/p&gt;
&lt;p&gt;文章整體有點長，但分小節看的話其實也蠻快的。對各個術語有興趣的話也可以再進一步搜尋，感覺還是挺不錯的，就轉貼上來給各位朋朋&lt;/p&gt;
&lt;p&gt;另外再補一篇相關閱讀（&lt;del&gt;方便我筆記關聯&lt;/del&gt;）：&lt;br/&gt;
&lt;a href=&#34;https://github.com/geekan/HowToLiveLonger&#34;&gt;geekan/HowToLiveLonger (程序员延寿指南) - Github&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【每天推薦一篇文章】如何發想解決方案？</title>
      <link>https://igouist.github.io/repost/2024/03/0326-how-to-ideate-and-come-up-with-product-solutions/</link>
      <pubDate>Tue, 26 Mar 2024 21:41:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/repost/2024/03/0326-how-to-ideate-and-come-up-with-product-solutions/</guid>
      <description>&lt;p&gt;前幾天丟了滿多篇文章到收件閘裡，今天就先從最有興趣的這篇開始讀起：&lt;br/&gt;
&lt;a href=&#34;https://medium.com/3pm-lab/how-to-ideate-and-come-up-with-product-solutions-573fa800a62d&#34;&gt;如何發想解決方案？產品團隊的創意思考流程！ - 3PM LAB 產品三眼怪實驗室&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這篇一打開就看到熟悉的雙鑽石（上次看到還是在《柔型要術》的時候）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/6/65/Double_Diamond_by_the_Design_Council.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;DISCOVER（發散）：透過使用者研究、市場研究來探索問題與機會&lt;/li&gt;
&lt;li&gt;DEFINE（聚焦）：根據前一步驟蒐集到的資訊來定義問題與場景，聚焦至一個待解決的問題&lt;/li&gt;
&lt;li&gt;DEVELOP（發散）：發想各種解決問題的方法、滿足使用者需求的手段&lt;/li&gt;
&lt;li&gt;DELIVER（聚焦）：製作 Prototype 並測試、進行實驗，透過使用者/市場的回饋推進與聚焦至我們最終想要推出的變動或功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;緊接著的這一小段我覺得很不錯，很有敏捷的 feel：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;發想解法的步驟並不是單一流程的「想出一個解法」，也不是「想出很多個解法，挑一個最棒的出來」，而是 &lt;strong&gt;「想出很多個解法，先挑一個我們認為最棒的出來，用很小的成本讓使用者測試，如果實驗成功就繼續發展；如果實驗失敗就從其他解法再挑下一個出來測試」&lt;/strong&gt; 這樣一個不斷迭代的過程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但要實驗各式各樣的想法，首先要先有夠多的解法。這篇文章介紹了幾種「好想法從何而來」的途徑，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;實務經驗累積：「累積的經驗愈多，每當遇到一個新問題，你可以延伸出來的子議題、思考方向、點子就愈多」&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;產品和競品研究：「研究其他軟體產品、競爭對手的產品，學習與參考他們的解決方法，或是從類似用途的元素中找到發想的靈感」&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;創意發想的工具與框架：「透過一些創意發想的工具與框架，產出大量同時又充滿廣度的點子，能夠逼迫我們探索更多的可能性」&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而在工具和框架這部份，這篇文章也分享了一些發想工具。例如心智圖、嘔吐法、丟出爛點子等等&lt;/p&gt;
&lt;p&gt;並且文內對每項工具都標上了使用情境和說明，有興趣的朋友可以看看。我個人則特別存了這段：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下班就該下班了其實，但為什麼上班的時候想不出這些東西呢？&lt;/p&gt;
&lt;p&gt;之前上《Learning How To Learn》這個線上課程時，裡面提到了專注模式（Focused Mode）和發散模式（Diffuse Mode）這兩種腦袋的運作方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;專注模式：當我們集中注意力時，會用已知的方法、經驗來解決我們熟悉的問題&lt;/strong&gt;，一般來說上班、上課都是處在這個模式之下，思想會照著既定的迴路在走。如圖所見，大腦此時會集中在某一部分的神經區塊中工作，此外腦內組織起來的東西（類似釘子）也比較多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;發散模式：當我們注意力較分散的時候，腦內的釘子減少了、也變得不規則，思想可以移動的空間變大、範圍變廣、也較隨機&lt;/strong&gt;。這個模式適合在面對陌生問題時，幫助我們找到新的觀點，從更廣、更綜觀、更自由的角度去思考，也較有利於創意發想。&lt;/p&gt;
&lt;p&gt;我們的大腦同一時間只會處在其中一種模式中，因此學習如何有效的切換到不同模式，將有利於幫助自己用更有創造力的方式解決難題。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就是這樣，我要去開 Steam 發散一下了，明天見～&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【每天推薦一篇文章】Airtable: 簡單的需求用簡單的儲存工具</title>
      <link>https://igouist.github.io/repost/2024/03/0325-airtable/</link>
      <pubDate>Mon, 25 Mar 2024 23:26:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/repost/2024/03/0325-airtable/</guid>
      <description>&lt;p&gt;今天也弄得挺晚才開工，還好今天有前輩發了一篇有趣的文：&lt;br/&gt;
&lt;a href=&#34;https://studyhost.blogspot.com/2024/03/airtable.html&#34;&gt;使用 Airtable 在小型需求上取代傳統資料庫 - .NET Walker&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主要讓我覺得有趣的是這一句話：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;傳統的關聯式資料庫，其實對於教育訓練和小型的專案來說，是一種負擔。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;仔細想想也蠻有道理，有時候我只是想示範一下某些工具簡單的操作，但只要想把東西存起來，就有種「好像該丟到資料庫？」的感覺&lt;/p&gt;
&lt;p&gt;但就像這篇說的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;如果你做一個小型專案或POC的話，『儲存』也往往不是重點，儲存只是『必要之惡』。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其實，若是從這個角度廣義的來說，軟體開發的GUI、資料庫，都只是細節(枝微末節)，都應該要是可以隨時被抽換或取代的部分，而非系統核心。&lt;/p&gt;
&lt;p&gt;一套軟體或解決方案的真正核心，是商業邏輯。它(商業邏輯)才是一個應用程式真正展現價值的部分。&lt;/p&gt;
&lt;p&gt;我們把主題拉回來。所以，我最近這幾年在上課的時候，盡量不讓範例程式碼涉及資料庫存取，特別是關聯式資料庫的存取。因為這對讀者或學員來說，變成了另一種必須學習的負擔。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果只是做一個簡單的 POC，的確不該把重點放在儲存工具上。而在這篇文章裡，作者使用了簡單輕便的雲端工具 Airtable 來處理掉儲存體的部份&lt;/p&gt;
&lt;p&gt;Airtable 可以簡單地呼叫 REST API 來處理掉 CRUD 的操作，可以說是無腦開箱即用。&lt;br/&gt;（是不是也該來嘗試看看xD）&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【每天推薦一篇文章】讓數據幫你決策</title>
      <link>https://igouist.github.io/repost/2024/03/0323-let-data-guide-your-decision-making/</link>
      <pubDate>Sun, 24 Mar 2024 00:09:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/repost/2024/03/0323-let-data-guide-your-decision-making/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://medium.com/3pm-lab/data-analytics-on-product-manager-decision-making-a8cce5f30122&#34;&gt;【PM 總動員】讓數據幫你決策：產品經理也懂的數據分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這邊文章把數據決策分析拆出四個步驟：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Step 1. 問題與指標拆解、訂定假設&lt;/li&gt;
&lt;li&gt;Step 2. 維度觀察與指標計算&lt;/li&gt;
&lt;li&gt;Step 3. 發現梳理與解讀&lt;/li&gt;
&lt;li&gt;Step 4. 資料呈現與視覺化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每個階段都有進一步的說明。例如在第一個步驟，我們開始前要問三個問題：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;問題與目標 (Question &amp;amp; Goal)：我想知道的問題是什麼? 目標是什麼?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假設 (Hypothesis)：我到底想看什麼樣的數據?是基於什麼觀察與假設？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;行動 (Next Steps)：如果數據撈出來了，會怎麼影響我的下一步?分析完的決策可能是什麼?&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;在第二步驟的指標計算裡，需要在第一步驟的「想看什麼樣的數據」時就進一步設想實際需要的數字。以文章內的電商背景為例，就像：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我想知道最近三個月中，每月成交次數都 ≥ 5 次的用戶 (=消費次數高的高頻用戶)，分別是買了哪些商品類型，不同性別的用戶人數有多少，而平均購買商品數又是多少?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;當拿到資料並且確認沒問題之後，進入第三步驟，開始解讀。解讀的發現我看得是有點玄(?)。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這很仰賴產品經理對用戶的理解、以及對產品與市場的敏銳度，其中也包含一部分的行動方針，但不管如何儘管大膽假設，之後再小心求證即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但除了這部份以外，整體的解讀方式「嘗試做圖進行分析、找出特徵，然後列出發現，和之前的假設互相比對…」這個流程解釋得很好理解。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;如果前面的步驟發現了好東西，就可以來搞第四步驟的資料呈現與視覺化。我覺得重點就在於示範前的這句：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可視化與圖像化就是把「數據」變成「資訊」、成為輕鬆說服他人的有利工具，但不是把圖拉出來就好，而是&lt;strong&gt;思考怎麼樣的呈現能讓看的人不帶腦、一眼就看出重點，甚至是默默認同你想強調的論點&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上把這篇文章的流程簡化很多，文章內從一個範例背景開始走完四個步驟，過程中列出很多舉例和說明，讓讀者能夠迅速理解這四個步驟&lt;/p&gt;
&lt;p&gt;例如我在這邊文章就認識了決定使用者行為動機的模型「Fogg’s Behavior Model」：&lt;br/&gt;
&lt;strong&gt;&lt;code&gt;Behavior(行為) ＝ Motivation(動機) * Ability(能力) * Prompt(提示)&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;感覺相當不錯，已收藏。也推薦有興趣的朋朋閱讀。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【每天推薦一篇文章】如何面試一間公司</title>
      <link>https://igouist.github.io/repost/2024/03/0322-a-developer-s-guide-to-interviewing/</link>
      <pubDate>Fri, 22 Mar 2024 21:54:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/repost/2024/03/0322-a-developer-s-guide-to-interviewing/</guid>
      <description>&lt;p&gt;今天閱讀效率有點不大行，決定來推薦一些實際幫助(?)的文章：&lt;br/&gt;
&lt;a href=&#34;https://blog.louie.lu/2017/04/30/%E9%96%8B%E7%99%BC%E4%BA%BA%E5%93%A1%E7%9A%84%E9%9D%A2%E8%A9%A6%E6%8C%87%E5%8D%97-a-developers-guide-to-interviewing/&#34;&gt;開發人員的面試指南 – A developer’s guide to interviewing - louie_lu&amp;rsquo;s blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這篇的內容非常直接：&lt;strong&gt;如何面試一間公司&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你有沒有過，當你在面試的時候，面試官坐在桌子對面，雙眼注視著問你：「你還有其他問題嗎？」，而你回眼回去並說：「umm, 大概沒有了」。如果這曾經發生在你身上，你有很大的機率得到了一個單一面向的面試經驗。&lt;/p&gt;
&lt;p&gt;作為一個應試者，可以想見你把目標放在一件事情上：取得工作職缺。但是別忘記，面試並不是一個單向的工作。&lt;strong&gt;如同面試官在面試你，你也必須要面試公司。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不過，你需要問他們什麼呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;首先我們要先搞清楚：我們對話的對象是誰？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根據對象是軟體工程師 or 管理階層 or 公司領導，這篇文章準備不同的問題，並且每個問題都有簡單直接的描述來幫助你了解&lt;/strong&gt;，有些還有延伸問題或判斷標準&lt;/p&gt;
&lt;p&gt;例如對軟體工程師的問題，其中一題是：「你喜歡在這邊工作嗎？」，而根據回答分成了強指標跟弱指標：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;強指標：我從我的工作中獲得許多成就。&lt;br/&gt;
強指標：我們的工作很有趣。&lt;br/&gt;
（略）&lt;br/&gt;
弱指標：他付我薪水。&lt;br/&gt;
弱指標：這裡沒有太大的壓力來提交成果。&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我最驚訝的是這點：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不要以為我在虎爛，我真的在面試時聽過這些答案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;del&gt;一些奇怪的面試回憶突然湧現&lt;/del&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;當然，針對開發人員也有像是「你們寫單元測試嗎？」「你們有持續整合嗎？」的這些題目（及延伸題目，例如執行時間）&lt;/p&gt;
&lt;p&gt;有幾個問題還是我真沒想過的，例如「你的下一個 deadline 在什麼時候？誰設定這個 deadline？」&lt;/p&gt;
&lt;p&gt;或是問管理階層「你手下的工程師如何得知每日該做什麼？」來比對開發人員回答的答案（這算一種分開訊問嗎？）&lt;/p&gt;
&lt;p&gt;如果最近有在面試，也許可以參考看看。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【每天推薦一篇文章】貧血模型與充血模型</title>
      <link>https://igouist.github.io/repost/2024/03/0321-anemic-domain-model/</link>
      <pubDate>Thu, 21 Mar 2024 23:16:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/repost/2024/03/0321-anemic-domain-model/</guid>
      <description>&lt;p&gt;今天剛好跟同事聊到充血模型的概念，決定轉貼小朱大的這篇，順手收進我的筆記庫：&lt;br/&gt;
&lt;a href=&#34;https://dotblogs.com.tw/regionbbs/2021/05/29/anemicdomainmodel&#34;&gt;這裡貧血、那裡充血，到底資料模型要怎麼設計？ - 小朱® 的技術隨手寫&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先我們先看一下貧血模型的部份，比較常見的應該就是單純放一下資料用的 DTO（Data Transfer Object）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;貧血模型之所以為貧血，其最大原因是，&lt;strong&gt;不論是 DTO 或是 POCO，它的業務邏輯都操控在別人手上，自己沒辦法去維護自己的業務規則&lt;/strong&gt;，以上面 DTO 或 POCO 作為例子，它們都沒有內建的處理存款與提款的程式碼，都要倚賴外部程式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;當業務邏輯只能由別人處理時，相對的就破壞了這個領域知識的內聚力，也提高了向外的耦合性，而且它並沒有辦法自我處理自己的領域知識，在後續系統的擴充與延長時，若與別人共用這個模型時，別人也一樣要實作這類領域知識，從而發生領域知識不一致的可能，導致系統設計的風險。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此，若系統內的業務邏輯、流程或知識會有共用的可能性時，就應該要考慮以領域模型的方式設計，而不是使用 DTO 或 POCO 的設計作法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;而相對的，充血模型則是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所謂的充血模型，只是大家在學校學過物件導向程式設計中，具有足夠內聚力的類別而己，但用一個新名詞來講，一個平凡無奇的概念突然瞬間高大上了起來。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一個充血模型，封裝 (Encapsulation) 的特性會十分明顯，它該有的資料就是它自己維護，外部想要對這個模型的資料做異動，就只能使用它所開放的方法 API 執行&lt;/strong&gt;…這不就教科書上說的嗎？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在最後一段，小朱大有列出這兩種模型適用的時機。&lt;/p&gt;
&lt;p&gt;例如說，應用程式很小、資料單純的時候，就可以考慮貧血模型；而如果某些領域知識會需要重複使用的時候，就可以考慮充血模型等等，有興趣的朋友可以再點進去參考一下。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;之前在維護三層式的專案時，各層之間都是用 DTO 來傳遞資料。就像工廠流水線一樣，到了某一段就把資料倒出來處理處理，然後塞到另一個 DTO 傳到下一站。&lt;/p&gt;
&lt;p&gt;後來到了現在的公司，才接觸到貧血充血這些名詞。但想想物件會動(?)好像也是理所當然的…吧？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>我買彩券是為了做一個善良的人</title>
      <link>https://igouist.github.io/post/2024/01/lottery-is-goodness/</link>
      <pubDate>Sat, 03 Feb 2024 12:02:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2024/01/lottery-is-goodness/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/IHUANWS.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我買彩券是為了做一個善良的人&lt;/strong&gt;&lt;br/&gt;
只要還沒開獎，我就有可能會成為億萬富翁&lt;/p&gt;
&lt;p&gt;有緊急需求？沒問題&lt;br/&gt;
東西又改壞了？沒關係&lt;br/&gt;
客戶跑來罵我們全家？當然可以&lt;/p&gt;
&lt;p&gt;一個買了彩劵的人，生活充滿希望，行事滿懷善良，心胸寬大、舉止謙讓&lt;/p&gt;
&lt;p&gt;畢竟我說不定晚上就發財了，沒必要跟你們計較這些小事。對吧&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>臥龍：蒼天殞落　白金！</title>
      <link>https://igouist.github.io/post/2023/04/wolong/</link>
      <pubDate>Wed, 05 Apr 2023 10:00:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2023/04/wolong/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/UU9opuT.jpg&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;在東漢逛街快一個月，總算白金啦！&lt;/p&gt;
&lt;p&gt;這次臥龍玩起來還算挺爽快的，從第一隻 Boss 張梁老師就好好教導玩家的基礎操作。而且意外地能從黃巾之亂一路做到官渡之戰，前期戰役打好打滿，算是蠻有誠意的。&lt;/p&gt;
&lt;p&gt;白金之後就開始期待後續的三個 DLC 跟二代了。畢竟三國題材這麼多，實在不怕沒有後作嘛，但 DLC 還要等到六月，這篇就來稍微紀錄一下心得吧。&lt;/p&gt;
&lt;h2 id=&#34;戰鬥化解&#34;&gt;戰鬥＝化解&lt;/h2&gt;
&lt;p&gt;這次戰鬥主打的是「化解」系統，基本上就是在敵人攻擊的瞬間進行化解，很有中國武術的味兒，也讓我想起隻狼鼓勵玩家要提起勇氣上前拚刀的快感。&lt;/p&gt;
&lt;p&gt;初次接觸的時候會覺得這系統做得很不錯，同時帶來了風險和回報：化解失敗就會被捅一刀，而化解成功就可以提升氣勢（可以當成能量條，做任何動作都會消耗），並且得到進攻機會。&lt;/p&gt;
&lt;p&gt;除此之外，化解殺招的畫面也很帥，敵人釋放絕招然後主角行雲流水擋掉回擊，很有觀賞樂趣。&lt;/p&gt;
&lt;p&gt;因此整個遊戲的主軸就是化解敵人的攻擊和殺招，你來我往地進攻，整個戰鬥就是化解的節奏，打起來挺爽快的。&lt;/p&gt;
&lt;p&gt;到這裡我都還是覺得化解真香。但到中後期的時候就開始發現：整個戰鬥過程，就只有化解。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用 Midjourney AI 繪圖 &amp; Canva 產生 Banner 初體驗</title>
      <link>https://igouist.github.io/post/2023/01/banner-2-midjourney-and-canva/</link>
      <pubDate>Sun, 29 Jan 2023 10:01:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2023/01/banner-2-midjourney-and-canva/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/MqLSU3f.jpg&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;我們在&lt;a href=&#34;https://igouist.github.io/post/2023/01/banner-1-system-drawing/&#34;&gt;前一篇&lt;/a&gt;嘗試自行產生簡單的文字 Banner，我也用了好一陣子（畢竟三年前的新訓文章還是沒整理完嘛）。&lt;/p&gt;
&lt;p&gt;直到前陣子逛臉書的時候，看到有人說「我都改用 &lt;strong&gt;AI 繪圖工具來產生部落格的配圖&lt;/strong&gt;了，還沒有版權問題」當下驚為天人：對呀！這不是很不錯嗎！&lt;/p&gt;
&lt;p&gt;如此如此，這般這般。立馬開始爬文來嘗試神秘的 AI 繪圖囉！&lt;/p&gt;
&lt;h2 id=&#34;初嘗試-midjourney&#34;&gt;初嘗試 Midjourney&lt;/h2&gt;
&lt;p&gt;在網路搜了一下，發現有大神已經整理 Midjourney 入坑詳細步驟，特此感謝：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.akanelee.me/2023/01/22/ai-midjouyney-tutorial-instruction/&#34;&gt;AI 繪圖教學，Midjourney 基本操作 · 嫁給 RD 的 UI Designer (akanelee.me)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這邊就稍微紀錄一下，總之先衝到 &lt;a href=&#34;https://www.midjourney.com/home/&#34;&gt;Midjourney&lt;/a&gt;，然後直接註他個冊、登他個入：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/L4aChGM.jpg&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用 .Net 的 System.Drawing 產生簡單的文字 Banner 初體驗</title>
      <link>https://igouist.github.io/post/2023/01/banner-1-system-drawing/</link>
      <pubDate>Sun, 29 Jan 2023 10:00:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2023/01/banner-1-system-drawing/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/aAfz8Dy.jpg&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;原本我都是用產生 FB 封面的「康熙字典體產生器」來做簡單的文字 Banner，就拿來當作文章的封面照&lt;/p&gt;
&lt;p&gt;用了好一陣子也沒啥問題。結果某天文章寫好，吃著火鍋唱著歌，產生器打開一看，服務竟然就沒了！&lt;/p&gt;
&lt;p&gt;當下是一個震驚啊，一氣之下決定直接打開 Linqpad 寫一個。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;註：現在搜尋康熙字典體產生器，還查得到介面截圖，還真的蠻簡單方便的 Q_Q&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以前面的菜雞與物件導向系列 Banner 為例，我們大概需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;產生一張圖&lt;/li&gt;
&lt;li&gt;在圖上面放主標題和副標題&lt;/li&gt;
&lt;li&gt;關鍵字可以上色&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/LiILeSl.jpg&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;稍微搜尋一下發現 .Net 已經有 System.Drawing 這個工具可以幫我們完成這些簡單的圖片任務，事不宜遲馬上就來嘗試！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Polyglot Notebooks －－ 在 VSCode 簡單迅速地撰寫 C# 腳本吧</title>
      <link>https://igouist.github.io/post/2023/01/polyglot-notebooks/</link>
      <pubDate>Sat, 28 Jan 2023 18:00:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2023/01/polyglot-notebooks/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/vZzccvm.jpg&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;像我這樣的菜鳥工程師，&lt;strong&gt;在 Coding 的時候時常會需要簡單試一些想法&lt;/strong&gt;。像是「我這邊下了這串 Linq 出來的資料，到底是不是我想要的內容啊 = =？」&lt;/p&gt;
&lt;p&gt;或是在進行開發任務時：「這個步驟能不能這樣做啊？先拆個簡單的 Method 試試看好了」之類的&lt;/p&gt;
&lt;p&gt;以往遇到這種時候，我都會打開香香的 &lt;a href=&#34;https://kevintsengtw.blogspot.com/2011/09/linqpad-net.html&#34;&gt;Linqpad&lt;/a&gt; 直接無情開寫，快速地作個小小的概念驗證。&lt;/p&gt;
&lt;p&gt;畢竟 Linqpad 可以迅速地開始撰寫簡單的 C# 腳本，並且有良好的語法提示、Nuget 支援和方便的資料庫連線，省去我還要開一個 Console 專案自己弄這些東西，更可以存著之後備查，所以一直以來我都愛不釋手。&lt;/p&gt;
&lt;p&gt;但在因緣際會下（其實就是閒逛論壇的時候），發現了微軟把拔出的 &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.dotnet-interactive-vscode&#34;&gt;Polyglot Notebooks&lt;/a&gt; 這款 VSCode 擴充套件。當下驚為天人！Linqpad 在我心中的地位就這麼動搖了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Polyglot Notebooks 可以讓我們直接在 VSCode 上面撰寫簡單的 C#、F#、JavaScirpt 等腳本、迅速驗證想法。甚至可以對程式碼分段、加入 Markdown 文檔，讓我們能更有邏輯、有步驟地撰寫我們的腳本、處理我們的資料。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它的特色是這麼對我的胃口，看來我以後鐵定是會用到的。現在就來簡單記錄 Polyglot Notebooks 的使用方式吧！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>仁王＆仁王２　白金！</title>
      <link>https://igouist.github.io/post/2023/01/nioh/</link>
      <pubDate>Thu, 26 Jan 2023 09:20:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2023/01/nioh/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/oAG7u0v.jpg&#34; alt=&#34;Image&#34;&gt;
&lt;img src=&#34;https://i.imgur.com/LylqTob.jpg&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;終於趁著這次連假白金啦囧&lt;/p&gt;
&lt;p&gt;在法環的白金文有提到過，我真的很懶得刷一些要農、重複蒐集東西的成就。偏偏仁王和仁王２後期都在做這兩件事情，結果兩款的主線過完之後就進入無限拖延狀態&lt;/p&gt;
&lt;p&gt;尤其像仁王２的主線通關成就早在 2021/9/18 就拿到了，ＢＯＳＳ也都挑戰完一輪，但想到後面有一堆跟仁王１一樣要蒐集的東西，就一路拖到現在 2023/1/24 才農出白金&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/wXNOUE7.jpg&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;仁王系列給我的感覺很特別，它&lt;strong&gt;在前期的時候是個完完全全的魂系遊戲&lt;/strong&gt;：容易死亡、要熟悉ＢＯＳＳ招式、要思考打法、重複挑戰和修正等等&lt;/p&gt;
&lt;p&gt;但差不多一周目過完之後，&lt;strong&gt;中後期就會開始往暗黑那種刷裝、配裝的方向走&lt;/strong&gt;。所以最佳方針就是一路打上高難度、農出可以搭配的裝、然後大功告成輾壓眾生。到這個階段已經沒有什麼魂系遊戲的味道了，樂趣變成是嘗試各種裝備的搭配和打法，完全變成另一款遊戲&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《軟實力：軟體開發人員的生存手冊》心得</title>
      <link>https://igouist.github.io/post/2022/11/soft-skills/</link>
      <pubDate>Sun, 27 Nov 2022 00:00:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2022/11/soft-skills/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/BngpHxv.jpg&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這是一本你從未見過的軟體開發書。
&lt;br/&gt;
        
      
－－《軟實力：軟體開發人員的生存手冊》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這本書其實已經借來兩年了（隔壁 &lt;a href=&#34;https://sunnyday0932.github.io/2020/%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97_soft-skills-%E8%BB%9F%E5%AF%A6%E5%8A%9B%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC%E4%BA%BA%E5%93%A1%E7%9A%84%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8A/&#34;&gt;Sian&lt;/a&gt; 心得文已經發了多久，就代表我借了多久），不過因為有一個指節那麼厚，我又是這麼的懶，因此就放在書櫃中睡了兩年，直到最近才終於捧起來看。&lt;/p&gt;
&lt;p&gt;直接先說感想：驚為天人。&lt;strong&gt;這本書的內容就像是一篇接著一篇的部落格文章&lt;/strong&gt;，但每篇之間又是環環相扣的，彷彿某種連載短篇一樣，會讓人一直看下去。&lt;/p&gt;
&lt;p&gt;對於這本書的內容，我推薦有興趣的朋友、或是喜歡閱讀部落格的朋友可以自己去試閱看看（今年剛好也出了第二版）；這邊就來聊聊我覺得這本書比較特別的部份吧！&lt;/p&gt;
&lt;h2 id=&#34;神奇的內容廣度&#34;&gt;神奇的內容廣度&lt;/h2&gt;
&lt;p&gt;首先一定要從這本書神奇的內容廣度開始說起，&lt;strong&gt;從常見的職涯建議、自我行銷，到健身、理財都有。完全對得起「生存手冊」的名稱&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;為了讓各位可以感受一下這個衝擊，這邊就條列出本書的章節目錄，並且附個一兩項裡面提到的內容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;職涯&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;如何把職涯當作企業經營？如何成為自由工作者？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自我行銷&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;如何打造個人品牌？為什麼幫助別人如此重要？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;學習&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;什麼是十步學習法？指導別人有什麼好處？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生產力&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;什麼是番茄工作法？為什麼培養習慣這麼重要？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;理財&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;什麼是選擇權？如何投資房地產？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;健身&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;為什麼工程師需要健身？怎麼計算卡路里？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;心靈&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;什麼是自我形象？我們該如何樹立理想的形象？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;從目錄就可以看出來，這本書能夠給軟體工程師們為了生存所接觸到各個領域的簡介、讓讀者能快速對這些領域都有基本的概念。藉由這些基本概念，就可以根據這些方向來做進一步的了解。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用 JMeter 來對 API 壓力測試吧</title>
      <link>https://igouist.github.io/post/2022/10/jmeter/</link>
      <pubDate>Mon, 10 Oct 2022 18:50:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2022/10/jmeter/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/sMw5vbw.jpg&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;前陣子協助某支 API 的壓力測試，趁機請 QA 朋朋指導指導一下，因此接觸了這款簡單好用的壓測工具 JMeter，趁現在記憶還在的時候記錄起來。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;往後其他同事只要說 API 弄好了可以串了，就先幫他打個一萬次壓壓驚，真是貼心&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://jmeter.apache.org/&#34;&gt;JMeter&lt;/a&gt; 是款充滿暴力的壓力測試工具，只要告訴他：你要揍哪支 API？要揍幾拳？揍他個幾輪？它就會忠實地對你指定的 API 爆打一頓。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Sony WH-1000XM5 使用一週心得</title>
      <link>https://igouist.github.io/post/2022/10/sony-wh-1000xm5/</link>
      <pubDate>Sat, 01 Oct 2022 20:00:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2022/10/sony-wh-1000xm5/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/rixivwP.jpg&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;在某個風和日麗的午後，同事讓我試戴他的 XM5，當我戴上去聽了兩秒音樂，&lt;strong&gt;就明白我已經犯了錯&lt;/strong&gt;，而且無法回頭。&lt;/p&gt;
&lt;p&gt;過了幾天，這副耳機就出現在我家門口，到今天已經過了一週，就讓我來紀錄一下小小心得吧。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在 Chrome 使用翻譯套件 ImTranslator 的嵌入式翻譯來逐行中英對照吧</title>
      <link>https://igouist.github.io/post/2022/09/imtranslator/</link>
      <pubDate>Sun, 18 Sep 2022 10:55:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2022/09/imtranslator/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/0XXKTrd.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;嗨各位朋朋，又到了替文章數灌水的好用工具時間！&lt;/p&gt;
&lt;p&gt;今天要介紹的是 &lt;a href=&#34;https://chrome.google.com/webstore/detail/imtranslator-translator-d/noaijdpnepcgjemiklgfkcfbkokogabh?hl=zh-TW&#34;&gt;ImTranslator&lt;/a&gt;，它是一款 Chrome 的翻譯套件。由於有&lt;strong&gt;嵌入式翻譯（Inline Translator）&lt;/strong&gt;，意外地在辦公室的詢問度還蠻高的，這就來寫一篇介紹來推廣給和我一樣英文苦手的朋朋們！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用 Azure Functions &#43; Line Notify 來定時提醒公車到站時間</title>
      <link>https://igouist.github.io/post/2022/09/bus-reminder-2-azure-functions-timetrigger-with-line-notify/</link>
      <pubDate>Mon, 12 Sep 2022 23:51:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2022/09/bus-reminder-2-azure-functions-timetrigger-with-line-notify/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/WX17auT.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上週的 &lt;a href=&#34;https://igouist.github.io/post/2022/09/bus-reminder-1-powershell-and-windows-task-scheduler&#34;&gt;使用 Powershell + 工作排程器 + Line Notify 來定時提醒公車到站時間&lt;/a&gt;，我們利用工作排程器來定時觸發腳本，藉此用 Line 提醒我下班的公車還有多久才來。&lt;/p&gt;
&lt;p&gt;做完之後靈機一動，對呀！最近上班挺常接觸到 &lt;a href=&#34;https://azure.microsoft.com/zh-tw/services/functions/&#34;&gt;Azure Functions&lt;/a&gt; 這個方便東東，不如就把這個小提醒給架設到 Azure Functions 上吧！&lt;/p&gt;
&lt;p&gt;這樣就省卻了特定主機要開著掛工作排程器的困擾，又可以用香香的 Azure 工具來控制監聽的開關，豈不美哉。&lt;/p&gt;
&lt;p&gt;如此如此這般這般，讓我們開始建立 Azure Functions 服務吧！&lt;/p&gt;
&lt;h2 id=&#34;建立-azure-functions-資源&#34;&gt;建立 Azure Functions 資源&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Azure Functions 是 Azure 推出的一款無伺服器（Serverless）服務，簡單來說就是伺服器之類的麻煩事就交給 Azure 去處理，我們只要專心寫功能就好&lt;/strong&gt;。對我這種愛寫小腳本的偷懶工程師來說，可以說是香到爆的服務。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小提醒：Azure Functions 是一款收費服務，使用前請務必確認&lt;a href=&#34;https://azure.microsoft.com/zh-tw/pricing/details/functions/&#34;&gt;定價&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在這篇文章撰寫當下，Azure Functions 有提供每月免費執行一百萬次的授權，對我們每天一次的公車通知來說綽綽有餘了（我們應該不會搭這麼多趟吧…？）&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>使用 Powershell &#43; 工作排程器 &#43; Line Notify 來定時提醒公車到站時間</title>
      <link>https://igouist.github.io/post/2022/09/bus-reminder-1-powershell-and-windows-task-scheduler/</link>
      <pubDate>Sat, 03 Sep 2022 14:40:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2022/09/bus-reminder-1-powershell-and-windows-task-scheduler/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/BLYVPi7.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;事情發生在一個風和日麗的平凡下午：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我：（把手上的事情弄到一個段落再下班吧）&lt;br/&gt;
～～十分鐘過後～～&lt;br/&gt;
我：差不多可以走了，看一下公車還有多久&lt;br/&gt;
公車：（一分鐘前離站）&lt;br/&gt;
我：(ﾟдﾟ)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這時候才明白愛恨情仇，最傷最痛是後悔。如果我早知道公車快到站了，也許我就不會錯過。&lt;/p&gt;
&lt;p&gt;抱著這股傷痛，決定乾脆寫個小腳本，每天下班提醒我一下，避免重蹈覆轍。&lt;/p&gt;
&lt;p&gt;綜上所述！目標是：&lt;strong&gt;每天下班前十分鐘，告訴我下一班到達的公車時間&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此至少能夠拆分成三個階段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每天下班前十分鐘（定時執行）&lt;/li&gt;
&lt;li&gt;告訴我（通知功能）&lt;/li&gt;
&lt;li&gt;下一班到達的公車時間（查詢資訊）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那麼，我們開始吧！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞抓蟲：Azure Functions ServiceBus Trigger 執行過久時會重複觸發 Functions</title>
      <link>https://igouist.github.io/post/2022/08/azure-function-servicebus-trigger-max-auto-renew-duration/</link>
      <pubDate>Sat, 27 Aug 2022 10:09:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2022/08/azure-function-servicebus-trigger-max-auto-renew-duration/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/00WQGqR.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;tldr&#34;&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;當發現&lt;strong&gt;需要執行很久的 ServiceBus Trigger Function 有重複執行的情況&lt;/strong&gt;出現時，可以嘗試到&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/azure-functions/functions-bindings-service-bus?tabs=in-process%2Cextensionv5%2Cextensionv3&amp;amp;pivots=programming-language-csharp#hostjson-settings&#34;&gt;官方的 Host.json 設定指引&lt;/a&gt;，按照 SDK 版本找到對應的「&lt;strong&gt;訊息鎖定最大持續時間&lt;/strong&gt;」設定，例如 maxAutoLockRenewalDuration（延伸模組 5.x+）或 maxAutoRenewDuration（Functions 2.x），並加入專案的 Host.json&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因為 ServiceBus 在傳遞訊息之後，如果超過一段時間（MaxAutoRenewDuration）內沒有得到回應，就會解除信件的鎖並嘗試重新傳遞&lt;/strong&gt;，這時候如果原先的 Function 仍在執行，就會一前一後重複執行 Function 並發生許多光怪陸離的事，例如寫入兩筆資訊、重複複製資料之類的。&lt;/p&gt;
&lt;p&gt;建議如果調整了有 ServiceBus Trigger Function 的 Azure Functions Timeout 設定時，或是發現某支 ServiceBus Trigger 的 Functions 執行時間過長，就要一併注意 MaxAutoRenewDuration 的設定，避免重複執行的情況出現。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>DevToys —— 開發人員的瑞士刀工具箱</title>
      <link>https://igouist.github.io/post/2022/08/devtoys/</link>
      <pubDate>Sat, 20 Aug 2022 08:00:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2022/08/devtoys/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/veler/DevToys/raw/main/assets/logo/300x300.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;嗨各位朋朋，又双叒叕到了「同事推薦的好用工具」時間！&lt;/p&gt;
&lt;p&gt;今天要介紹的是 &lt;a href=&#34;https://devtoys.app/&#34;&gt;Devtoys&lt;/a&gt;：這是一套包含了許多貼心小工具的工具箱，例如 UUID 產生器、Base64 編碼解碼、JSON Format 都可以在這邊找到，省下 Google 這些小工具的時間。&lt;/p&gt;
&lt;p&gt;進入&lt;a href=&#34;https://devtoys.app/&#34;&gt;官網&lt;/a&gt;或 &lt;a href=&#34;https://www.microsoft.com/store/apps/9pgcv4v3bk4w&#34;&gt;Store&lt;/a&gt; 下載之後，點開就能在畫面上看到一整堆小工具：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/C0fUpI2.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;左邊的工具列也有工具分類和搜尋可以使用，具體有哪些工具這邊就不再贅述。可以到 &lt;a href=&#34;https://github.com/veler/DevToys&#34;&gt;Github&lt;/a&gt; 上看一下工具列表，或是就直接下載下來看看更清楚：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/6TdYfDu.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用 Azure Service Bus 來建立簡單的訊息佇列（Message Queue）吧</title>
      <link>https://igouist.github.io/post/2022/08/azure-service-bus/</link>
      <pubDate>Sat, 13 Aug 2022 16:50:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2022/08/azure-service-bus/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/5Vube9E.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;在工作上遇到在兩個 Azure 工具間建立訊息佇列（Message Queue）的需求，因此接觸到了 Azure Service Bus（中文：服務匯流排 &lt;del&gt;燴牛排？&lt;/del&gt;），在前輩的協助下建立了一組簡單的 Demo，這就來筆記一下。&lt;/p&gt;
&lt;h2 id=&#34;什麼是訊息佇列message-queue-mq&#34;&gt;什麼是訊息佇列（Message Queue, MQ）&lt;/h2&gt;
&lt;p&gt;首先讓我們簡單認識一下訊息佇列。假設我們有生產者和消費者兩個服務，其中&lt;strong&gt;生產者負責產生資料，而消費者負責消費這些資料&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/mg4lXJk.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;各位也可以這樣理解：生產者就像是壽司師傅，他會不斷的捏壽司出來；而這時候來了一位大胃王顧客，他就是消費者，會不斷地把壽司吃掉&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Sk16WdC.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;大概對這兩個角色有點認識就行了。那麼，假設我們有兩組 API 服務：其中一個是負責寫入 Log 的服務，而另一個是產品服務。&lt;/p&gt;
&lt;p&gt;產品服務會將 Log 內容丟給 Log 服務去紀錄 Log，這時候產生了這些日誌資料的產品服務就是生產者，而消費這些日誌資料去寫 Log 的服務就是消費者。&lt;/p&gt;
&lt;p&gt;也就是：&lt;strong&gt;&lt;code&gt;產品服務（生產者） —— 資料 —&amp;gt; Log 服務（消費者）&lt;/code&gt;&lt;/strong&gt; 這樣的狀況。&lt;/p&gt;
&lt;p&gt;然而像這樣&lt;strong&gt;直接相依的兩個服務，可能就會遇到一些問題：像是消費者突然掛掉，導致生產者也跟著掛掉；又或是消費者的變動和擴展會連帶影響到生產者必須跟著變動等等。&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Snispate —— 方便的截圖小幫手，放下剪取工具和小畫家吧</title>
      <link>https://igouist.github.io/post/2022/08/snispate/</link>
      <pubDate>Sun, 07 Aug 2022 11:44:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2022/08/snispate/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/w0SORqB.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;嗨各位朋朋，又到了「同事推薦的好用工具」時間！&lt;/p&gt;
&lt;p&gt;今天要推薦的是 &lt;a href=&#34;https://apps.microsoft.com/store/detail/snipaste/9P1WXPKB68KX?hl=zh-tw&amp;amp;gl=TW&#34;&gt;Snipaste&lt;/a&gt; 這套香香的截圖工具。&lt;/p&gt;
&lt;p&gt;在遠古時代的時候，我寫部落格或是測ＡＰＩ要貼圖附結果時，都是使用 Windows 內建的剪取工具（&lt;code&gt;Shift + Win + S&lt;/code&gt;）來螢幕截圖，之後貼到小畫家上再進行標記（例如畫底線、紅色框框等等）&lt;/p&gt;
&lt;p&gt;但有了 Snispate，這個動作就可以一氣呵成！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用 Wox &amp; Everything 在 Windows 上得到良好的搜尋體驗</title>
      <link>https://igouist.github.io/post/2022/06/wox-and-everything/</link>
      <pubDate>Sat, 18 Jun 2022 20:11:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2022/06/wox-and-everything/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Qw6TXg6.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;介紹一下同事推薦的 Windows 好用工具：方便的快速啟動工具 Wox 以及能快速搜尋檔案的 Everything。&lt;/p&gt;
&lt;p&gt;如果你曾經有看著檔案總管轉圈圈、等到火都上來了的經驗；或是懶得伸伸手用滑鼠點資料夾，那也許你能試試 Wox + Everything 的組合來稍稍拯救你的心理健康。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C#: 使用 AngleSharp 爬蟲工具來抓取網頁內容吧</title>
      <link>https://igouist.github.io/post/2022/06/angle-sharp/</link>
      <pubDate>Sun, 05 Jun 2022 00:21:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2022/06/angle-sharp/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/DHoF8Yw.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;前一次用到 AngleSharp 已經是去年抓網路小說的時候，想不到最近又用上了，乾脆就來筆記一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://anglesharp.github.io/&#34;&gt;AngleSharp&lt;/a&gt; 是一款簡單方便的 C# 爬蟲套件&lt;/strong&gt;，撈網頁時支援 &lt;a href=&#34;https://developer.mozilla.org/zh-TW/docs/Web/API/Document/querySelector&#34;&gt;QuerySelector&lt;/a&gt; 的語法來篩選網頁元素，並且撈回來的資料集合也都能用 Linq 操作，讓我們能對爬取的網頁內容快速進行篩選和處理，只需要短短的語法就可以開心抓想要的內容。&lt;/p&gt;
&lt;p&gt;說到要示範爬蟲，果然還是要用爬蟲界默認的經典範例 &lt;a href=&#34;https://www.ptt.cc/bbs/Beauty/index.html&#34;&gt;PTT 表特版&lt;/a&gt; 來操作（？），接著就讓我們來寫一個簡單的腳本來抓取文章吧！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>艾爾登法環　白金！</title>
      <link>https://igouist.github.io/post/2022/06/elder-ring-clear/</link>
      <pubDate>Fri, 03 Jun 2022 23:25:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2022/06/elder-ring-clear/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/wzQeHHu.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;這是一篇遲來的白金炫耀廢文。&lt;/p&gt;
&lt;p&gt;這次的成就對蒐集東西的要求比較少，沒有像黑魂一樣需要在同個場景來回打怪刷道具。通常只需要經歷幾個主要的劇情，然後到各地探險、打倒一些Ｂｏｓｓ，白金獎盃就幾乎到手了。&lt;/p&gt;
&lt;p&gt;對我這種一半時間都在到處逛街、動不動迷路然後就被王打死的人來說，實在是福音。畢竟我真的很討厭重複打同隻怪刷東西，去年的黑魂也卡在刷誓約物品很久很久。讚美法環，法環拯救了我的靈魂。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞新訓記 (7): 使用 Fluent Validation 來驗證參數吧</title>
      <link>https://igouist.github.io/post/2022/03/newbie-7-fluent-validation/</link>
      <pubDate>Sun, 13 Mar 2022 20:03:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2022/03/newbie-7-fluent-validation/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/p6aSDH9.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;這是俺整理公司新訓內容的第七篇文章，目標是紀錄 Fluent Validation 這個好用套件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FluentValidation 可以幫我們將 Api 傳入的參數的檢查用更口語、更乾淨的方式去處理&lt;/strong&gt;，除了可以將檢查邏輯拆分成單獨的 Validator 類別，更提供了許多內建的檢查規則和自訂的彈性，相當方便。&lt;/p&gt;
&lt;p&gt;並且因為將參數的檢查邏輯整理出去，就可以和 Controller 本身的工作做簡單的拆分，達到關注點分離的目標。&lt;/p&gt;
&lt;p&gt;現在就讓我們來認識一下這個好用工具吧！首先要從很久很久以前開始說起…&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;西元前的某一天，憂心的皇帝在朝堂內繞著柱子走，突然大臣奪門而入。&lt;/p&gt;
&lt;p&gt;大臣：「陛下！敵軍已經攻到國境內啦！」&lt;/p&gt;
&lt;p&gt;皇帝大驚：『邊境的那些檢查站和關口難道都陷落了嗎？不可能！』&lt;/p&gt;
&lt;p&gt;大臣：「陛下，有內奸和敵國勾結，檢查站完全沒檢查！髒資料已經闖進來了！」&lt;/p&gt;
&lt;p&gt;皇帝喊了一聲：『怎麼可能！讓朕看看！』就打開 Controller 和前一個版本的 Git Log，這一看差點就昏了過去。&lt;/p&gt;
&lt;p&gt;原來 Controller 的舊程式碼就已經很亂了，檢查參數的條件 if/else 和其他呼叫的方法、組裝資料都雜在一起。結果這次專案改動時，某一行就被內奸改壞了，關鍵的參數竟然沒檢查到！&lt;/p&gt;
&lt;p&gt;『可，可惡！來人啊，把工程師推出午門斬首！』&lt;/p&gt;
&lt;p&gt;「皇上！他已經離職啦！」&lt;/p&gt;
&lt;p&gt;皇帝跌坐在地，懊悔地說：『如果當初有好好把檢查參數跟實際組資料的部份都拆開的話，也許就不會這樣了…』&lt;/p&gt;
&lt;p&gt;「是啊，如果我們有用 Fluent Validation…！」&lt;/p&gt;
&lt;h2 id=&#34;專案現況&#34;&gt;專案現況&lt;/h2&gt;
&lt;p&gt;大臣提到的 &lt;a href=&#34;https://fluentvalidation.net/&#34;&gt;FluentValidation&lt;/a&gt; 是一套能幫我們把傳入參數的分離出去、用更口語化的方式去撰寫的工具。&lt;/p&gt;
&lt;p&gt;……如果當時他們有使用 Fluent Validation 來把驗證的邏輯和規則跟原本很亂的 Controller 切分的話，說不定就能及時發現問題吧，大概。&lt;/p&gt;
&lt;p&gt;為了不要步上他們的後塵，就讓我們直接回到本系列的卡牌管理 API 服務來加上這個好用工具吧！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Omni —— 實用的 Chrome 分頁書籤搜尋欄</title>
      <link>https://igouist.github.io/post/2022/03/omni/</link>
      <pubDate>Sun, 13 Mar 2022 20:00:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2022/03/omni/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/D29Htug.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://chrome.google.com/webstore/detail/omni-bookmark-history-tab/mapjgeachilmcbbokkgcbgpbakaaeehi&#34;&gt;Omni&lt;/a&gt; 是一款 Chrome 的擴充功能。它能夠讓你用快捷鍵叫出搜尋框，並直接&lt;strong&gt;搜尋當前開啟的分頁、書籤、歷史紀錄&lt;/strong&gt;等等。&lt;/p&gt;
&lt;p&gt;這個工具適合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;習慣分頁開很多的人，尤其是像我這種能分頁分組摺疊之後就開更多&lt;/li&gt;
&lt;li&gt;懶得用滑鼠去找分頁、也懶得 Ctrl Tab 逐個分頁切換的人&lt;/li&gt;
&lt;li&gt;書籤存了一大堆但每次都忘記放在哪裡，最後還是重新搜尋一次的人&lt;/li&gt;
&lt;li&gt;想在瀏覽器有方便的搜尋框（就像 Mac 的 Alfred 或 Windows 的 Powertoy 那樣）&lt;/li&gt;
&lt;li&gt;即使只有三個分頁，還是要在朋友面前打字裝潮的人&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>AutoMapper 使用 ConvertUsing 自定義類型轉換，將包含串列成員的物件映射為一組串列</title>
      <link>https://igouist.github.io/post/2021/12/automapper-convert-using/</link>
      <pubDate>Sun, 05 Dec 2021 11:20:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2021/12/automapper-convert-using/</guid>
      <description>&lt;p&gt;從朋友那兒聽到了用 &lt;a href=&#34;https://igouist.github.io/post/2020/07/automapper&#34;&gt;AutoMapper&lt;/a&gt; 把串列成員物件攤平成一組串列的問題，發現了 &lt;strong&gt;ConvertUsing&lt;/strong&gt; 的好用，這邊就紀錄一下。&lt;/p&gt;
&lt;p&gt;事情是這樣的，首先有一個 &lt;code&gt;Parent&lt;/code&gt; 類別，其中包含著兩個成員：&lt;code&gt;Id&lt;/code&gt; 和串列的 &lt;code&gt;Child&lt;/code&gt; 類別，而 &lt;code&gt;Child&lt;/code&gt; 類別則只有一個成員 &lt;code&gt;Val&lt;/code&gt;，如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Parent&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Id { &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; IEnumerable&amp;lt;Child&amp;gt; Children { &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Child&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; Val { &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外還有一個 &lt;code&gt;Target&lt;/code&gt; 類別，包含 &lt;code&gt;Id&lt;/code&gt; 和 &lt;code&gt;Val&lt;/code&gt; 兩個成員：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Target&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Id { &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; Val { &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;現在的目標是：&lt;strong&gt;將一個有著 Child 串列的 Parent 映射成 Target 串列&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;也就是說，假設我們的來源是這樣子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; boo = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Parent
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Id = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Children = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; List&amp;lt;Child&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Child { Val = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Child { Val = &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;希望可以變成這樣子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; expect = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; List&amp;lt;Target&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Target { Id = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, Val = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Target { Id = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, Val = &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我之前遇到的時候，會直覺地將 Child 直接 Map 到 Target，再對 Target 做個 Foreach 來補上 Parent 的 Id。&lt;/p&gt;
&lt;p&gt;這次和朋友討論時，提到了另一個角度：雖然這樣的做法相當直覺快速，但其實並不能保證後續維護的人使用這組 Mappings 時，都知道這裡要補資料；況且此處的對應關係的確是 &lt;code&gt;Parent&lt;/code&gt; 到 &lt;code&gt;List&amp;lt;Target&amp;gt;&lt;/code&gt;，並非 &lt;code&gt;Child&lt;/code&gt; 到 &lt;code&gt;Target&lt;/code&gt; 而已，直覺上就怪怪的。若要解決這個問題，可能就要再包裝一層，把 Mapper 隔離出去做個轉換器之類的。&lt;/p&gt;
&lt;p&gt;但想想又覺得 AutoMapper 不可能沒提供這個場景能使用的方法才對，最後餵狗發現 &lt;strong&gt;AutoMapper 確實有提供 &lt;code&gt;ConvertUsing&lt;/code&gt; 來讓我們客製化轉換過程&lt;/strong&gt;，這邊就紀錄一下。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞新訓記 (6): 使用 依賴注入 (Dependency Injection) 來解除強耦合吧</title>
      <link>https://igouist.github.io/post/2021/11/newbie-6-dependency-injection/</link>
      <pubDate>Sun, 28 Nov 2021 20:13:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2021/11/newbie-6-dependency-injection/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/2XYv7X2.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;這是俺整理公司新訓內容的第六篇文章，目標是&lt;strong&gt;紀錄什麼是依賴注入（Dependency Injection）&lt;/strong&gt;。包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/11/newbie-6-dependency-injection#%E7%82%BA%E4%BB%80%E9%BA%BC%E9%9C%80%E8%A6%81%E4%BE%9D%E8%B3%B4%E6%B3%A8%E5%85%A5&#34;&gt;為什麼要依賴注入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/11/newbie-6-dependency-injection#%E4%BE%9D%E8%B3%B4%E6%B3%A8%E5%85%A5%E7%9A%84%E7%A8%AE%E9%A1%9E&#34;&gt;依賴注入的種類（建構式注入、屬性注入、方法注入）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/11/newbie-6-dependency-injection#%E4%BE%9D%E8%B3%B4%E6%B3%A8%E5%85%A5%E7%9A%84%E4%B8%89%E7%A8%AE%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F-transientscopedsingleton&#34;&gt;.net Core 中依賴注入的生命週期&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;並用 &lt;a href=&#34;https://igouist.github.io/post/2021/11/newbie-6-dependency-injection#%E5%AF%A6%E4%BD%9C&#34;&gt;.net Core 實際跑一次依賴注入&lt;/a&gt;，&lt;strong&gt;藉由將控制權轉移給注入容器，解除分層與分層間、類別與類別間的依賴和耦合關係，達到以介面分離實作的目標&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;西元前的某一天，憂心的皇帝在朝堂內繞著柱子走，正巧被路過的廷尉看見。&lt;/p&gt;
&lt;p&gt;廷尉：「敢問陛下在煩惱什麼呢？」&lt;/p&gt;
&lt;p&gt;皇帝：『朕這是在想封賞的事兒哪。前朝之所以覆滅，根本的原因就在於大肆封賞臣下，四處分封土地給他們做諸侯。&lt;/p&gt;
&lt;p&gt;這些諸侯呢，肆意起用自己喜歡的人擔任要職、結黨營私，心情好就 &lt;code&gt;new 將軍(&amp;quot;我ㄉ朋友&amp;quot;);&lt;/code&gt;，&lt;br/&gt;十天就封了十個將軍。這些人若犯了錯，要處理他們還得看諸侯面子；而諸侯一聲令下，這些人便群起造反。&lt;/p&gt;
&lt;p&gt;並且，這些諸侯之間彼此喜歡直接往來，動不動就在自家裡下命令給 &lt;code&gt;隔壁諸侯.借糧草(100)&lt;/code&gt;，哪天就變成 &lt;code&gt;隔壁諸侯.揪團造反()&lt;/code&gt;。彼此之間偷來暗去，實在難以掌握。&lt;/p&gt;
&lt;p&gt;最後呢，一個逆賊起來造反，若要將他給辦了，附近諸侯就一起響應，每個都一齊報錯，Exception 成千上百，國家也就這樣滅了，想到這朕就頭痛得很，不知愛卿可有法子？』&lt;/p&gt;
&lt;p&gt;廷尉想了一想，便說：「陛下，此事要點還是在於諸侯之間&lt;strong&gt;相互依賴、彼此耦合&lt;/strong&gt;，致生禍端。&lt;/p&gt;
&lt;p&gt;臣有一計，先收回諸侯的人事任命權，使其不可私自 &lt;code&gt;new&lt;/code&gt; 自己人，所有人事異動，須&lt;strong&gt;由中央進行管理與派遣&lt;/strong&gt;。這樣即使諸侯要造反，也不知道下面這群打工仔是不是自己人。大家各司其職，諸侯做好自己的行政作業，打工仔派到崗位就做好自己的工作，彼此不直接依賴，這樣出事的機率就少了。&lt;/p&gt;
&lt;p&gt;其次，明令禁止諸侯私自往來，對諸侯們進行隔離，若是有公務上的需要，&lt;strong&gt;一律藉由中央提供的接口來溝通&lt;/strong&gt;，彼此之間明訂契約，由中央進行隔離與調派，諸侯間就只需要按照協議好的合約下去合作，這樣勾結的機會也就少了，耦合也就降低了。陛下覺得如何？」&lt;/p&gt;
&lt;p&gt;皇帝大喜：『如此甚好！治眾如治寡，在於分而治之。此計可有名字？』&lt;/p&gt;
&lt;p&gt;「此乃－－依賴注入之計！」&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在 Swagger UI 加上驗證按鈕，讓 Request Header 傳遞 Authorize Token</title>
      <link>https://igouist.github.io/post/2021/10/swagger-enable-authorize/</link>
      <pubDate>Sat, 16 Oct 2021 23:50:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2021/10/swagger-enable-authorize/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/XjZLvSZ.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;在先前的 &lt;a href=&#34;https://igouist.github.io/post/2021/05/newbie-4-swagger&#34;&gt;菜雞新訓記 (4): 使用 Swagger 來自動產生簡單好看可測試的 API 文件吧&lt;/a&gt; 中，我們介紹了在 .net Core 環境使用 &lt;strong&gt;Swashbuckle&lt;/strong&gt; 套件來產生 Swagger 文檔，並且直接在 Swagger UI 中呼叫 API 來進行測試。&lt;/p&gt;
&lt;p&gt;但很多時候，我們的 API 會需要先驗證才能使用，例如&lt;strong&gt;在 Header 傳遞 Token 來驗證身分&lt;/strong&gt;等等。這時候 Swagger UI 就會整個廢掉，打了都會出錯，很不方便。&lt;/p&gt;
&lt;p&gt;因此這篇文章就紀錄一下如何在 Swagger UI 上加入 Authorize Token 的傳遞，讓 Swagger UI 在需要身分驗證的環境也能直接呼叫使用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞抓蟲: DateTime.ToString() 之我們不一樣 &amp; CultureInfo 文化特性小筆記</title>
      <link>https://igouist.github.io/post/2021/10/csharp-datatime-tostring-cultureinfo/</link>
      <pubDate>Mon, 04 Oct 2021 22:00:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2021/10/csharp-datatime-tostring-cultureinfo/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/EMdGkwr.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;事發緣由&#34;&gt;事發緣由&lt;/h2&gt;
&lt;p&gt;咱們內部套件中有個方法，會將各個參數組合為 QueryString 去打指定的 Api。就是這麼稀鬆平常的場景，神奇的事情就發生了。&lt;/p&gt;
&lt;p&gt;同樣的套件、同樣的語法，在團隊中兩個人的電腦上安裝執行，卻是一個成功一個失敗。&lt;/p&gt;
&lt;p&gt;原來該方法的參數中，包含一欄型別為 DateTime 的資料，並且會把該欄位的值拿來 ToString() 再做為參數傳遞給目標 Api。&lt;/p&gt;
&lt;p&gt;而呼叫失敗的人就是在這個 &lt;code&gt;DateTime.ToString()&lt;/code&gt; 的過程中&lt;strong&gt;產生了中文字&lt;/strong&gt;，使得目標 Api 接到參數後，無法將中文字轉換回 DateTime 而發生了錯誤。&lt;/p&gt;
&lt;p&gt;問題就浮現了：&lt;strong&gt;同一行 DateTime.ToString() 在不同電腦執行的結果竟然不一樣？！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;為了讓我們更快了解狀況，現在就簡單地使用 Linqpad 進行測試：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    DateTime.Now.ToString().Dump();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;首先，在我的 Windows 時間設定中，完整時間的格式為 &lt;code&gt;09:40:07&lt;/code&gt; ，也就是 24 小時制。&lt;/p&gt;
&lt;p&gt;現在讓我們先執行上面這段語法看看：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 2021/10/04 21:00:00
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接著讓我們變更時間格式看看。&lt;/p&gt;
&lt;p&gt;以我的 Win10 為例，在 Windows 工具列，也就是畫面的右下角右鍵，選擇 &lt;code&gt;調整日期時間 → 日期時間格式設定 → 變更資料格式&lt;/code&gt;，將時間格式變更為 &lt;code&gt;上午 09:40:07&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;重新啟動 Linqpad 再執行如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 2021/10/04 下午 09:00:00
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到 &lt;code&gt;下午&lt;/code&gt; 兩個字就蹦出來了！&lt;/p&gt;
&lt;p&gt;之所以會有這樣的差異，是因為 &lt;code&gt;DateTime.ToString()&lt;/code&gt; 預設轉換的目標格式會是抓取目前執行緒的&lt;strong&gt;文化特性&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞新訓記 (5): 使用 三層式架構 來切分服務的關注點和職責吧</title>
      <link>https://igouist.github.io/post/2021/10/newbie-5-3-layer-architecture/</link>
      <pubDate>Sun, 03 Oct 2021 14:00:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2021/10/newbie-5-3-layer-architecture/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/S72H7sA.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;這是俺整理公司新訓內容的第五篇文章，目標是&lt;strong&gt;使用三層式架構 (3-Layer Architecture) 來切分服務的關注點和職責&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;什麼是分層分層可以吃嗎&#34;&gt;什麼是分層？分層可以吃嗎？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;天地混沌如雞子，商業邏輯生其中。&lt;/p&gt;
&lt;p&gt;萬八千歲，天地開闢。表現層為天。資料層為地。商業邏輯層在其中……&lt;/p&gt;
&lt;p&gt;　　　　－－民明書坊《盤古與他的CRUD之旅》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根據民明書坊的文獻記載，我們常聽到的「天地玄黃，宇宙洪荒」云云，其實指的就是上古時期的開發狀況。當時世界還是一片混沌，所有的程式碼都混雜成一坨，不是所有東西寫在一起你儂我儂，一言不合就三千行；就是依賴關係交錯複雜，改了北極壞南極。&lt;/p&gt;
&lt;p&gt;要說有多亂呢，大概就算前人嘗試引入了 MVC，也只是改成把所有程式都塞在 Controller 而已，其絕望程度可見一斑。&lt;/p&gt;
&lt;p&gt;這時候隔壁課的老盤調過來接刀，一看不得了，便決定先對這屎山整頓一番。他大喝一聲，那些靠近使用者的便上浮起來化作了天，親近資料庫的便沉澱下去變成了地，而所有的商業邏輯就連接著兩者，支撐起了整個專案。這也就是分層架構的由來。&lt;/p&gt;
&lt;h3 id=&#34;三層式架構&#34;&gt;三層式架構&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;分層架構是運用最為廣泛的架構模式，幾乎每個軟體系統都需要通過層（Layer）來隔離不同的關注點（Concern Point），以此應對不同需求的變化，使得這種變化可以獨立進行；此外，分層架構模式還是隔離業務複雜度與技術複雜度的利器。 －－ &lt;a href=&#34;https://raychiutw.github.io/2019/%E9%9A%A8%E6%89%8B-Design-Pattern-2-%E8%BB%9F%E9%AB%94%E5%88%86%E5%B1%A4%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F-Software-Layered-Architecture-Pattern/&#34;&gt;Ray&amp;rsquo;s Notes&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般來說，最常見的分層架構就是&lt;strong&gt;三層式架構&lt;/strong&gt;了。&lt;/p&gt;
&lt;p&gt;三層式架構顧名思義就是把應用程式分成三層，通常會分成「&lt;strong&gt;展示層、商業邏輯層、資料存取層&lt;/strong&gt;」。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/RxSrWJm.jpg&#34; alt=&#34;分層架構01&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞抓蟲: 使用 FromUri 的複雜型別在有傳遞 QueryString 的情況下會先建立再賦值</title>
      <link>https://igouist.github.io/post/2021/08/set-default-value-with-model-when-fromuri/</link>
      <pubDate>Thu, 19 Aug 2021 22:20:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2021/08/set-default-value-with-model-when-fromuri/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/TuGp6Lk.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;事發緣由&#34;&gt;事發緣由&lt;/h2&gt;
&lt;p&gt;在 .net Framework 4.6.2 MVC 的 ApiController 中，某個查詢資料列表的方法除了提供查詢條件的參數以外，還有提供選擇性的分頁參數。也就是像這樣子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-CSharp&#34; data-lang=&#34;CSharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[HttpGet]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; IEnumerable&amp;lt;Boo&amp;gt; GetBoos(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;    [FromUri]&lt;/span&gt; SearchBooParameter parameter,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;    [FromUri]&lt;/span&gt; PagingParameter paging = &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 呼叫 Service 查資料...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由於需要調整該功能的預設排序，改為由大到小，又不想背負更改大量共用的 &lt;code&gt;PagingParameter&lt;/code&gt; 去影響到其他使用到的地方，決定在 Controller 這裡簡單用預測值加上判斷處理一下就好&lt;/p&gt;
&lt;p&gt;相信著「若使用者沒有傳遞 paging 相關的參數，應該就會是給定的預設值 &lt;code&gt;null&lt;/code&gt; 吧！」的我，用了 &lt;code&gt;if (paging is null)&lt;/code&gt; 進行判斷：若是 &lt;code&gt;null&lt;/code&gt; 的情況就將其中用來標示排序方向的成員 &lt;code&gt;isDesc&lt;/code&gt; 設定為 true，開開心心交差。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-CSharp&#34; data-lang=&#34;CSharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[HttpGet]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; IEnumerable&amp;lt;Boo&amp;gt; GetBoos(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;    [FromUri]&lt;/span&gt; SearchBooParameter parameter,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;    [FromUri]&lt;/span&gt; PagingParameter paging = &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (paging &lt;span style=&#34;color:#66d9ef&#34;&gt;is&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        paging = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; PagingParameter();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        paging.isDesc = &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 預設由大到小&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 呼叫 Service 查資料...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但實際使用之後發現：即使只有傳入查詢條件參數、未傳遞 paging 時，資料仍然由小到大顯示，且 &lt;code&gt;paging.isDesc&lt;/code&gt; 竟然是 false，並未被更改到。也就是說，即使未傳遞 paging，它也並不是 null！&lt;/p&gt;
&lt;p&gt;實測之後發現：若在呼叫該 API 的時候，給定一個完全無關的參數，例如 &lt;code&gt;?a=1&lt;/code&gt;，則 paging 還是會被建立一個實體出來，並無視 &lt;code&gt;= null&lt;/code&gt; 這個預設值。因此就導致了非預期（＝跟我想的不一樣啊！）的行為。&lt;/p&gt;
&lt;p&gt;這邊直接先講結論：&lt;strong&gt;如果有傳遞 QueryString 的任何參數時，不管這些參數跟指定的類別有沒有關係，放在 &lt;code&gt;[FromUri]&lt;/code&gt; 的複雜型別都會先建立出實體，再嘗試和 QueryString 的內容進行比對與設值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;設定在 &lt;code&gt;[FromUri]&lt;/code&gt; 的複雜型別身上的預設值，像是 &lt;code&gt;[FromUri] PagingParameter paging = null&lt;/code&gt; 只有完全沒給任何 QueryString 的時候才會吃到。（不過因為預設值只能是常數的關係，基本上就是指 defualt 的 null）&lt;/p&gt;
&lt;p&gt;因此如果遇到要給定預設值的場合，還是得乖乖地針對型別中的成員做設定比較保險，例如 &lt;code&gt;bool isDesc { get; set; } = true&lt;/code&gt;。另外，因為完全沒給 QueryString 的時候還是會是 null，故該有的參數檢查仍然不能漏了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞抓蟲: Url 變得怪怪的？你可能是零寬空格（ZWSP）的受害者！</title>
      <link>https://igouist.github.io/post/2021/06/zero-width-space/</link>
      <pubDate>Sat, 26 Jun 2021 21:53:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2021/06/zero-width-space/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/bS6EGIL.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;這週遇到個想不到的坑，特別來記錄一下。故事是這樣的－－&lt;/p&gt;
&lt;p&gt;在需要呼叫其他 API 服務時，發生了以下怪事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打某支查詢 API，突然查不到任何東西，或是跳出參數錯誤&lt;/li&gt;
&lt;li&gt;有些&lt;strong&gt;需要用參數組成 URL 的 API 跑出 Not Found&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;第一組資料呼叫成功，第二組突然路徑錯誤&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;寫入的時候，&lt;strong&gt;資料莫名其妙多了個 &lt;code&gt;?&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;例如原先的資料是 &lt;code&gt;ABC&lt;/code&gt;，不知怎地變成了 &lt;code&gt;ABC?&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由於這些操作都涉及到同一個參數，直覺上就是我們這邊給的參數出了點問題，馬上進入找犯人的環節。直接中斷點標記下去，反覆觀察該字串，但它就是一個普通的字串 &lt;code&gt;&amp;quot;ABC&amp;quot;&lt;/code&gt;，完全看不出什麼端倪。&lt;/p&gt;
&lt;p&gt;正要覺得參數沒有問題的時候，赫然發現組出來的 Url 相當不對勁：在該參數的後方，多出了 &lt;strong&gt;&lt;code&gt;%E2%80%8B&lt;/code&gt;&lt;/strong&gt; 這串神秘東西！&lt;/p&gt;
&lt;p&gt;當下我驚呆了，我們傳出去的 Url 裡，並不是預想的 &lt;code&gt;/api/product/ABC&lt;/code&gt;，而是 &lt;code&gt;/api/product/ABC%e2%80%8b&lt;/code&gt;！真是赤裸裸的背叛！這串鬼東西到底是什麼來頭？！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C#: BenchmarkDotnet —— 效能測試好簡單</title>
      <link>https://igouist.github.io/post/2021/06/benchmarkdotnet/</link>
      <pubDate>Sun, 13 Jun 2021 22:25:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2021/06/benchmarkdotnet/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/rhmeAUi.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;「你寫那什麼鬼東西？這個ＯＯＯ寫法比較好啦！」&lt;br/&gt;
『聽你在屁！明明是這個ＸＸＸ寫法快= =』&lt;/p&gt;
&lt;p&gt;哇喔！等等！&lt;strong&gt;想戰效能嗎&lt;/strong&gt;？那你一定需要這款 &lt;strong&gt;BenchmarkDotnet&lt;/strong&gt;！&lt;/p&gt;
&lt;h2 id=&#34;介紹與安裝&#34;&gt;介紹與安裝&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/dotnet/BenchmarkDotNet/raw/master/docs/logo/logo-wide.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我們在 Coding 的時候，或多或少都會有「不知道這兩個寫法哪個比較好？」、「聽說Ａ寫法比Ｂ寫法快，真的嗎？」這類關於效能的疑問。&lt;/p&gt;
&lt;p&gt;在遠古時期，當我們需要驗證這種想法，可能就要用記錄秒數的方式，或是搭配迴圈、然後再印在畫面上等等這類土法煉鋼的方式。&lt;/p&gt;
&lt;p&gt;然而這種單純計秒數的 Print 流測試，可能比較到了時間成本，卻忽略了吃掉的記憶體這些空間成本；又或是每次都要插一堆列印文字的語句，因為麻煩就萌生退意等等…&lt;/p&gt;
&lt;p&gt;這時候就是 BenchmarkDotnet 出場的時候啦！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BenchmarkDotnet 是一款簡單好用的效能比較工具，可以幫助我們比對多組程式碼，並告訴我們平均的執行時間、耗用的記憶體等等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只要使用 BenchmarkDotnet 這個神奇妙妙幫手，它就能幫我們搞定這些麻煩的事情，讓我們可以專注在要測試的程式碼內容囉。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞新訓記 (4): 使用 Swagger 來自動產生可互動的 API 文件吧</title>
      <link>https://igouist.github.io/post/2021/05/newbie-4-swagger/</link>
      <pubDate>Sun, 16 May 2021 22:42:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2021/05/newbie-4-swagger/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/lzjNys4.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;這是俺整理公司新訓內容的第四篇文章，目標是&lt;strong&gt;簡單地使用 Swagger 工具來自動產生可互動的 API 文件&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;api-文件與-swagger&#34;&gt;API 文件與 Swagger&lt;/h2&gt;
&lt;p&gt;在 &lt;a href=&#34;https://igouist.github.io/post/2021/05/newbie-3-dapper&#34;&gt;上一篇&lt;/a&gt; 我們建立了一個有簡單的 CRUD 的 Web API 服務，這篇我們就接續著 API 服務往下看吧！&lt;/p&gt;
&lt;p&gt;之前我們介紹 API 的時候有提過：API 是為了讓兩個服務之間可以溝通、互動所產生的接口。而所有的溝通要有效，都一定要先有共識，隨著溝通的人數越來越多，或是內容的理解要越來越細，就會用文件或契約的方式來達成共識。&lt;/p&gt;
&lt;p&gt;回到我們的 API 服務開發來說，就是你除了把服務生出來了，可以跑了以外，還有一個重要的點是：&lt;strong&gt;必須讓所有的使用者（包含幾個月後的你自己）知道怎麼使用這組 API 服務&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;也就來說，就是要寫 &lt;strong&gt;API 規格文件&lt;/strong&gt; 啦！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞新訓記 (3): 使用 Dapper 來連線到資料庫 CRUD 吧</title>
      <link>https://igouist.github.io/post/2021/05/newbie-3-dapper/</link>
      <pubDate>Sun, 09 May 2021 11:15:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2021/05/newbie-3-dapper/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/aIHQL5Z.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;這是俺整理公司新訓內容的第三篇文章，目標是&lt;strong&gt;在 .NET Core 簡單地使用 Dapper 連線到資料庫並完成 CRUD 的功能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;接續 &lt;a href=&#34;https://igouist.github.io/post/2021/05/newbie-2-webapi&#34;&gt;上一篇&lt;/a&gt; 的進度，我們接著要來連線到資料庫中完成我們的 Web Api 的 CRUD 範例。因為從新訓時期到現在工作團隊作業上主要都是使用 Dapper 來做連線資料庫的工作，這邊就直接用 Dapper 來推進吧！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dapper 有多好用呢？它輕量、它簡單、它快速&lt;/strong&gt;。總之先把大神們的介紹文直接拿來鎮樓：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.darkthread.net/blog/dapper/&#34;&gt;短小精悍的.NET ORM神器 &amp;ndash; Dapper - 黑暗執行緒&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/mrkt/2016/06/10/153606&#34;&gt;另一種資料存取對映處理方式的選擇 - Dapper - mrkt 的程式學習筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.huanlintalk.com/2014/03/a-micro-orm-dapper.html&#34;&gt;好用的微型 ORM：Dapper - Huanlin 學習筆記&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那麼按照慣例，我們先來 &lt;del&gt;吹捧今天的主角&lt;/del&gt; 說明一點簡單的前因後果吧。想直接實作的朋友，可以跳到&lt;a href=&#34;#%E6%AD%A3%E5%BC%8F%E9%96%8B%E5%B7%A5&#34;&gt;正式開工&lt;/a&gt;的小節呦。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞新訓記 (2): 認識 Api &amp; 使用 .net Core 來建立簡單的 Web Api 服務吧</title>
      <link>https://igouist.github.io/post/2021/05/newbie-2-webapi/</link>
      <pubDate>Sun, 02 May 2021 12:39:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2021/05/newbie-2-webapi/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/d2xM94x.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;這是俺整理公司新訓內容的第二篇文章，目標是&lt;strong&gt;對 Api, Restful Api, HTTP 等相關的知識點做個筆記，並用 .net Core 建立一個簡易的 Web Api 專案&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;前言基本觀念&#34;&gt;前言、基本觀念&lt;/h2&gt;
&lt;p&gt;我們在 &lt;a href=&#34;https://igouist.github.io/post/2021/04/newbie-1-hello-git&#34;&gt;上一篇&lt;/a&gt; 記錄了新訓第一天的 Git 操作筆記。接著在這篇，我們終於要進入 .net Core 啦！&lt;/p&gt;
&lt;p&gt;目前的規劃是先從建立一個可以使用的、最簡單版本的 Web Api 服務開始，再將各個工具擴增進來。所以後續的文章應該都會以這篇的簡易 API 為基底繼續延伸下去（如果順利的話啦）&lt;/p&gt;
&lt;p&gt;這篇文章的前半段會用來記錄一些&lt;strong&gt;使用或開發 API 常用到的相關知識&lt;/strong&gt;，如果對 HTTP 的部分已經有點頭緒，或是迫不及待想直接動手用 .net Core 開 Api 服務的朋友們，可以直接跳到 &lt;a href=&#34;#%E6%AD%A3%E5%BC%8F%E9%96%8B%E5%B7%A5&#34;&gt;正式開工&lt;/a&gt; 的部份。那麼，我們開始吧～&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;什麼是-api&#34;&gt;什麼是 API&lt;/h3&gt;
&lt;p&gt;我們在物件導向的 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface/&#34;&gt;介面&lt;/a&gt; 時有稍微聊過所謂介面（Interface）的概念：「在兩個系統，或是兩個分層之間要介接的時候，只需要提供我這個功能的接口／介面給對方，就能讓對方知道如何使用」&lt;/p&gt;
&lt;p&gt;API（Application Programming Interface）也是同樣的道理：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在不同的應用程式或服務（Application）之間，使用程式碼（Programming）的方式提供一組 介面（Interface），讓提供方和使用方可以藉由這組介面銜接起來。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;API 最貼切的比喻就是我們在 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;封裝篇&lt;/a&gt; 也用過的&lt;strong&gt;販賣機&lt;/strong&gt;：販賣機會提供不同飲料的按鈕，當我們選擇了其中一個按鈕按下、投了錢之後，對應的飲料就會掉下來。&lt;/p&gt;
&lt;p&gt;對應回來就是：我們到了某個服務（販賣機），去拿我們想要的資料（飲料），所以呼叫了該服務的某支 API（按鈕）並且提供了一些該 API 要求的資料（投錢），最後 API 就會把我們想要的資料交給我們（飲料）&lt;/p&gt;
&lt;p&gt;再用更實際的例子來說就像是：假設我們想要做一款可以查詢台北市的公車動態的 APP，於是我們到了提供公車動態的服務 &lt;a href=&#34;https://ptx.transportdata.tw/MOTC?t=Bus&amp;amp;v=2#!/CityBus/CityBusApi_RealTimeByFrequency&#34;&gt;MOTC Transport API v2&lt;/a&gt; 去找我們想要的 API，過程中我們可能需要告訴服務我們要查的是台北市，最後服務就會將公車動態的資料交給我們。&lt;/p&gt;
&lt;p&gt;關於 API 的部份，推薦可以先閱讀過 Huli 大大的這兩篇，將基本觀念說明的相當好懂且透徹：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@hulitw/learning-tcp-ip-http-via-sending-letter-5d3299203660&#34;&gt;從傳紙條輕鬆學習基本網路概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@hulitw/ramen-and-api-6238437dc544&#34;&gt;從拉麵店的販賣機理解什麼是 API&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，也推一下我在 CodingBar 看到的這篇 &lt;a href=&#34;https://medium.com/codingbar/api-%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E9%BA%BC-%E7%94%A8%E7%99%BD%E8%A9%B1%E6%96%87%E5%B8%B6%E4%BD%A0%E8%AA%8D%E8%AD%98-95f65a9cfc33&#34;&gt;API 到底是什麼？ 用白話文帶你認識&lt;/a&gt; 和它所引用的影片：&lt;/p&gt;
&lt;iframe src=&#34;https://www.youtube.com/embed/zvKadd9Cflc&#34; width=&#34;100%&#34; height=&#34;480&#34; frameborder=&#34;0&#34; scrolling=&#34;no&#34; allowfullscreen&gt;&lt;/iframe&gt;</description>
    </item>
    
    <item>
      <title>Visual Studio: 在同一個檔案分割視窗</title>
      <link>https://igouist.github.io/post/2021/05/visual-studio-split-window-in-one-file/</link>
      <pubDate>Sun, 02 May 2021 10:00:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2021/05/visual-studio-split-window-in-one-file/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/LEB9mUy.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;當我們遇到比阿嬤的裹腳布還臭還長的類別時，常常會發生「需要一邊確認 Public 的 Function，但它用到的 Private Function 卻遠在天邊」，或是「SQL 字串／字串常數等等另外宣告在檔案最上端，導致瀏覽邏輯到一半的時候還要來回跳」的狀況。&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&#34;https://igouist.github.io/post/2021/03/visual-studio-bookmark&#34;&gt;上一篇&lt;/a&gt; 我們分享過用書籤的方式來記錄兩個地方來回飛躍，但如果是要互相比對或理解流程等等時候，就比不上分割視窗來的方便。&lt;/p&gt;
&lt;p&gt;在 Visual Studio 用分割視窗的方式開啟不同的檔案，相信大家都已經駕輕就熟，尤其用過 Visual Studio 來進行 Merge 的朋友一定對這樣的排版不陌生。但是你知道就算&lt;strong&gt;對同一個檔案，也可以使用分割視窗來同時編輯兩個地方嗎&lt;/strong&gt;？只需要動動滑鼠就可以囉！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞新訓記 (1): 使用 Git 來進行版本控制吧</title>
      <link>https://igouist.github.io/post/2021/04/newbie-1-hello-git/</link>
      <pubDate>Mon, 05 Apr 2021 22:39:01 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2021/04/newbie-1-hello-git/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ojI91y9.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;這是俺整理公司新訓內容的第一篇文章，目標是&lt;strong&gt;整理 Git 相關的筆記&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;前言推薦資源&#34;&gt;前言、推薦資源&lt;/h2&gt;
&lt;p&gt;說來慚愧，前陣子 PTT 和臉書社團都有討論到相關科系畢業卻不會 Git 會不會太誇張，我正是畢業之後才開始用 Git 的那類人囧，相信像我一樣的人並不少，因此這個系列就決定從「&lt;strong&gt;新訓時學到的 Git 的基本操作&lt;/strong&gt;」開始記錄。&lt;/p&gt;
&lt;p&gt;開始之前先感謝公司前輩和完善的新手教學，還有第一天就先學 Git 的優良傳統。另外，也感謝相當多優秀的 Git 學習資源，說明得也更為詳細深入，想好好了解 Git 的朋友也可以逛逛，這邊就先推薦一波：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gitbook.tw/&#34;&gt;為你自己學 Git&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;對新手非常友善。網站點進去後往下拉，可以看到大部分章節都能免費看，佛！&lt;/li&gt;
&lt;li&gt;最有價值的是裡面的各種狀況題。畢竟當你用 Git 不只需要基本操作的時候，呃，祝你好運&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://backlog.com/git-tutorial/tw/&#34;&gt;連猴子都能懂的 Git 入門指南&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;從入門到進階篇跟過一次的話，基本操作就沒有問題了&lt;/li&gt;
&lt;li&gt;圖解讓人很好理解，而且在教學的實作部分會提供儲存庫讓你下載實作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.darkthread.net/blog/category/Git&#34;&gt;黑暗執行緒的 Git 分類文章&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;同場加映：&lt;a href=&#34;https://blog.darkthread.net/blog/my-git-cheatsheet/&#34;&gt;黑暗執行緒的 Git 指令筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;黑大出品，品質保證&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://learngitbranching.js.org/?locale=zh_TW&#34;&gt;Learn Git Branching&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;用遊戲通關的方式認識 Git，對於一些分支的概念會很有幫助&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/users/20004901/ironman/525&#34;&gt;30 天精通 Git 版本控管&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://git-scm.com/book/zh-tw/v2&#34;&gt;Pro Git&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下來我們就從認識 Git 開始吧！&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;什麼是-git&#34;&gt;什麼是 Git？&lt;/h3&gt;
&lt;p&gt;你發生過以下狀況嗎？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;從沒做過版本控制，結果突然要改回前一版，不知所措&lt;/li&gt;
&lt;li&gt;使用資料夾／壓縮檔板控
&lt;ul&gt;
&lt;li&gt;20201201.rar, 20201215_v2.rar, 20201215_首頁.rar&amp;hellip;&amp;hellip;&lt;/li&gt;
&lt;li&gt;空間越吃越兇，東西越來越雜，事情越想越不對勁，但是不敢刪除&lt;/li&gt;
&lt;li&gt;其實不知道每一份實際上改了哪裡，要復原某一段的時候要找半天，不如直接重寫一段&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;團隊合作／分組報告，各自負責一個區域，結果複製來複製去組不起來，不只需要看眼科，修 BUG 還比寫的時間還多&lt;/li&gt;
&lt;li&gt;看到一段程式碼
&lt;ul&gt;
&lt;li&gt;完全不知道為什麼要這樣寫&lt;/li&gt;
&lt;li&gt;或是氣到要死，抓不到戰犯&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那麼，你很有可能需要 Git！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞新訓記 (0): 前言</title>
      <link>https://igouist.github.io/post/2021/04/newbie-0-menu/</link>
      <pubDate>Mon, 05 Apr 2021 22:39:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2021/04/newbie-0-menu/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/uobV40z.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;長夜將至，我從今開始守望。&lt;br/&gt;
　　　　　　　　　　　　　　　　　　　　　　　　　　　　——《冰與火之歌》守夜人誓詞&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;年初整理完物件導向系列後，休息（沉迷遊戲）了好一陣子，終於要繼續整理公司新訓的內容啦！&lt;/p&gt;
&lt;p&gt;因為這個系列會是公司新訓時期的筆記整理，所以會是比較簡易的實作紀錄，並不會太過深入，需要的時候會用延伸閱讀的形式補充上去。如果看文的過程中覺得有什麼能夠補充的，也歡迎告訴我呦。&lt;/p&gt;
&lt;p&gt;本系列預計會從 Git 的基本操作開始，簡單建立一個 Web Api 為主軸，逐步介紹相關的部份，例如簡單地引入套件、簡單地分層等等。基本方針就是直接抄襲 &lt;a href=&#34;https://sunnyday0932.github.io/&#34;&gt;隔壁同事的部落格&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;後續有更新的文章，就會整理到這篇目錄中。或是也可以從 &lt;a href=&#34;https://igouist.github.io/series/%E8%8F%9C%E9%9B%9E%E6%96%B0%E8%A8%93%E8%A8%98/&#34;&gt;菜雞新訓記&lt;/a&gt; 裡面做系列文的查詢。&lt;/p&gt;
&lt;p&gt;那麼，就從第一篇：&lt;a href=&#34;https://igouist.github.io/post/2021/04/newbie-1-hello-git&#34;&gt;Git 入門這樣做&lt;/a&gt; 開始吧！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>隻狼、黑暗靈魂３　白金！</title>
      <link>https://igouist.github.io/post/2021/03/sekiro-darksouls3-clear/</link>
      <pubDate>Sat, 13 Mar 2021 09:38:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2021/03/sekiro-darksouls3-clear/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/9DPgS7X.png&#34; alt=&#34;&#34;&gt;
&lt;img src=&#34;https://i.imgur.com/ElKOIq1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;苦難終於告一段落了，開心到 PO 一篇來紀念一下！&lt;/p&gt;
&lt;p&gt;接下來…… 就坐等血源詛咒上 PC 啦（等得到嗎？）&lt;/p&gt;
&lt;h2 id=&#34;延伸閱讀&#34;&gt;延伸閱讀&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://game.udn.com/game/story/10451/3757216&#34;&gt;就是要逼你正面對決 《隻狼》如何用設計讓玩家展現勇氣？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://opinion.udn.com/opinion/story/6068/3028754&#34;&gt;《血源詛咒》如何善用內在動機讓玩家甘願受虐？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Visual Studio: 書籤 (bookmarks)</title>
      <link>https://igouist.github.io/post/2021/03/visual-studio-bookmark/</link>
      <pubDate>Sat, 13 Mar 2021 00:38:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2021/03/visual-studio-bookmark/</guid>
      <description>&lt;p&gt;今天從同事們那邊學到了書籤這個方便功能，趁還記得的時候來做個紀錄。&lt;/p&gt;
&lt;p&gt;那麼馬上就來操作一次：&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;Ctrl K&lt;/code&gt;, &lt;code&gt;Ctrl K&lt;/code&gt; 可以在指定的行號上加上一個「書籤」&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/uSBHhGt.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (Ex1): 小結</title>
      <link>https://igouist.github.io/post/2021/01/oo-ex1-end2020/</link>
      <pubDate>Fri, 01 Jan 2021 23:50:49 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2021/01/oo-ex1-end2020/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/hycMTRZ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;隨著 2020 進到了 2021，菜雞與物件導向也推進到了五大原則結束，可以暫時告一段落了。&lt;/p&gt;
&lt;p&gt;最初和朋友約好了要把公司新訓學到的東西做個整理（廣告一下他的部落格：&lt;a href=&#34;https://sunnyday0932.github.io/&#34;&gt;Sian&lt;/a&gt;），只是沒想到因為太常發廢文偷懶，大半年才推進到物件導向的基礎而已，甚至占不到新訓內容的十分之一。希望 2021 能繼續推進，把這部份的坑給填一填，然後把前面的文章也重構一下，只是按照我的個性，可能又會忍不住開新的坑吧，哈哈。&lt;/p&gt;
&lt;p&gt;至於物件導向相關的心得和紀錄，也就是這個系列，偶而有想到或是有所體悟的時候再發上來吧，暫時想先把前面隨手寫凌亂文章給整一整先。在這個十幾篇的短系列，記錄了從類別與物件開始，到耦合、內聚及五大原則，每個主題的心得。這邊稍微做個小整理：&lt;/p&gt;
&lt;h3 id=&#34;類別物件post202007oo-1-class-object&#34;&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;類別、物件&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;物件就是用來表達「我們知道的某個東西」，&lt;strong&gt;物件導向是用物件彼此互動的方式來建立架構&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;類別去定義我們要的物件有什麼特徵、有什麼功能，再從類別中實例化（也就是根據設計圖產生）物件出來使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;建構式多載post202007oo-2-constructor-overload&#34;&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;建構式、多載&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;建構式用來在建立物件時就進行一些我們想要的操作，例如狗狗的毛色等等天生的東西，或是這個建立這個物件的必須素材&lt;/li&gt;
&lt;li&gt;多載指的就是可以有很多個同樣名字的方法，各自去接不同的參數，讓同個目標的函式可以&lt;strong&gt;根據傳入的參數不同做不一樣的處理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (15): 最少知識原則</title>
      <link>https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle/</link>
      <pubDate>Sun, 20 Dec 2020 23:57:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/FOWZ8zY.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;上一篇&lt;/a&gt;我們紀錄了依賴反轉原則，到此五大原則介紹完畢…是這樣嗎？太天真了！就像四天王總是五個人一樣，五大原則當然也有第六個！&lt;/p&gt;
&lt;p&gt;今天的主角就是五大原則中Ｌ位的第一候補：&lt;strong&gt;最少知識原則&lt;/strong&gt;，也被稱作&lt;strong&gt;迪米特法則&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;最少知識原則-least-knowledge-principle&#34;&gt;最少知識原則 (Least Knowledge Principle)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;只和直接的朋友溝通，不和陌生人說話&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那麼所謂的朋友是什麼呢？就是指這個物件或方法有直接相關的物件啦。例如當我們使用一個方法時，這個方法應該只認識：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;該方法所屬的類別&lt;/li&gt;
&lt;li&gt;該方法所接收的參數&lt;/li&gt;
&lt;li&gt;該方法中建立的類別&lt;/li&gt;
&lt;li&gt;該方法所屬的類別所依賴的對象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外對這個方法而言都是陌生人。什麼情況會遇到陌生人呢？有一個蠻常遇到的狀況就符合定義：當我們使用依賴對象的方法，該方法給了我們另一個類別時，我們就正在接觸毫無關係的陌生人。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (14): 依賴反轉原則</title>
      <link>https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle/</link>
      <pubDate>Sun, 13 Dec 2020 21:53:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ywiHuis.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在聊依賴反轉之前，先讓我們聊聊什麼是依賴，所謂的依賴就是一種「受到某個東西影響、牽制」的狀態。例如說如果有個像我一樣的肥宅每天一定要來一片雞排才能療癒身心，那我就是依賴雞排；同樣的，如果有個大叔不抽菸就會全身不舒服，就是對香菸有所依賴。當有「必須要藉由某個人事物來達到目的」的狀況時，就是依賴。&lt;/p&gt;
&lt;p&gt;而在程式設計裡面的概念也差不多，如果&lt;strong&gt;Ａ模組直接受到Ｂ模組的影響，我們就稱Ａ依賴了Ｂ&lt;/strong&gt;，最明顯的狀況就是Ａ模組需要藉由Ｂ模組的實例來完成某個功能的時候，例如「匯出報表」功能建立了一個「Excel 控制類別」的實例以建立檔案；或是「會員查詢」功能建立了一個「DB 連線」的實例來進入資料庫取得會員資料，諸如此類由Ａ模組直接藉由Ｂ模組的實例來完成想要的動作，就是依賴。&lt;/p&gt;
&lt;h2 id=&#34;依賴與耦合&#34;&gt;依賴與耦合&lt;/h2&gt;
&lt;p&gt;我們在之前的 &lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;耦合篇&lt;/a&gt; 提過，如果模組和另一個模組之間有關連，那這兩者之間就耦合。以此來看，依賴就是一種耦合的關係，那麼，依賴是健康還是不健康的耦合呢？&lt;/p&gt;
&lt;p&gt;現在讓我們用 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;多型篇&lt;/a&gt; 用過的「老闆徵工程師」的例子來舉例一下：現在有間小小公司，老闆請來了小明當工程師，並請他開工撰寫產品程式碼。&lt;/p&gt;
&lt;p&gt;當「撰寫產品程式」對「工程師」直接依賴的時候，狀況可能是這樣的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Product Work()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Ming programmer = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Ming();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; product = programmer.Programming();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; product;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;過一陣子，老闆發現小明寫出來的東西似乎不太行，於是把小明趕走，另外請了小華。這時候因為「工程師」這個實作類別不一樣了，我們就必須要改一次程式碼：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Product Work()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Hua programmer = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Hua();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; product = programmer.Programming();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; product;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>7&#43; Taskbar Tweaker —— 簡單方便的 Windows 工作列調整工具</title>
      <link>https://igouist.github.io/post/2020/12/7_taskbar/</link>
      <pubDate>Sun, 06 Dec 2020 23:49:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/12/7_taskbar/</guid>
      <description>&lt;p&gt;故事是這樣的——&lt;/p&gt;
&lt;p&gt;Win10 工作列的合併設定有這些選項：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/yZypwQD.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;當選擇「一律、隱藏標籤」時，工作列上同樣的程式就會摺疊起來：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/8JvOmkJ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;而「永不」和「當工作列滿時」則會將工作列展開：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/BqA2ERo.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;好的，那麼像我個性這麼麻煩的人，如果覺得顯示名字很佔位置，可是又不想要摺疊之後按兩次才能打開我要的應用程式，偏偏又很愛開一整排 IDE 的話，有沒有什麼簡單的辦法&lt;strong&gt;不要讓圖示合併，但也不要顯示名字呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果有個小工具，可以讓這些工作列的設定更彈性就好了，會有嗎？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>讀《離開公司，我過得還不錯》</title>
      <link>https://igouist.github.io/post/2020/11/i-am-doing-well-after-leaving-the-company/</link>
      <pubDate>Sun, 29 Nov 2020 23:54:06 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/11/i-am-doing-well-after-leaving-the-company/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/8QX3RPd.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;無論喜不喜歡自己的工作，都應該好好思考自己和工作的關係，畢竟每天花三分之一的時間做這件事，如果和它處得不好，人生也不可能會變好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這本書並不是那種精神勝利法，又或是超猛接案全攻略之類的書；反而給我的感覺比較像是作者藉著這本書，分享他這一路摸索的心得，和遭遇到的一些困難，看的時候有種像在和作者聊聊天的感覺。&lt;/p&gt;
&lt;p&gt;也因為這本書比較接近作者分享他選擇的道路、內容比較廣雜，遇到的部分都稍微說一些，但不是那種針對某個議題深入探討的書籍，所以比較適合想稍微了解自由工作的朋友閱讀。同時也必須了解到，自由工作者也只是眾多職業道路的其中一種，每個人的條件也不盡相同，因此抱持著好奇的心情閱讀，會更有收穫的感覺。&lt;/p&gt;
&lt;p&gt;從 &lt;a href=&#34;https://www.books.com.tw/products/0010810277&#34;&gt;博客來&lt;/a&gt; 的書籍簡介就可以看到，目錄真的把自由工作遇到的議題都碰了一些：從適不適合接案工作，到報稅、勞保、合約、工作場所都聊了一點。因為真的挺廣的，這邊我就只記錄一些我比較感興趣的話題。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞抓蟲: 在 Amazon Linux AMI 安裝 .net Core 時卡在 Requires: openssl-libs</title>
      <link>https://igouist.github.io/post/2020/11/bugs-install-dotnet-core-on-amazon-ami-requires-openssl/</link>
      <pubDate>Sun, 22 Nov 2020 23:40:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/11/bugs-install-dotnet-core-on-amazon-ami-requires-openssl/</guid>
      <description>&lt;p&gt;最近遇到在 Amazon Linux AMI 要安裝 .net Core 3.1 環境的時候，會一直跳出&lt;br/&gt; &lt;code&gt;Requires: openssl-libs&lt;/code&gt; 而無法安裝的問題，儘管明明已經有 openssl 了，但還是解析失敗找不到依賴，過程一直碰壁，因此在這邊紀錄一下。&lt;/p&gt;
&lt;p&gt;過程中嘗試了安裝 openssl-libs（會找不到該套件）、下載 Dotnet 的 tar.gz ，再直接對執行檔下 Dotnet 指令起站台（雖然網站起得來，但執行者會是當下的登入身分，也就是 &amp;lsquo;&amp;rsquo;@連線進來的IP-伺服器位置，而非由本機執行。後續如果有連線資料庫等檢查權限的地方就很容易出錯）&lt;/p&gt;
&lt;p&gt;最後在 Dotnet Core 的 issue 翻到這篇 &lt;a href=&#34;https://github.com/dotnet/core/issues/930&#34;&gt;Cannot install .NET Core 2.0 on Amazon Linux AMI&lt;/a&gt; 才成功解決。&lt;/p&gt;
&lt;p&gt;首先先將 openssl-libs 的 SPEC 抓下來，然後給 RPM 建置一下。這兩句可以參考一下這篇 &lt;a href=&#34;https://medium.com/linux-%E9%96%8B%E7%99%BC%E5%85%A5%E9%96%80/rpm-%E6%89%93%E5%8C%85-%E7%94%B1%E4%B8%80%E7%AB%85%E4%B8%8D%E9%80%9A%E5%88%B0%E5%8B%95%E6%89%8B%E6%BF%AB%E7%94%A8-%E4%BA%8C-df9eea70bd7b&#34;&gt;RPM 打包︰由一竅不通到動手濫用 (二)&lt;/a&gt; 的說明。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;wget https://github.com/dotnet/core/files/2186067/openssl-libs-ami.spec.txt
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rpmbuild --bb openssl-libs-ami.spec.txt
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (13): 介面隔離原則</title>
      <link>https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle/</link>
      <pubDate>Sun, 15 Nov 2020 12:00:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/itHN6VZ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;今天要記錄的是介面隔離原則，顧名思義是和介面高度相關的原則。因此在閱讀本篇之前，可能需要先對 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;介面&lt;/a&gt; 有一點了解呦。&lt;/p&gt;
&lt;p&gt;事情就從上一篇 &lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;里氏替換原則&lt;/a&gt; 的鳥類物流公司開始說起。老闆痛定思痛，決定先用&lt;strong&gt;介面&lt;/strong&gt;先規定好物流士們的應徵條件，例如裝貨、卸貨、飛行、必須有帥氣的喙等等。&lt;/p&gt;
&lt;p&gt;這道命令下來後，倉庫們的企鵝都慌了，來檢查的編譯器瘋狂跳出 Error:「您未實作 IBird 的 Fly() 方法！」這下怎麼辦呢，為了要保住飯碗，企鵝們就必須實作出飛行才行，可是企鵝真的就不會飛呀！&lt;/p&gt;
&lt;p&gt;這下子企鵝們只剩下兩個選擇：不實作飛行，但是就不能被當成物流士，最後就會被開除；或是……空實作。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Penguin&lt;/span&gt; : IBird
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Fly()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// Do nothing;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;企鵝們終於騙過了編譯器檢查員，然而當送貨的命令下來之後，企鵝們再一次卡在倉庫門口發呆，最終物流公司仍然踏上了虧損的老路，再度面臨倒閉危機…&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Dark Reader —— 暗黑模式愛好者的 Chrome 必備套件</title>
      <link>https://igouist.github.io/post/2020/11/dark-reader/</link>
      <pubDate>Sun, 08 Nov 2020 23:39:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/11/dark-reader/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/G4OjUzE.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不能信任那些 Terminal 或編輯器用白底的人。&lt;/br&gt;
—— &lt;a href=&#34;https://github.com/CodeTengu/JokeKappa/blob/master/jokekappa/jokes/codetengu_weekly.json&#34;&gt;JokeKappa&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這禮拜推薦了個常用的 chrome 套件給同樣喜歡黑色背景的同事，這邊也推薦給大家。&lt;/p&gt;
&lt;p&gt;&lt;s&gt;絕對不是因為隻狼更新了不小心砍太爽，結果來不及寫介面隔離只能介紹套件水一下，Heiya～&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;今天要介紹的就是這款 &lt;a href=&#34;https://chrome.google.com/webstore/detail/dark-reader/eimadpbcbfnmbkopoojfekhnkhdbieeh&#34;&gt;Dark Reader&lt;/a&gt;，這是我用 chrome 時首選的暗黑模式擴充套件，在俺寫文的這時候已經超過了三百萬次的下載次數，現在就讓我來記錄一下這款擴充套件的一些特色唄。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (12): 里氏替換原則</title>
      <link>https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle/</link>
      <pubDate>Sun, 01 Nov 2020 11:31:44 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ZAuxFRy.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;里氏替換原則-liskov-substitution-principle&#34;&gt;里氏替換原則 (Liskov Substitution Principle)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;子類別必須能夠替換父類別&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;里氏原則還包含了一個概念：子類別替換父類別後，&lt;strong&gt;不需要改變，也不會發生任何錯誤或異常&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;從定義就可以看出來，這項原則是來替我們處理繼承問題的。因此，在開始本篇之前，可能需要先對 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;繼承&lt;/a&gt; 以及 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;多型&lt;/a&gt; 有基本的認識。如果可以的話，也請先看過 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;介面&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;那麼，就讓我們從很久很久以前開始說起…&lt;/p&gt;
&lt;h2 id=&#34;我的子類別進入叛逆期了怎麼辦&#34;&gt;我的子類別進入叛逆期了，怎麼辦？&lt;/h2&gt;
&lt;p&gt;很久很久以前，有一間公司受到 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%BB%A5%E9%B8%9F%E7%B1%BB%E4%B8%BA%E8%BD%BD%E4%BD%93%E7%9A%84%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE&#34;&gt;鴿子封包&lt;/a&gt; 所啟發，打算發展鳥類運輸技術，強勢打入無人機市場，用生物智慧掀起對人工智慧的革命。既然&lt;strong&gt;鳥類都會飛行&lt;/strong&gt;，理所當然可以藉由飛行來進行空運，甚至還可以偷偷擊墜那些無人機對手，野心勃勃的老闆立馬徵了一批鳥類物流士，打出「凡是鳥類都可應徵」的旗號，各式各樣的猛禽響應而來，一時之間掀起整個物流業的風暴！&lt;/p&gt;
&lt;p&gt;但是好景不常，公司營運之後發貨狀況不佳，頻繁發生丟包問題，甚至有些貨根本就出不了倉庫，虧損越來越大，心急如焚的老闆下令徹查，這才發現—&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (11): 開放封閉原則</title>
      <link>https://igouist.github.io/post/2020/10/oo-11-open-closed-principle/</link>
      <pubDate>Sun, 25 Oct 2020 11:58:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/10/oo-11-open-closed-principle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/6pQOti2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;開放封閉原則-open-close-principle&#34;&gt;開放封閉原則 (Open-Close Principle)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;軟體實體（類別、模組、函式等等）應該對擴展開放，而對修改封閉&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我們了解什麼是「對擴展開放」和「對修改封閉」之前，先讓我們談談：什麼是擴展，什麼又是修改呢？&lt;/p&gt;
&lt;p&gt;用白話一點的方式來形容，修改就是把東西拆開來改，像是手術；而擴展就是對東西額外加裝模組，像是添購設備。我們用飛行來舉例，像是鳥類直接用翅膀飛行，如果有需要修改飛行方法的話就得對鳥直接進行手術；但如果今天是一個裝備了噴射背包的人，我們只需要把噴射背包換成噴射鞋子、甚至噴射翅膀就可以了，不需要去修改人這個本體。&lt;/p&gt;
&lt;p&gt;這邊可以發現開放封閉原則是針對「改變的時候」去做一個行動的建議，例如需求追加和變更等等。&lt;strong&gt;凡是變化都有成本&lt;/strong&gt;，例如變動的難易度、變動造成的影響範圍等等都會影響到成本，若是程式碼冗長、內部邏輯複雜，類別之間互相耦合、影響範圍很廣，導致綁手綁腳或壞東壞西等等狀況，使得修改很困難，成本就會變高，進而使得開發效率變低。&lt;/p&gt;
&lt;p&gt;然而，軟體並不是製造完畢就完工的東西，而是隨需求而生、隨需求而變的動態作品，因此程式碼的修改或重構相當頻繁。就像我們在 &lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;內聚耦合篇&lt;/a&gt; 提過的：軟體面對改變的能力，就像基因適應環境並生存下去的能力。因此，程式必須具有彈性，也就是需要盡可能降低修改的成本。&lt;/p&gt;
&lt;p&gt;那麼讓我們回到前面：動手術跟換道具，哪個的成本比較高呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;面對需求，對程式碼的改動是透過增加新程式碼進行的，而不是更改現有的程式碼&lt;/strong&gt;　　
&lt;br/&gt;（《大話設計模式》）&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>菜雞的 Markdown 筆記</title>
      <link>https://igouist.github.io/post/2020/10/markdown/</link>
      <pubDate>Sun, 18 Oct 2020 22:00:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/10/markdown/</guid>
      <description>&lt;p&gt;Markdown 是一種寫作用語言，特色是只要用簡單的符號就可以替文章進行排版，例如 &lt;code&gt;#&lt;/code&gt; 就代表了標題，因此能相當簡潔迅速地應用 Markdown 語法來撰寫出文件，目前已經被廣泛使用在各個撰寫文章或是文檔的場景中。&lt;/p&gt;
&lt;p&gt;例如 Github 用來說明專案的 Readme.md，從副檔名 md 就已經告訴你這是一篇 Markdown；又像是這個部落格的文章，也都是使用 markdown 來寫的。除此之外，像是 Facebook 和 Line 都開始支援簡單的 Markdown 語法了 —— 因為它實在是太方便好用了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用Markdown格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成 —— markdown.tw&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然用簡單的符號就能完成這些簡潔的排版，我們自然就能把專注的重心挪回到撰寫文章本身，這也就是 Markdown 最大的魅力：&lt;strong&gt;專注於內容&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;也因為 Markdown 的特色就是非常的簡潔乾淨，文檔本身的可讀性就相當的高，撰寫起來也很直覺容易。就如同其說明文件所說的：「Markdown 的目標就是實現『&lt;strong&gt;易讀易寫&lt;/strong&gt;』」&lt;/p&gt;
&lt;p&gt;這篇就來稍微紀錄一下 Markdown 的常用語法和好用的編輯環境吧！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>聊一下外接螢幕</title>
      <link>https://igouist.github.io/post/2020/10/external-screen/</link>
      <pubDate>Sun, 11 Oct 2020 23:50:17 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/10/external-screen/</guid>
      <description>&lt;p&gt;這週入手了新玩具，在這邊記錄下～&lt;/p&gt;
&lt;p&gt;&lt;s&gt;我們家大神大大跟我說部落格就當推特發就對了，唉呀我也是深表認同吶&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/5BHHs9a.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;像我這種被實驗室和公司寵壞的人，已經習慣了雙螢幕的好。結果不管是在放不下兩台螢幕的家裡書桌，還是帶著筆電出門，尤其是一邊寫東西一邊查資料，需要來來回回切換視窗時，總是會想「唉呀真想把這丟到另一個螢幕啊！」&lt;/p&gt;
&lt;p&gt;因此！幾經掙扎之後，還是入手了外接螢幕！&lt;/p&gt;
&lt;p&gt;開場先說心得，雖然尚未有外出機會，但目前的使用相當滿意。這邊就說說個人體會的好壞：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2021/1/30 補充：外出也相當方便，只是桌面的空間就需要大一點&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (10): 單一職責原則</title>
      <link>https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle/</link>
      <pubDate>Fri, 02 Oct 2020 11:03:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/VyyeaYz.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我們在前面的 &lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;內聚和耦合&lt;/a&gt; 有提到過，內聚並不是無腦把相關的程式碼都封在一起就好了，也有分成健康的和不健康的。但我們要怎麼知道這個類別是否足夠健康呢？單一職責原則就是很好的檢驗方式，這篇就讓我們來紀錄一下。&lt;/p&gt;
&lt;h2 id=&#34;單一職責原則-single-responsibility-principle&#34;&gt;單一職責原則 (Single Responsibility Principle)&lt;/h2&gt;
&lt;p&gt;「單一職責」原則顧名思義，就是一個類別應該&lt;strong&gt;只負責一個職責&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但是這樣太過籠統了，「職責」相當容易產生誤會，容易變成各說各話。&lt;s&gt;畢竟咱們工程師最愛戰定義了嘛。&lt;/s&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;「你這類別不優，它有兩個職責！登入跟登出！」&lt;/p&gt;
&lt;p&gt;『沒有啦，我這個類別就是負責帳戶管理的啊』&lt;/p&gt;
&lt;p&gt;「&lt;a href=&#34;https://dailyview.tw/Daily/2019/11/07&#34;&gt;OSSO&lt;/a&gt;。乾脆你全部放一起，然後說是負責網站管理算了，呵」&lt;/p&gt;
&lt;p&gt;『……你存心來找碴的是不是？』&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;為了避免像這樣產生職場糾紛，我們需要先定義一下什麼是「職責」。經過前輩們的努力（解釋）之後，單一職責的定義就成了：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;就一個類別而言，應該只有一個引起它變化的原因&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外，我也看過「一個類別應該只對一個角色負責」的說法，這兩者的核心概念是一樣的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C#: 元組 (Tuple)</title>
      <link>https://igouist.github.io/post/2020/09/csharp-trulp/</link>
      <pubDate>Sun, 27 Sep 2020 23:56:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/09/csharp-trulp/</guid>
      <description>&lt;p&gt;因為隔壁介紹原則的部分有點卡住了，所以這週來紀錄一下挺常用到的方便東西：&lt;strong&gt;Tuple&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;這篇的 Tuple 指的是 C# 7.0 後提供的 &lt;strong&gt;ValueTuple&lt;/strong&gt; 和相關語法，舊版得用 &lt;code&gt;Tuple.Create&lt;/code&gt; 建立，成員的名稱也只能使用 Item1, Item2&amp;hellip;，實用性並不是很高。但新 Tuple 出現後，方便程度大大提升，這邊就稍作紀錄一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;註：此處使用的 &lt;code&gt;Dump&lt;/code&gt; 是 Linqpad 提供的輸出方法，把它當成 Print 就行了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; student = (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;王小明&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;student.Item1.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// 1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;student.Item2.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// 王小明&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;student.Dump();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到 Tuple 的建立相當簡單，只需要用小括號 &lt;code&gt;()&lt;/code&gt; 括選起來即可。建立後的內容就會像這樣：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/H0wJglN.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;但這樣使用就和之前一樣，取出來時只能拿 Item1, Item2，放個幾天根本就不記得 Item1 裡面是啥東西了。這時我們就可以&lt;strong&gt;替成員們取名字&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ID, &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; Name) student = (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;王小明&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;student.ID.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// 1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;student.Name.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// 王小明&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如此使用的時候就和一般操作物件的習慣沒有差別，也增加了可讀性。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (9): SOLID</title>
      <link>https://igouist.github.io/post/2020/09/oo-9-solid/</link>
      <pubDate>Sun, 20 Sep 2020 13:51:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/09/oo-9-solid/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/U7iWMT9.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;終於進入了原則篇，接下來的幾篇我們會介紹幾個物件導向的原則（基本上就是指 SOLID 原則）。因此這篇就讓我 &lt;s&gt;水一下&lt;/s&gt; 當成後半段的目錄，方便之後可以把相關的部分整理進來。&lt;/p&gt;
&lt;h2 id=&#34;為什麼我們需要這些原則&#34;&gt;為什麼我們需要這些原則？&lt;/h2&gt;
&lt;p&gt;我們在前面的章節已經說明了一些物件導向的特性，例如繼承和多型等等。然而我們並沒有討論到怎麼運用、或是怎樣設計才能算是更好的、更優雅的、更符合物件導向精神的；我們並沒有提到一個評估的標準，或是指引一個更好的方向。&lt;/p&gt;
&lt;p&gt;然而，混亂的使用物件導向對整個專案的毀滅性甚至比乾脆不使用物件導向還高。&lt;/p&gt;
&lt;p&gt;這些特性使用起來很簡單，大多數語言只需要一個符號或標示就能完成繼承，把一堆東西全部塞在一起就可以說我在封裝。但怎麼使用得好，又該什麼時候使用呢？這就是難的地方吧。&lt;/p&gt;
&lt;p&gt;例如說濫用繼承，或是封裝時完全不隱藏複雜度一路 Puuuuublic 到底，又或者是類別之間過於相互依賴，全部耦合成一團等等。如果隨便地使用物件導向的各項特性，就會讓整個架構變得僵化、脆弱、危險、充滿臭味。&lt;/p&gt;
&lt;p&gt;更可怕的是，這個發臭的過程是每一次設計、每一次修改都會有所影響，所謂「持續發生，腐敗成真」，&lt;strong&gt;隨著物件導向的亂用、誤用、無腦用，軟體就會逐漸腐化&lt;/strong&gt;。一組腐化的軟體可能會有以下特徵：大量的依賴使得修改變得困難、修改後看似不相干的各個地方發生問題、或是修改時沒辦法依循原本的設計、到處出現不必要的複雜性和不必要的重複，模組也變得難以理解等等。&lt;/p&gt;
&lt;p&gt;阻止程式碼的腐化、追求更好的架構和設計、寫出更好的代碼，當然是我輩所追求的目標。儘管面對的可能是不同的問題和不同的環境，那些優質、穩固、具有&lt;strong&gt;反脆弱&lt;/strong&gt;特質的程式碼也必然會有些共通之處。例如說：需要具有&lt;strong&gt;面對改變&lt;/strong&gt;的能力、具有&lt;strong&gt;方便管理&lt;/strong&gt;的能力、具有&lt;strong&gt;隱藏複雜性&lt;/strong&gt;的能力。&lt;/p&gt;
&lt;p&gt;因此，大前輩們整理並提出了一些可以致力的方向，也就是所謂的「&lt;strong&gt;原則&lt;/strong&gt;」。如同心法、教義一般，只要實作的同時將其牢記在心，就能讓我們作為一些行動的準則和依據。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (8): 內聚、耦合</title>
      <link>https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling/</link>
      <pubDate>Sun, 13 Sep 2020 23:56:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/cgxW9yZ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;做為前後段落的分水嶺，這篇文章我將紀錄一下 &lt;strong&gt;「內聚」(Cohesion)&lt;/strong&gt; 和 &lt;strong&gt;「耦合」(Coupling)&lt;/strong&gt;，這兩者是評估一個類別或元件的重要概念。&lt;/p&gt;
&lt;p&gt;在實務上，為了提升擴展性，降低維護成本等因素，我們對於單個類別或元件，會有著 &lt;strong&gt;「低耦合」&lt;/strong&gt; 及 &lt;strong&gt;「高內聚」&lt;/strong&gt; 的期待。例如我們在 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt; 中，我們就有提到封裝的好壞相當重要，其中也包含了「提高類別內的內聚性，降低對外的耦合性」。那麼，到底什麼是內聚，什麼又是耦合呢？&lt;/p&gt;
&lt;h2 id=&#34;內聚&#34;&gt;內聚&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;「把需要的程式和資料都包裝在同一個模組內，使得該模組能夠做為一個單獨的個體執行」&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;白話一點說，就是就是把用到的東西都打包到一處，該有的自己都有了，所以即使單獨一個人也能完成工作的能力、可以自己 Carry 整場不用看豬隊友臉色的能力。越能自己單幹，越不需要依賴其他類別的時候，內聚力也就越高。&lt;/p&gt;
&lt;p&gt;也就是說：如果你的類別什麼都要依賴其他類別，像小嬰兒一樣需要呵護照顧，那內聚力就很低。反之，如果像野外求生大師，啥都靠自己，那內聚力就超高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;內聚代表的是該模組的獨立性，當這個模組可以獨力完成工作，就代表我們能夠重複使用它，且不需要擔心影響到其他模組。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;並且也基於這點，我們不用擔心變動這個模組時需要先處理其他的模組，因為這個工作所需的都包含在模組內了，這樣就可以&lt;strong&gt;單獨修改&lt;/strong&gt;該模組，減少維護成本。&lt;/p&gt;
&lt;p&gt;例如你的筆已經包含了所有寫字工具的條件，具有墨水跟筆芯等等，可以只使用筆就完成寫字這個工作。那麼我們就可以隨身帶著，在任何需要的時候重複使用它，而不用擔心我們會不會漏了什麼必要零件沒有帶出門。同時，如果我們需要換筆芯或墨水，我們也知道要更換的部份就在筆裡面，不需要去找鉛筆盒中別的地方。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>讀《先問為什麼》</title>
      <link>https://igouist.github.io/post/2020/09/start-with-why/</link>
      <pubDate>Sun, 06 Sep 2020 10:02:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/09/start-with-why/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/mC6ySzk.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你樂於接納新事物，希望成功能持久，也相信自己的成功需要別人的幫助&lt;/p&gt;
&lt;p&gt;我向你提出一個挑戰 ——&lt;/p&gt;
&lt;p&gt;從今天起，做任何事情之前，請先問自己「為什麼」。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這本書的中文副標很好地點出了本書的重點：顛覆慣性思考的&lt;strong&gt;黃金圈理論&lt;/strong&gt;，啟動你的&lt;strong&gt;感召領導力&lt;/strong&gt;。大多篇幅用在舉例以及逐步說明何謂感召，以及黃金圈。&lt;/p&gt;
&lt;p&gt;本書的想法和一些例子，尤其是書中最重要的黃金圈理論，在作者上 TED 的影片「&lt;a href=&#34;https://www.ted.com/talks/simon_sinek_how_great_leaders_inspire_action?language=zh-tw&#34;&gt;偉大的領袖如何鼓動行為&lt;/a&gt;」都有說明，有興趣的朋友可以直接看演講影片，足夠掌握到黃金圈理論的核心。&lt;/p&gt;
&lt;iframe src=&#34;https://embed.ted.com/talks/lang/zh-tw/simon_sinek_how_great_leaders_inspire_action&#34; width=&#34;100%&#34; height=&#34;480&#34; frameborder=&#34;0&#34; scrolling=&#34;no&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;（偉大的領袖如何鼓動行為 - TED）&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C#: 時區轉換、民國西元、國曆農曆、中文月份週期</title>
      <link>https://igouist.github.io/post/2020/08/csharp-timezone/</link>
      <pubDate>Sun, 30 Aug 2020 11:58:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/08/csharp-timezone/</guid>
      <description>&lt;p&gt;聊到將時間從 UTC 轉到台灣時間，居然還是聽到朋友表示使用 +8 小時的做法，驚為天人。這種做法可能會造成後續的問題，例如時區並不會跟著變動，或是遇到日光節約等特殊狀況就容易出事。和西元民國轉換直接 -1911 一樣不穩定。&lt;/p&gt;
&lt;p&gt;這篇就用來記錄一下之前看過比較優雅的時區轉換方式，順便將先前存著的時間處理相關資料整理一下，方便之後需要時可以馬上回來查詢。&lt;/p&gt;
&lt;h2 id=&#34;timezoneinfo-時區資訊&#34;&gt;TimeZoneInfo: 時區資訊&lt;/h2&gt;
&lt;p&gt;轉換方式主要參考自 &lt;a href=&#34;https://dotblogs.com.tw/supershowwei/2016/10/17/141620&#34;&gt;[食譜好菜] DateTime 具有文化特性的格式化及時區的轉換&lt;/a&gt; 及 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/standard/datetime/converting-between-time-zones&#34;&gt;在各時區間轉換時間&lt;/a&gt;，感謝前人的指引。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;關於文化特性，也可以參考本站的 &lt;a href=&#34;https://igouist.github.io/post/2021/10/csharp-datatime-tostring-cultureinfo&#34;&gt;菜雞抓蟲: DateTime.ToString() 之我們不一樣 &amp;amp; CultureInfo 文化特性小筆記&lt;/a&gt; 呦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 假設現在是要從標準時區 +00:00 轉換到台灣時區，故這邊使用 UtcNow 先取標準世界協調時間&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; nowDateTime = DateTime.UtcNow;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;nowDateTime.ToString(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;yyyy/MM/dd H:mm:ss zzz&amp;#34;&lt;/span&gt;).Dump();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 2020/08/30 15:56:05 +00:00&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ==================================================&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 傳統的 直接對時間做計算的方式…&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; addedDateTime = nowDateTime.AddHours(&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;addedDateTime.ToString(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;yyyy/MM/dd H:mm:ss zzz&amp;#34;&lt;/span&gt;).Dump();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 2020/08/30 23:56:05 +00:00&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 可以看到儘管時間變動了，時區仍然還在 +00:00&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ==================================================&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 使用 TimeZoneInfo 先取得台北時區&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; timeZone = TimeZoneInfo.FindSystemTimeZoneById(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Taipei Standard Time&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 再使用 TimeZoneInfo 來變更時間&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; convertedDateTime = TimeZoneInfo.ConvertTime(nowDateTime, timeZone);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;convertedDateTime.ToString(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;yyyy/MM/dd H:mm:ss zzz&amp;#34;&lt;/span&gt;).Dump();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 2020/08/30 23:56:05 +08:00&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 可以看到除了時間變更以外，時區也切換到 +08:00 了！&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面取得台北時區的步驟，可以參照 &lt;a href=&#34;https://docs.microsoft.com/en-us/previous-versions/windows/embedded/gg154758(v=winembedded.80)&#34;&gt;Time Zone IDs&lt;/a&gt; 來查詢想要的時區。這樣的時區切換方式，不僅副作用少，不會因為時區沒轉雷到後續接手的人，也省卻了擔心日光節約等等問題，這種事就交給微軟去煩惱吧！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Powershell 美化作戰 —— 字型、執行原則和 oh-my-posh</title>
      <link>https://igouist.github.io/post/2020/08/powershell-beauty/</link>
      <pubDate>Sat, 15 Aug 2020 18:00:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/08/powershell-beauty/</guid>
      <description>&lt;p&gt;最近在兩天內經歷了記憶體死去、系統毀損、機殼碎裂等等，終於電腦重灌。一堆設定都要重弄，正好也是個機會，這篇順手記一下常用好幫手 Powershell 的美化步驟。&lt;/p&gt;
&lt;p&gt;先放一張施工後的圖鎮樓：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/417skJs.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以在開始圖示上用右鍵打開選單，之後點選 Powershell；或是 Win + X 打開選單，然後按 I 或 A （後者會以系統管理員身分開啟）就能開啟了。&lt;/p&gt;
&lt;p&gt;如果選單打開還是 CMD 而不是 Powershell 的，可以先去切換成 Powershell，真的是比較好用啦（&lt;a href=&#34;https://www.microsoft.com/zh-tw/p/windows-terminal/9n0dx20hk701?activetab=pivot:overviewtab&#34;&gt;Windows Terminal&lt;/a&gt; 笑而不語）&lt;/p&gt;
&lt;p&gt;剛打開的畫面是這樣的：
&lt;img src=&#34;https://i.imgur.com/JE6BTSU.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;抱歉，光細明體我就不太行了。所以接下來就從字型這些內建設定開始！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C#: 字串插值 (String interpolation) 的格式化</title>
      <link>https://igouist.github.io/post/2020/08/csharp-string-interpolation/</link>
      <pubDate>Sun, 09 Aug 2020 20:35:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/08/csharp-string-interpolation/</guid>
      <description>&lt;p&gt;自從 C# 有了 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/csharp/language-reference/tokens/interpolated&#34;&gt;字串插值&lt;/a&gt; 這東西之後，我就一直是愛用者。畢竟比起 &lt;code&gt;string.format&lt;/code&gt; 這東西可是看起來優雅多了。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;哈囉，{userName} 您的點數將於 {cutoffTime} 到期。&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;簡潔又明瞭，一眼就能理解字串內容。實在是挺方便，後來發現這東西還有一些延伸用法，這邊就稍加紀錄一下：&lt;/p&gt;
&lt;p&gt;字串插值中能夠做&lt;strong&gt;簡易計算&lt;/strong&gt;，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;您輸入的數值為：{a}、{b}。他們相加為：{a + b}&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;同時，在字串插值時可以針對內容作格式化，只需要用 &lt;code&gt;:&lt;/code&gt; 來區隔，妥善運用可以省下一堆 &lt;code&gt;ToString()&lt;/code&gt; 的空間。&lt;/p&gt;
&lt;p&gt;例如當我們要將&lt;strong&gt;時間&lt;/strong&gt;格式化的時候，就可以：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; date = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; DateTime(&lt;span style=&#34;color:#ae81ff&#34;&gt;2020&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;您的商品已於 {date:yyyy/MM/dd} 抵達。&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 您的商品已於 2020/08/09 抵達。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外，&lt;strong&gt;數值&lt;/strong&gt;當然也可以格式化，不過數值的應用比較複雜，主要是用來定下小數點、百分比等符號的位置。
可以參見 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/standard/base-types/custom-numeric-format-strings&#34;&gt;自訂數值格式字串 - Microsoft Docs&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; cost = &lt;span style=&#34;color:#ae81ff&#34;&gt;2100&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message1 = &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;您的商品一共是 {cost:#,###} 元&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 用 # 可以替數字預留位置&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 您的商品一共是 2,100 元&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message2 = &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;您的商品一共是 {cost:#,###.00} 元&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 也可以用 0 來預留位置，若該數字有值就會顯示該數字，沒有就會自動補 0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 您的商品一共是 2,100.00 元&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>C#: 使用 System.Environment 取得環境資訊、特殊資料夾路徑</title>
      <link>https://igouist.github.io/post/2020/08/system-environment/</link>
      <pubDate>Sun, 02 Aug 2020 13:31:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/08/system-environment/</guid>
      <description>&lt;p&gt;有時候我們會需要取得一些系統資訊，例如說取得設備和當前使用者等資料來寫 Log，或是取得特殊資料夾路徑、讀取環境變數等等。這些時候就可以使用 &lt;code&gt;System.Environment&lt;/code&gt; ，這邊就稍微紀錄一下用法。&lt;/p&gt;
&lt;p&gt;先列出幾個常用的&lt;strong&gt;環境資訊&lt;/strong&gt;，詳細可查詢的內容可以到 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/api/system.environment?view=netcore-3.1&#34;&gt;Environment Class&lt;/a&gt; 查詢：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/8L67T46.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;資料夾路徑&lt;/strong&gt;則需要用 &lt;code&gt;Environment.GetFolderPath&lt;/code&gt; 搭配 &lt;code&gt;Environment.SpecialFolder&lt;/code&gt; 列舉使用，該列舉包含資料夾可以到 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/api/system.environment.specialfolder?view=netcore-3.1&#34;&gt;Environment.SpecialFolder Enum&lt;/a&gt; 查詢。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/aOQ30KB.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C#: 程式碼風格備忘</title>
      <link>https://igouist.github.io/post/2020/07/code-style/</link>
      <pubDate>Sat, 25 Jul 2020 00:16:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/code-style/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;前言：本篇是整理公司規範和網路文章後，方便我自己在各個場所也能回來查閱使用的，故仍會不定時修改（畢竟我這人挺三心二意的）。另外本篇有重新調整過行距，發現有點跑版的朋友可以先 Ctrl+F5 一下，感謝閱讀。&lt;/p&gt;
&lt;p&gt;如果你想知道的是如何寫出更優雅、更乾淨、品質更高的程式碼，那並不是該看這篇我個人的備忘錄，我會建議可以閱讀&lt;a href=&#34;https://www.tenlong.com.tw/products/9789862017050?list_name=e-106&#34;&gt;《無暇的程式碼》&lt;/a&gt;。或是可以參考這幾篇，我覺得都寫得很好：&lt;a href=&#34;https://ithelp.ithome.com.tw/users/20107637/ironman/1927&#34;&gt;可不可以不要寫糙 code&lt;/a&gt;、&lt;a href=&#34;https://ithelp.ithome.com.tw/users/20107637/ironman/1927&#34;&gt;Clean Code 無瑕的程式碼閱讀筆記&lt;/a&gt;、&lt;a href=&#34;https://ithelp.ithome.com.tw/users/20112160/ironman/1988&#34;&gt;易讀程式之美學&lt;/a&gt;，共勉之。&lt;/p&gt;
&lt;p&gt;如果你是正巧路過並且也寫 C#，希望這篇能讓你做為參考。但請記得，程式碼風格沒有絕對，最終還是回歸到團隊能否接受和將來的可維護性去考慮，畢竟教條是死的，人是活的。了解這樣做背後的原因，以及為自己寫的程式碼負責，這些都比對著隻字片語斤斤計較更加重要。&lt;/p&gt;
&lt;p&gt;Nothing is true, everything is permitted. —— Assassin&amp;rsquo;s creed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;命名原則&#34;&gt;命名原則&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;想像下一個接手你程式碼的人是個暴力傾向的重度精神病患者&lt;/p&gt;
&lt;p&gt;而且他知道你住在哪。　　—— 《無瑕的程式碼》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;strong&gt;有意義的命名&lt;/strong&gt;，請重視描述性。除了迴圈計數器例外&lt;/li&gt;
&lt;li&gt;盡量不要超過五個單字&lt;/li&gt;
&lt;li&gt;業界和慣例中有對應縮寫時可以使用縮寫&lt;/li&gt;
&lt;li&gt;承上，縮寫兩個字母時全大寫，三個字母以上時只第一字大寫&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;命名空間&#34;&gt;命名空間&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;基礎類別庫：{組織} . {大類/應用範圍} . {小類/專案名稱}
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MyStudio.Libs.Basic&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MyStudio.Libs.Web.BaseTools&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;專案類別庫：{專案名稱} . {子專案/類別/用途}
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MyProject.Permiss.Proxy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MyProject.Permiss.Repository&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Pocket —— 稍後閱讀，想看再看</title>
      <link>https://igouist.github.io/post/2020/07/pocket/</link>
      <pubDate>Sat, 18 Jul 2020 10:17:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/pocket/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;前言：由於我這人特喜歡發完文之後一想到就回去改改，因此現在還在修改上一篇物件導向的內容囧。講好聽是有持續交付的精神，講難聽就是比較後知後覺一點。因此這幾篇仍會像之前我要買便當系列一樣，主軸間穿插個幾篇小工具或心得，以這個節奏前進。所以這邊就介紹一下我幾乎每天都會用到的小工具：&lt;strong&gt;Pocket&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在兩個多月前，我們介紹過將文章用 RSS 訂閱集中起來的工具 &lt;a href=&#34;https://igouist.github.io/post/2020/04/feedly/&#34;&gt;Feedly&lt;/a&gt;。但是，有些時候雖然對文章挺有興趣的，但並&lt;strong&gt;不適合馬上看&lt;/strong&gt;（例如在公司或學校的時候，看到社論、科技新聞等等）；或是像我個人平常休息時逛逛一些論壇或是文檔，這時候如果遇到一些&lt;strong&gt;比較長的、主題式的文章&lt;/strong&gt;，就會想要把文章存放起來，等晚些時候再看。&lt;/p&gt;
&lt;p&gt;雖然 Feedly 也有提供 Read Later 的功能，只要勾個標籤就可以之後再到 Read Later 的頁面去觀看。但懶惰如我，就會想要把所有稍後再看的文章集中在一塊，因此必須尋找一個前述場景都共用的做法，這時我就遇上了 Pocket。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://getpocket.com/&#34;&gt;Pocket&lt;/a&gt; 是一個簡單直接的「稍後閱讀」服務，操作方便，只需要擴充套件或分享，和一段能靜下來好好閱讀的時間即可服用&lt;/strong&gt;。在開始介紹之前，有幾件事必須報告：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果你和我一樣可能變成倉鼠型玩家，看到什麼都想加到稍後閱讀，可能要當心。建議可以先閱讀一下 &lt;a href=&#34;https://www.playpcesor.com/2011/10/blog-post.html&#34;&gt;用「稍後閱讀」過濾資訊洪水的五種層次與六個方法 - 電腦玩物&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;就像在 Feedly 介紹中提到的：這類工具是用來幫助我們完成&lt;strong&gt;被動接收資訊＋主動篩選資訊&lt;/strong&gt;的，莫要忘記原則，否則真的很容易看不完看到超載，心會很累。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你是 Android 或 iOS 的使用者，由於 Pocket 有提供網頁和 APP 等平台，但本篇以電腦的操作為主，使用手機操作的朋友可以參考 &lt;a href=&#34;https://www.kocpc.com.tw/archives/266659&#34;&gt;Pocket 稍後閱讀 APP，收藏想看的文章和網頁！&lt;/a&gt; 這篇的說明。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你已經決定要尋找稍後閱讀功能的工具，可以參考 &lt;a href=&#34;https://pickydigest.com/productivity/read-it-later-bookmark-app-competition/&#34;&gt;10個稍後閱讀書籤服務大評比！Pocket、Instapaper、Diigo還有更多！&lt;/a&gt;本篇並不會提到別的工具。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (7): 介面</title>
      <link>https://igouist.github.io/post/2020/07/oo-7-interface/</link>
      <pubDate>Sun, 12 Jul 2020 23:53:07 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/oo-7-interface/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/9eGbMlk.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果說&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;繼承&lt;/a&gt;是用來表明物件「屬於什麼」；那麼介面就是用來表明物件「能做什麼」。&lt;/p&gt;
&lt;p&gt;如果說&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;封裝&lt;/a&gt;是將物件視作一個整體，是隱藏複雜度；那麼介面就是封裝精神的體現。&lt;/p&gt;
&lt;p&gt;如果說&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;多型&lt;/a&gt;是指藉著繼承後能實作不同的行為的可能性達到擴展的彈性；那麼介面就是在實作多型。&lt;/p&gt;
&lt;p&gt;介面就是這麼厲害，這麼瀟灑。介面就是我大哥，今天誰不服介面，對不起！我們不認識。&lt;/p&gt;
&lt;p&gt;介面就像是針對類別的實作、物件的行為去做規定的一個契約書，會先定義好要實作這個介面的類別所必須要有的方法，而當我們建立符合這個介面的類別時，就必須實作出所有介面中定義好方法才可以。……這樣說起來實在太繞口，總而言之介面的核心概念只有一條：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我不在乎你是誰，我只在乎你能做什麼。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;還是公司誠徵工程師的例子&#34;&gt;還是公司誠徵工程師的例子&lt;/h2&gt;
&lt;p&gt;由於介面基本上就是封裝繼承多型抽象之大雜燴，所以我們把前面&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;多型&lt;/a&gt;的小明小華例子稍微修改來用吧。也就是以公司徵人的方式去理解介面。&lt;/p&gt;
&lt;p&gt;介面就像是老闆開出來的要求列表，例如說：要會寫 C#、要會寫 SQL、要會 VB…等等，於是老闆就貼出了徵人啟示，要求新來的員工必須要有 &lt;code&gt;IProgrammer&lt;/code&gt; 寫的能力：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;IProgrammer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; WriteCSharp();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; WriteSQL();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; WriteVB();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;特別注意和前面多型的例子的不同處，&lt;strong&gt;介面只需要先定義好該做的事，裡面怎麼做不需要管；所以只需要宣告要求的方法，不需要撰寫方法本體&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;於是今天小華就又(?)來面試了，但是他其實並不會寫 C#：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Hua&lt;/span&gt; : IProgrammer
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Error: Hua 未實作 IProgrammer.WriteCSharp()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; WriteSQL() { &lt;span style=&#34;color:#75715e&#34;&gt;/* Work */&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; WriteVB() { &lt;span style=&#34;color:#75715e&#34;&gt;/* Work */&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這時候編譯器就會跳出錯誤了：很抱歉，你不符合我們 &lt;code&gt;IProgrammer&lt;/code&gt; 的規定，因為我們只喜歡訓練精英（略），請你實作完之後再來。否則你就不能掛上我們 &lt;code&gt; : IProgrammer&lt;/code&gt; 的頭銜。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (6): 抽象、覆寫</title>
      <link>https://igouist.github.io/post/2020/07/oo-6-abstract-override/</link>
      <pubDate>Sun, 12 Jul 2020 23:53:06 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/oo-6-abstract-override/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Y2gHFsr.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;備註：這邊的抽象是指程式語言中的抽象類別，而非抽象化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;抽象的概念很直接，請回想一下前面的例子就可以了：&lt;/p&gt;
&lt;p&gt;當我們在用卡牌的例子時，雖然怪獸卡跟魔法卡都繼承了 Card 這個類別，但是我們仍然能 &lt;br/&gt; &lt;code&gt;new Card()&lt;/code&gt; 來建立一張新卡牌，那…怪怪的吧，這張卡牌到底是什麼呀，空白的卡片嗎？&lt;/p&gt;
&lt;p&gt;又或是動物的例子，我們的狗跟貓都繼承了哺乳類，那我們能實例化一個哺乳類嗎？我們的狗跟鳥都是動物，那我們能實例化一個動物嗎？&lt;/p&gt;
&lt;p&gt;小明跟小華都繼承了工程師，那我們能 new 一個工程師嗎…？&lt;/p&gt;
&lt;p&gt;有些類別就是這樣，它們負責定義共通的那些特性，&lt;strong&gt;然而它們本身不應該被實體化成一個物件，這種類別我們就應該把它們標記為抽象類別&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象類別在 C# 裡用 &lt;code&gt;abstract&lt;/code&gt; 這個修飾詞來表示&lt;/strong&gt;，可以加在類別或方法上。例如 &lt;code&gt;abstract class Animal&lt;/code&gt; 就代表動物這個類別是個抽象類別，它不能被實例化。&lt;/p&gt;
&lt;p&gt;而當加在方法上時，例如 &lt;code&gt;public abstract void Eat()&lt;/code&gt; 就是代表這個進食的方法無法被叫用，只能由繼承者去重新定義這個方法。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Animal&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; color { &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Eat();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那麼繼承者們，也就是衍生類別如何去重新定義父類別的方法呢？&lt;/p&gt;
&lt;p&gt;&lt;del&gt;所謂「欲戴王冠，必 Override」&lt;/del&gt;，這時候就必須使用&lt;strong&gt;覆寫（&lt;code&gt;override&lt;/code&gt;）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;覆寫是指對於像是前述的抽象方法時，在同名的方法前加上 &lt;code&gt;override&lt;/code&gt; 關鍵字就可以讓程式知道你要覆寫這個方法（你不覆寫的話，編譯器還會生氣）。&lt;/p&gt;
&lt;p&gt;例如前述的 Eat，狗就可以用 &lt;code&gt;public override void Eat()&lt;/code&gt; 的方式去覆寫吃東西這個方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Dog&lt;/span&gt; : Animal
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; color { &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt;; } = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Black&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Eat()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;/* 嚼嚼嚼 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (5): 多型</title>
      <link>https://igouist.github.io/post/2020/07/oo-5-polymorphism/</link>
      <pubDate>Sun, 12 Jul 2020 23:53:05 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/oo-5-polymorphism/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/65N5R3A.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;多型算是比較三特性之中給人感覺比較溫和的了，不如說只要有了繼承，那麼多型的到來就是必然的。多型的定義是：不同的物件能夠做出一樣的行為，但必須由他們自己的程式碼來實作。&lt;/p&gt;
&lt;p&gt;白話一點說就是：&lt;strong&gt;一樣的事，不同做法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;多型相對是比較好理解的，畢竟每個人做同一件事的方法本來就不太一樣。例如一樣是泡奶茶，英國就正常地泡，&lt;a href=&#34;https://www.ettoday.net/news/20200707/1754177.htm&#34;&gt;美國就會用微波爐&lt;/a&gt;；一樣是肉粽，有些人就是比較愛吃油飯；到了程式的世界裡也是，即使繼承了同一個物件，實現這個行為的方式也可以不同。&lt;/p&gt;
&lt;p&gt;在此可以先推菜鳥工程師肉豬的這篇 &lt;a href=&#34;https://matthung0807.blogspot.com/2018/02/java-overload.html&#34;&gt;Java 什麼是多載(Overload), 覆寫(Override), 多型(Polymorphism)&lt;/a&gt; 中的說明。其中可以從例子看到儘管狗跟鳥都是繼承自動物這個類別，但對於「移動」這個方法，他們實作的方式並不一樣。這就是多型的範例。&lt;/p&gt;
&lt;p&gt;我個人更喜歡用職位的方式去理解多型。&lt;/p&gt;
&lt;p&gt;被繼承者就像是該職位的工作，例如說：&lt;code&gt;Programmer&lt;/code&gt; 要會寫 C#、要會寫 SQL、要會 VB…等等，於是老闆就貼出了徵人啟示，要求新來的員工必須要有 &lt;code&gt;Programmer&lt;/code&gt; 寫的能力：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Programmer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; WriteCSharp()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;/* 努力地寫 C# */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; WriteSQL()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;/* 努力地寫 SQL */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; WriteVB()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;/* 努力地寫 VB */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (4): 繼承</title>
      <link>https://igouist.github.io/post/2020/07/oo-4-inheritance/</link>
      <pubDate>Sun, 12 Jul 2020 23:53:04 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/oo-4-inheritance/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/g9FZ3WN.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接著要介紹的是繼承 aka 物件導向三大特性之王 aka 濫用榜 Ko.1 ，繼承的強大幾乎和它的惡名一樣可怕，給一個從聊聊程式的這篇 &lt;a href=&#34;https://dotblogs.com.tw/initials/2016/06/10/171117&#34;&gt;[心得整理] c# 物件導向程式 - 2.封裝、繼承、多型的三大特性&lt;/a&gt; 摘過來的例子就可以略知一二了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/IFV4xjr.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;什麼也不做，僅僅只是繼承而已，就取得了繼承對象（C# 中稱為基底類別）近乎全部的內容，真是太可怕了。在 C# 中，繼承可以取得基底類別除了 &lt;code&gt;Private&lt;/code&gt; 以外所有的內容，例如 &lt;code&gt;Protected&lt;/code&gt; 更是表明就是只給繼承使用的。&lt;/p&gt;
&lt;p&gt;由此可見，在減少重複程式碼的路上，繼承無疑達到了全新的高度。&lt;/p&gt;
&lt;p&gt;那麼繼承代表的是什麼意思呢？大多的網站都能直接說明：&lt;strong&gt;繼承是一種「is-a」的關係。當你能說出Ａ是一個Ｂ的時候，就代表你認為Ａ可以繼承自Ｂ&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最直覺的繼承例子就是&lt;strong&gt;物種的分類&lt;/strong&gt;。舉例來說，狗跟貓都是哺乳類，因此他們都可以繼承到一些哺乳類共通的特徵（例如哺乳、用肺呼吸）。藉由繼承，我們可以把這些哺乳類共有的特徵全部放在哺乳類這個物件，再由狗和貓分別去繼承哺乳類，藉此讓他們都能得到哺乳類的特徵，再進一步發展出自己的特徵和行為，甚至重新定義基底類別的方法為自己所用。因此，像大話設計模式就將繼承說明如：繼承者是對於被繼承者的一種特殊化。&lt;/p&gt;
&lt;p&gt;如此一來，當我們需要修改哺乳類的定義的時候，&lt;strong&gt;只需要修改一個地方，而繼承了哺乳類的這些物件（C# 中稱為衍生類別）全都能夠一起修改到，大大地減少了跑來跑去修改的次數，也讓程式碼的重複大幅度地減少&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;然而也因為如此，繼承最大的惡名出現了：&lt;strong&gt;繼承享受了取用基底類別內容的好處，卻也必須背負牽一髮動全身的風險&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (3): 封裝</title>
      <link>https://igouist.github.io/post/2020/07/oo-3-encapsulation/</link>
      <pubDate>Sun, 12 Jul 2020 23:53:03 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/oo-3-encapsulation/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/cc9DLDo.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;封裝包含了兩個重要的觀念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;控制物件和外部進行互動的出入口&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隱藏物件內部的細節資訊&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;強者我同事整理的&lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-3_%E5%B0%81%E8%A3%9Dencapsulation%E7%B9%BC%E6%89%BFinheritance%E8%88%87%E5%A4%9A%E5%9E%8Bpolymorphism/&#34;&gt;文章&lt;/a&gt;裡的例子就舉得不錯：當你按下鍵盤的Ａ鍵，螢幕隨即出現了Ａ，你不必知道中間發生了什麼事，你只需要知道怎麼操作和最後得到什麼就可以了。&lt;/p&gt;
&lt;p&gt;其中鍵盤提供的按鍵，就是我們對電腦進行互動的出入口；而電腦實際上做了什麼事情，也被隱藏了起來，讓我們只需要關注結果就好。&lt;/p&gt;
&lt;p&gt;此外我也看到過販賣機的例子，&lt;strong&gt;當你去販賣機買飲料，你也不需要知道裡面的構造，只要知道你選了飲料投了錢，飲料就會跑出來就行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;從上面的兩個例子，相信大家已經掌握到封裝的概念了：&lt;strong&gt;將物件視作一個整體，把內部的實作內容隱藏起來，讓使用者只需要知道怎麼使用這個物件即可。&lt;/strong&gt;（相似的思路，我們後續的&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;介面&lt;/a&gt;會再提到）&lt;/p&gt;
&lt;p&gt;如果封裝做得夠好，除了可以將程式碼整理得井井有條以外，也能讓物件內部的修改不會直接影響到使用物件的地方，達成了降耦合的目標&lt;/p&gt;
&lt;p&gt;並且也能讓物件的使用者直覺地知道如何使用物件提供的方法，如此使用者就可以專注在更高層次的抽象，而不用被物件內部的細節所干擾。&lt;/p&gt;
&lt;p&gt;最後，從上面的敘述中我們可以察覺到要實現封裝，最重要的就是：&lt;strong&gt;對外的開放程度（存取範圍）的控制&lt;/strong&gt;。或是套一句前輩的說法：&lt;strong&gt;給程式碼隱私的空間&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;補充：如果想問「什麼是耦合？」的朋友，建議可以看看這篇：&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10203659&#34;&gt;實務上的高內聚與低耦合&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;或是參照本系列後續的 &lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;內聚與耦合&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;存取範圍與存取子&#34;&gt;存取範圍與存取子&lt;/h2&gt;
&lt;p&gt;先讓我們從存取範圍開始說起吧，因為我個人慣用的是 C#，因此就介紹一下 C# 是怎麼控制存取範圍的。&lt;/p&gt;
&lt;p&gt;在 C# 之中，類別裡控制可見度是使用修飾子來定義存取範圍，也就是當我們替類別宣告欄位時常看到的 &lt;code&gt;Public&lt;/code&gt; 和 &lt;code&gt;Private&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Public&lt;/code&gt;: 這是公開的，所有人都看得到&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Private&lt;/code&gt;: 這是私有的，只有自己看得到&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了最常用的這兩個以外，還有其他的修飾子可以先知道一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Protected&lt;/code&gt;: 這是受到保護的，只有自己和繼承的孩子們看得到&lt;/li&gt;
&lt;li&gt;&lt;code&gt;internal&lt;/code&gt;: 這是內部的，只有身為同一個組件的朋友們看得到&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Protected internal&lt;/code&gt;：組合上面兩個，也就是可以給同個組件的朋友們，或是其他組件繼承的孩子們看見&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下來的部分會以最常見的 &lt;code&gt;Public&lt;/code&gt; 和 &lt;code&gt;Private&lt;/code&gt; 來繼續說明，對存取範圍的這些修飾子有興趣的朋友，可以參照 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/csharp/language-reference/keywords/accessibility-levels&#34;&gt;存取範圍層級&lt;/a&gt; 的說明。&lt;/p&gt;
&lt;p&gt;現在我們已經知道了有哪些修飾子可以用來控制存取範圍，但為什麼我們會需要宣告存取範圍的大小呢？其根本是為了&lt;strong&gt;將控制權掌握在物件本身&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;就像大話設計模式比喻的：物件就像間房子，我們不希望被看光光，可以看見的 &lt;code&gt;Public&lt;/code&gt; 就像門和窗，而不該看見的 &lt;code&gt;Private&lt;/code&gt; 則是用牆壁隱藏起來，而對於這間房子而言，門窗是可以控制的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (2): 建構式、多載</title>
      <link>https://igouist.github.io/post/2020/07/oo-2-constructor-overload/</link>
      <pubDate>Sun, 12 Jul 2020 23:53:02 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/oo-2-constructor-overload/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/naCjLay.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我就直接說了，有用前面的程式碼區塊的人，絕對執行不了。因為我們建立哥布林和戰士這兩張卡片的時候，根本就沒有給他們數值呀！&lt;/p&gt;
&lt;p&gt;雖然可以先呼叫出來再賦值…&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; goblin = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Card();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;goblin.Name = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;哥布林&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;goblin.Attack = &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;goblin.Health = &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* ...其他賦值 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這實在相當占空間，也有點奇怪。畢竟如果是阿福（狗），一出生的時候應該就確定了一些特徵才對，例如品種、血型、眼睛顏色這種。並不會出生後過一陣子，才突然決定這些東西，既然如此，我們在產生物件的時候，當然也會希望在&lt;strong&gt;建立的同時就先決定好一部份內容&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這時候我們就可以藉由&lt;strong&gt;建構式&lt;/strong&gt;的方式，在建立物件時就進行一些我們想要的操作。&lt;/p&gt;
&lt;h2 id=&#34;建構式&#34;&gt;建構式&lt;/h2&gt;
&lt;p&gt;事實上，&lt;strong&gt;當我們呼叫 &lt;code&gt;new Card()&lt;/code&gt; 的時候&lt;/strong&gt;（不覺得這個 () 很有呼叫方法的感覺嗎？）&lt;strong&gt;我們就是正在調用 Card 的建構式&lt;/strong&gt;。而當我們沒有特別去定義建構式的時候，就會直接使用內建的建構式去幫我們產生物件。&lt;/p&gt;
&lt;p&gt;現在我們替 Card 新增一個建構式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Card&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Card (&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; name, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; attack, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; health)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Name = name;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Attack = attack;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Health = health;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/* ... 其他屬性和方法 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 C# 的時候，建構式必須和類別同名，且不需要定義回傳類型。當我們有了建構式，剛剛的例子就可以改寫成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; goblin = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Card(name: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;哥布林&amp;#34;&lt;/span&gt;, attack: &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, health: &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; warrior = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Card(name: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;戰士&amp;#34;&lt;/span&gt; , attack: &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, health: &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;warrior.Hit(goblin);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;建構式也就是建立這個物件時執行的函式&lt;/strong&gt;，通常會用來進行初始化，也就是做一些建立物件必要的準備。例如傳遞必要屬性或是建構需要的其他物件、或是給予私有屬性初始值等等，例如說我們的卡牌一建立，就會需要知道它的名字和戰鬥力，這樣才有卡牌的感覺，而不該像一些 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%AD%A6%E8%97%A4%E9%81%8A%E6%88%B2&#34;&gt;壞決鬥者&lt;/a&gt; 邊打牌邊偷偷印卡。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (1): 類別、物件</title>
      <link>https://igouist.github.io/post/2020/07/oo-1-class-object/</link>
      <pubDate>Sun, 12 Jul 2020 23:53:01 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/oo-1-class-object/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/TIEIXm5.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;直覺上你當然知道什麼是物件；物件就在你的身邊。&lt;/p&gt;
&lt;p&gt;汽車、iPhone、收音機、吐司機、廚房用具等等，你說得出來的都是。&lt;/p&gt;
&lt;p&gt;　　——《深入淺出學會編寫程式》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;什麼是物件？一切都是物件。&lt;/p&gt;
&lt;p&gt;物件導向試圖讓抽象的程式碼，更貼近於我們的實際生活，其認為一切是由各式各樣的人事物互動所組成的，因此有了物件這個共通、最基本的概念。&lt;/p&gt;
&lt;p&gt;假設現實世界存在一頭狗，叫做阿福。而我們想要在虛擬世界裡表達「有一隻叫做阿福的狗」這件事&lt;/p&gt;
&lt;p&gt;這時候就要在系統裡有一個能代表「阿福（狗）」的東西存在，也就是「阿福」這個物件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;關於「把現實世界的物件，抽象化成程式世界裡的物件」的邏輯，可以參考 &lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10201905&#34;&gt;一個語言如果不改變你的思考方式，就不值得學？談程式語言的本質&lt;/a&gt; 這篇，尤其是選擇保留哪些資訊的部份我認為描述得很好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;現在我們知道，&lt;strong&gt;物件就是用來在虛擬世界中代表「某個特定的東西」&lt;/strong&gt;，例如說叫做阿福的狗就是一個物件，阿福今天晚上要吃的飼料罐也是一個物件。&lt;/p&gt;
&lt;p&gt;理解物件的概念是相當直覺且迅速的，畢竟你我身邊有著數不清的東西，它們都是一件一件的物件，但這樣的理解還不夠明確。&lt;/p&gt;
&lt;p&gt;就像前文所引的 &lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10201905&#34;&gt;談程式語言的本質&lt;/a&gt; 文中所提到的，在抽象化的同時我們必然要選擇保留哪些資訊。&lt;/p&gt;
&lt;p&gt;例如說阿福這隻狗，是一個物件；飼料罐也是一個物件&lt;/p&gt;
&lt;p&gt;而這些物件之間還會彼此互動，例如說阿福是一隻狗，而我們觀察到狗都有吃東西這個&lt;strong&gt;動作&lt;/strong&gt;，例如「阿福吃了飼料」&lt;/p&gt;
&lt;p&gt;同時物件也會有一些專屬於它的&lt;strong&gt;特徵&lt;/strong&gt;，例如說阿福是黑色的，我們就知道狗有毛色的差別。&lt;/p&gt;
&lt;p&gt;那麼我們要怎麼表達「阿福」作為一隻「狗」擁有的那些動作和特徵呢？狗的毛色？狗可以吃飼料？&lt;/p&gt;
&lt;p&gt;我們需要選擇怎麼去描述「狗」－－也就是阿福這隻狗，被我們抽象化後的樣子，我們需要將它用程式碼的方式定義出來。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;這時候我們就會需要類別，來定義出我們觀察到同一類的物件該有哪些特徵和動作，也就是我們替物件「分門別類」後、篩選出特定資訊的抽象化結果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;延續前面的例子，假設今天我們從阿福身上觀察到進食跟毛色兩個狗的重要資訊，我們就可以建立類別 Dog：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Dog&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; color;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Eat(IFood food) { &lt;span style=&#34;color:#75715e&#34;&gt;/* 進食與消化之類的 */&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;藉由我們定義的類別，就可以從類別中實例化（＝建立）出物件。&lt;/p&gt;
&lt;p&gt;也就是說，現在我們終於可以用「狗」這個類別，來表達出我們需要的「阿福」了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Dog afu = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Dog(); &lt;span style=&#34;color:#75715e&#34;&gt;// 阿福是一隻狗&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Console.Write(afu.Color); &lt;span style=&#34;color:#75715e&#34;&gt;// 阿福是黑色的&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;afu.Eat(food); &lt;span style=&#34;color:#75715e&#34;&gt;// 阿福會吃食物&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (0): 前言</title>
      <link>https://igouist.github.io/post/2020/07/oo-0-object-oriented/</link>
      <pubDate>Sun, 12 Jul 2020 23:53:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/oo-0-object-oriented/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/9UtcyAf.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在訂便當告一段落之後，其實就已經和同事約好要來整理公司新訓的筆記。但儘管已經到職快一年了，有些工具已經在專案碰過好幾次。但遇到需要跟朋友討論，或是聽前輩說明觀念的時候，還是不自主地會想「我真的懂嗎？」故一直是挺畏懼的。&lt;/p&gt;
&lt;p&gt;但幸虧同事的鼓勵和以身作則，最終還是開啟了這個新系列，決定直接開坑把當初前輩新訓指導過的部分整理下來，也算是讓自己能趁著這機會好好複習一番，把自己的想法跟心得記錄下來。&lt;/p&gt;
&lt;p&gt;另外，如果你是真心希望弄懂物件導向的朋友，這邊推薦&lt;a href=&#34;https://www.tenlong.com.tw/products/9789866761799&#34;&gt;《大話設計模式》&lt;/a&gt;的附錄，內容對物件導向的介紹清晰易懂且循序漸進，非常適合作為了解物件導向的起頭。&lt;/p&gt;
&lt;p&gt;本篇的段落將會分成以下幾個部份，由於只是筆記一下，因此會附上一些知識點的參考資料，看見的時候可以先行閱讀；末尾也會附上有關的參考資料及文章，對於這類概念性的東西，一向是推薦多方閱讀以增強理解，就像保哥寫的：「&lt;strong&gt;如果你問 100 個人這個問題，可能會得到 200 個答案，所以你一定要有自己獨到、有自信、精闢的見解或描述方式&lt;/strong&gt;。」如果有寫得不錯的文章想推薦給我，或是有地方需要補充和指證，還請不吝指教。共勉之。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>AutoMapper —— 類別轉換超省力</title>
      <link>https://igouist.github.io/post/2020/07/automapper/</link>
      <pubDate>Sun, 05 Jul 2020 23:40:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/automapper/</guid>
      <description>&lt;p&gt;類別間的轉換幾乎是每個專案每個工程師都會碰到的動作，舉凡是分層架構每層之間的轉換，如 Dto 轉換成 ViewModel；或是接收到資料要塞進自定義的類別時也需要進行轉換。但&lt;strong&gt;在遠古時代，當我們要把一個類別的資料倒進另一個類別時，總免不了一番折騰&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如一個卡片對戰遊戲的資料庫，光是要先把卡片資料讀取出來就需要：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/c81Hx5I.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;有些時候也會看見用 Foreach 然後逐一傳值的場景，或是各種差不多的變種情況。同樣的是，光是將一個簡單的卡片資訊轉換成 ViewModel，就花了一大段在做對映的處理。這個過程本身枯燥乏味又占空間，更可怕的是，&lt;strong&gt;如果有個陳年資料表，動不動就上百個欄位，那這個轉換過程的恐怖程度可想而知&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;幸好！天無絕人之路，這種時候就是本日的主角 —— AutoMapper 出場的時候了。&lt;/p&gt;
&lt;p&gt;當 AutoMapper 一出手，轉換的過程瞬間就變成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/KxHAKpi.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;是不是精簡很多呢？接著就讓我們來看看怎麼開始使用吧！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Electron.net —— 把網頁包成桌面應用吧</title>
      <link>https://igouist.github.io/post/2020/06/electron-net/</link>
      <pubDate>Sun, 28 Jun 2020 19:41:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/06/electron-net/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/ElectronNET/Electron.NET/raw/master/assets/images/electron.net-logo.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;因緣際會下想要弄出一些單機小工具來跑，這時候正巧接觸到 &lt;a href=&#34;https://github.com/ElectronNET/Electron.NET&#34;&gt;Electron.net&lt;/a&gt; 這個神器，特別紀錄一下以免忘記。這是 &lt;a href=&#34;https://www.electronjs.org/&#34;&gt;Electron&lt;/a&gt; 搭配 .net Core 的框架， &lt;strong&gt;Electron 是用 Chromium 和 Node.js 將網頁封裝成桌面應用程式&lt;/strong&gt;，像是 Visual Studio Code、Slack 也都有使用到 Electron。而 &lt;a href=&#34;https://github.com/ElectronNET/Electron.NET&#34;&gt;Electron.net&lt;/a&gt; 顧名思義就是 .net 用的 Electron 框架囉。&lt;/p&gt;
&lt;p&gt;這邊記錄一下自己嘗試時載入套件和建置的流程，主要參考自黑大的 &lt;a href=&#34;https://blog.darkthread.net/blog/electron-net/&#34;&gt;用 ASP.NET Core 寫桌面 GUI 應用程式 - Electron.NET&lt;/a&gt; 和 &lt;a href=&#34;https://blog.darkthread.net/blog/electron-api-brief/&#34;&gt;Electron.NET API 快速巡覽&lt;/a&gt; 這兩篇文章，以及官方的 &lt;a href=&#34;https://github.com/ElectronNET/electron.net-api-demos&#34;&gt;API DEMO&lt;/a&gt;，特此感謝。&lt;/p&gt;
&lt;p&gt;本篇小節：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%89%E8%A3%9D%E5%A5%97%E4%BB%B6%E5%8F%8A%E7%92%B0%E5%A2%83%E8%A8%AD%E7%BD%AE&#34;&gt;安裝套件及環境設置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%8D%E5%BE%8C%E7%AB%AF%E5%82%B3%E5%80%BC-ipcmain-ipcrenderer&#34;&gt;前後端傳值 (IpcMain, IpcRenderer)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%89%93%E5%8C%85%E6%88%90%E5%9F%B7%E8%A1%8C%E6%AA%94exe&#34;&gt;打包成執行檔（.exe）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BE%8C%E8%A8%98&#34;&gt;後記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99&#34;&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>讀《黑馬思維》</title>
      <link>https://igouist.github.io/post/2020/06/darkhorse/</link>
      <pubDate>Sat, 20 Jun 2020 00:22:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/06/darkhorse/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://kbimages1-a.akamaihd.net/7b5f2f3f-4c9e-45f9-b6e9-a678e7761be5/353/569/90/False/jR89tVf-UjOvjOiRwLSBjw.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每個人都是天才。但如果你用爬樹能力來斷定一條魚有多少才幹，牠整個人生都會相信自己愚蠢不堪。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這邊整理一下這陣子讀&lt;a href=&#34;https://www.books.com.tw/products/0010819494&#34;&gt;《黑馬思維》&lt;/a&gt;這本書的筆記，以及一些個人心得。直接破題說，我個人覺得值得一讀。&lt;/p&gt;
&lt;p&gt;本書的目的是研究那些橫空出世的&lt;strong&gt;黑馬&lt;/strong&gt;。但在研究少數的黑馬之前，就必須先說明何謂多數，所以本書前段著重在介紹什麼是&lt;strong&gt;標準化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;從工業革命至今，為了能大量生產、品質穩定、降低成本、最終達到「&lt;strong&gt;一致、大量、簡單、有效&lt;/strong&gt;」的效果，最直接且有效的做法就是制定流程和規定。不管是製造業，或者是教育，甚至是人生，群眾總是試圖找出一個固定的流程，鋪設一條筆直的道路，並且告訴大家：&lt;strong&gt;只要遵循這個路線，就能夠達到成功&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;雖然比起更加以前的階級制而言，標準化的做法的確更加公平了。然而為了達到標準一致，勢必得要重視群體、忽視個人。標準化的做法將所有人一視同仁，如同工廠的機器，或是程式的流程，&lt;strong&gt;認為設定好的輸入，經過了制定好的流程，就該有期待的產出&lt;/strong&gt;。為了達到標準，因此無法認為每個人是特別的，甚至那些過於特別的，反而對標準化而言是個麻煩。&lt;/p&gt;
&lt;p&gt;標準化的成功很直接：跟別人做一樣的事，但做得更好，就是最佳路線。&lt;/p&gt;
&lt;p&gt;但有一些人，並不遵循標準化建議的路線，仍然取得了成功，他們就是黑馬。在個人化崛起的這個時代，媒體、醫療、廣告，甚至教育都開始有了量身打造的選項，隨處可見精準投放，個人菜單，標準化漸漸被個人化取代，於是作者們提出了疑問：什麼是「&lt;strong&gt;個人化的成功&lt;/strong&gt;」呢？他們開始研究這些黑馬。&lt;/p&gt;
&lt;p&gt;直接結論：黑馬們的個性、背景和領域都不大一樣，然而他們有一部分是相似的。有些人說：我認為自己做的事情是值得的，有些人說他感覺到熱忱，也有人說這是他的天職。&lt;strong&gt;黑馬的共通點在於：他們都並非為了想要成功或是達到目標才努力前進，而是靠著追求自我實現而成就卓越&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Chase Excellence, Success will follow. - 3 Idiots&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而對於這些黑馬如何追求自我實現，如何走出和標準化不同的路。本書提出以下四個重點：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;知道你的微動力&lt;/li&gt;
&lt;li&gt;清楚你的選擇&lt;/li&gt;
&lt;li&gt;了解你的策略&lt;/li&gt;
&lt;li&gt;忽略你的目的地&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>C#: 位元旗標 (Bit flag) 與列舉</title>
      <link>https://igouist.github.io/post/2020/06/bit-flags-and-enum/</link>
      <pubDate>Sun, 14 Jun 2020 21:27:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/06/bit-flags-and-enum/</guid>
      <description>&lt;p&gt;前陣子碰到個資料表儲存方式，因為這種位元運算的方式也常用在權限管理等地方，這邊就順手紀錄一下。&lt;/p&gt;
&lt;p&gt;平常遇到二元的情形（例如 開／關、有／沒有），我們會直接宣告個 Boolean 來處理。但這次遇到的是同時有多個「有／沒有」的狀況，但我遇到的程式碼並沒有分成多個 Bool 去做處理，而是直接儲存成一個數值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由於「有／沒有」只佔據一個位元，那麼將多個狀況按照位元順序排列的話，就只需要一個數字就可以紀錄或傳遞給其他系統了&lt;/strong&gt;。例如最常見的用處是在權限系統，若有「讀」、「寫」、「執行」等權限，那麼我們按照這個順序去排列，當 &lt;code&gt;讀＝可、寫＝不可、執行＝可&lt;/code&gt; 的時候，就記做 &lt;code&gt;101&lt;/code&gt; = &lt;code&gt;5&lt;/code&gt;。這種直接用一組位元表示狀態的方式就叫做&lt;strong&gt;位元旗標（Bit flag）&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1 讀   = 可
0 寫   = 不可
1 執行 = 可

/* 橫放 */
=&amp;gt; 101 (2進位) 
=&amp;gt; 5 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;假使某天老闆靈光一現，決定接下來的新人員工都要記錄他們會的程式語言，並且他們報到的時候就會發一張公司列好的程式語言清單請他們勾選。&lt;/p&gt;
&lt;h2 id=&#34;enum--flags&#34;&gt;Enum &amp;amp; Flags&lt;/h2&gt;
&lt;p&gt;在 C# 中已經有方便的工具可以處理數字列表，我們可以建立一個叫做 SkillEnum 的&lt;strong&gt;列舉（Enum）&lt;/strong&gt;，並且按照上面說明的，將老闆提到的每個技能各自用一個位元來表示。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[Flags]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; SkillEnum
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    C = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,     &lt;span style=&#34;color:#75715e&#34;&gt;// 0001&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    PHP = &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,   &lt;span style=&#34;color:#75715e&#34;&gt;// 0010&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    SQL = &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;,   &lt;span style=&#34;color:#75715e&#34;&gt;// 0100&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Java = &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;,  &lt;span style=&#34;color:#75715e&#34;&gt;// 1000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;註：&lt;code&gt;[Flags]&lt;/code&gt;的標籤是指 C# 專門提供給位元旗標使用的 Enum，請參見 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/api/system.flagsattribute?view=netcore-3.1&#34;&gt;FlagsAttribute&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;只要在 enum 上加上 Flags 的屬性，除了自動按照 2 的次元增加以外，在使用 ToString() 也能更方便看見旗標內容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有了這個列舉之後，我們就可以&lt;strong&gt;表達不同排列組合的狀況&lt;/strong&gt;了。例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;* C: C
* P: PHP
* S: SQL
* J: Java
===========
J S P C
0 0 0 0 =&amp;gt; 什麼都不會
0 0 0 1 =&amp;gt; 只會 C
0 0 1 1 =&amp;gt; 同時會 C 和 PHP
1 0 1 0 =&amp;gt; 同時 PHP 和 Java
1 1 1 1 =&amp;gt; 全部都會
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>WakaTime —— 我 Coding 了多久？</title>
      <link>https://igouist.github.io/post/2020/06/wakatime/</link>
      <pubDate>Sun, 07 Jun 2020 22:10:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/06/wakatime/</guid>
      <description>&lt;p&gt;這一周又是 &lt;del&gt;偷懶週&lt;/del&gt; 繁忙週，因此就跟大家分享一個有趣的網站：&lt;a href=&#34;https://wakatime.com/&#34;&gt;WakaTime&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;WakaTime 能夠幫你自動記錄寫程式的時間、常用語言及專案，只要簡單地在常用的 IDE 設定好擴充套件就可以達成。 WakaTime 支援的 IDE 可以參閱 &lt;a href=&#34;https://wakatime.com/plugins&#34;&gt;WakaTime - Plugin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;註冊相當簡單，此處就不贅述。稍微介紹一下儀表板的各區塊的功能：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/wd1LZLr.png&#34; alt=&#34;&#34;&gt;
左上會有最近的專案及花費時間，每個色塊都是一個專案，滑鼠移上去就會顯示專案名稱。&lt;/p&gt;
&lt;p&gt;點擊其中一天更會顯示當天的時間軸，可說是無所遁形。至於它判斷專案名稱的方法是看你編輯的檔案所在的資料夾名稱。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>我要訂便當 (5): Heroku 填坑小記</title>
      <link>https://igouist.github.io/post/2020/05/bandon-5-heroku-debug/</link>
      <pubDate>Sun, 31 May 2020 23:24:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/05/bandon-5-heroku-debug/</guid>
      <description>&lt;p&gt;在上一集的 &lt;a href=&#34;https://igouist.github.io/post/2020/05/bandon-4-heroku/&#34;&gt;將 Python 腳本部署上 Heroku&lt;/a&gt; 中，記錄了將 Python 腳本放上 Heroku 的過程，但仍然沒有將我們的 &lt;a href=&#34;https://igouist.github.io/tags/bandon/&#34;&gt;訂便當小幫手&lt;/a&gt; 給放上去。之前有稍微提到是因為過程中遇到了一些問題，最後決定將這些問題和找到的前人解決文記錄在這一篇，將來再遇到的時候就可以參考。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SQLite 要改成用 PostgreSQL&lt;/li&gt;
&lt;li&gt;在 Heroku 上執行 Selenium&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;一sqlite-要改成用-postgresql&#34;&gt;一、SQLite 要改成用 PostgreSQL&lt;/h2&gt;
&lt;p&gt;在之前的 &lt;a href=&#34;https://igouist.github.io/post/2020/03/bandon-2-sqlite/&#34;&gt;我要訂便當(2) —— 用 Python + Sqlite 儲存訂單&lt;/a&gt; 中，為了方便及簡單性，選擇了較輕便的 SQLite 來儲存我們爬回來的訂單資訊。然而，SQLite 將資料儲存在小檔案以便於攜帶的做法，在 Heroku 上將會遭遇像是各個 dyno 的資料不同步等許多問題，因此 Heroku 是不建議使用 SQLite 的。&lt;/p&gt;
&lt;p&gt;在 Heroku 的開發文件中的 &lt;a href=&#34;https://devcenter.heroku.com/articles/sqlite3&#34;&gt;SQLite on Heroku&lt;/a&gt; 有關於這部分的詳細說明，並直接提到「&lt;em&gt;If you were to use SQLite on Heroku, you would lose your entire database at least once every 24 hours.&lt;/em&gt;」同時，官方也提供了他們的建議：&lt;strong&gt;PostgreSQL&lt;/strong&gt;。相較於輕便但只能同時單一寫入而且還會在 dyno 炸掉的 SQLite，PostgreSQL 的完整性更符合 Heroku 對服務的要求。&lt;/p&gt;
&lt;p&gt;關於在 Heroku 上使用 PostgreSQL 的做法，這篇 &lt;a href=&#34;https://swf.com.tw/?p=1327&#34;&gt;佈署 Python Flask 網站留言板應用程式到 Heroku + PostgreSQL 資料庫系統&lt;/a&gt; 說明得相當詳細。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Json View —— 用 Chrome 打開 Json 的正確方式</title>
      <link>https://igouist.github.io/post/2020/05/jsonview/</link>
      <pubDate>Sun, 17 May 2020 15:39:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/05/jsonview/</guid>
      <description>&lt;p&gt;本來這週已經沒梗了，不過同學來問了個接 API 的問題還附了照片，頓時決定順手推一下好用的瀏覽器插件：&lt;a href=&#34;https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc&#34;&gt;Json View&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Json View 是一款 Chrome 的擴充套件，能幫忙把 Json 格式的資料重新排版，保護妳我的眼睛。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;備註：關於 JSON 可以參閱 &lt;a href=&#34;http://miniaspreading.github.io/guide-to-json/1-what-is-json.html&#34;&gt;JSON精要讀書紀錄&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;照慣例來張效果圖鎮樓
&lt;img src=&#34;https://i.imgur.com/VYg1Siy.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Carbon —— 把程式碼片段截成有質感的圖片吧</title>
      <link>https://igouist.github.io/post/2020/05/carbon/</link>
      <pubDate>Sun, 10 May 2020 23:57:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/05/carbon/</guid>
      <description>&lt;p&gt;開始挑戰每週寫文之後，發現最大的敵人根本不是寫文這件事，而是自己的惰性啊。像這次母親節假期過太爽，差點兒就忘記發文…… 所以這週就還是 &lt;del&gt;偷懶&lt;/del&gt; 工具介紹囉。&lt;/p&gt;
&lt;p&gt;今天要分享的是 &lt;a href=&#34;https://carbon.now.sh/&#34;&gt;Carbon&lt;/a&gt; 這個工具，它能夠&lt;strong&gt;將貼上的程式碼輸出成圖片，並且支援程式碼上色&lt;/strong&gt;，還可以自選字型、背景色等等，產出的圖可以說相當有質感。&lt;/p&gt;
&lt;p&gt;當傳送圖片比較快或排版比較好的場合（例如Line, Facebook..），或是在部落格和文件中想直接放漂亮圖片，以及&lt;strong&gt;需要示範給對方看可是又不想要對方直接複製貼上&lt;/strong&gt;的時候可謂是相當實用。&lt;/p&gt;
&lt;p&gt;先來一張成果圖鎮樓
&lt;img src=&#34;https://i.imgur.com/jM07HAC.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>我要訂便當 (4): 將 Python 腳本部署上 Heroku</title>
      <link>https://igouist.github.io/post/2020/05/bandon-4-heroku/</link>
      <pubDate>Sun, 03 May 2020 23:55:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/05/bandon-4-heroku/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;目標：紀錄一下如何將 Python 寫好的東西丟上 &lt;a href=&#34;https://www.heroku.com/home&#34;&gt;Heroku&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在先前的 &lt;a href=&#34;https://igouist.github.io/post/2020/03/bandon-1-selenium/&#34;&gt;訂便當系列&lt;/a&gt; 中已經建立了一個替我們去爬便當網並通知我們的小工具，但還存在一個相當大的問題：要在哪跑？總不能就只放在家裡電腦有開機就跑、沒開機就算了吧？因此我們必須找個主機把它放上去。而在上一篇做 Line Notify 的時候所參考的 &lt;a href=&#34;https://www.evanlin.com/go-line-notify/&#34;&gt;如何快速建置一個 LINE Notify 的服務&lt;/a&gt; 中提到了將服務放上 Heroku 的部分，因此馬上嘗試看看。&lt;/p&gt;
&lt;p&gt;結果過程中碰了不少壁，因此特地紀錄下來。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Heroku 是一個雲端平台&lt;/strong&gt;，讓使用者可以把服務丟上去跑，同時最讚的部分是，免費用戶就提供了每月 450 小時可以使用（但有每半小時會進入休眠的限制），詳情可以參閱 &lt;a href=&#34;https://www.heroku.com/pricing&#34;&gt;Heroku 的計費頁面&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本系列最後一階段的目標就是要將訂便當爬蟲整套丟上去雲端上運行，達到被動接收通知的效果。但由於訂便當爬蟲還牽涉到用 Selenium 開瀏覽器互動，以及使用 Sqlite 儲存的部分，轉移到 Heroku 的環境上還需要進行一些調整。因此&lt;strong&gt;這一階段將會分成兩篇（或以上）文章進行，上篇會先簡單地紀錄如何將服務放上 Heroku，下篇開始則著重於紀錄將訂便當系統放上 Heroku 時遇到的問題和解決過程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本篇主要的參考來源來自於 &lt;a href=&#34;https://medium.com/enjoy-life-enjoy-coding/heroku-%E6%90%AD%E9%85%8D-git-%E5%9C%A8-heroku-%E4%B8%8A%E9%83%A8%E7%BD%B2%E7%B6%B2%E7%AB%99%E7%9A%84%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E5%AD%B8-bf4fd6f998b8&#34;&gt;搭配 Git 在 Heroku 上部署網站的手把手教學&lt;/a&gt;、&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10196129&#34;&gt;發布網站到 Heroku&lt;/a&gt; 以及 &lt;a href=&#34;https://railsbook.tw/chapters/32-deployment-with-heroku.html&#34;&gt;網站部署（使用 Heroku）&lt;/a&gt; 這幾篇，其餘參考將附於文末，感謝各位前人大大留下的優質文。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CSS: 變數 (Variables)</title>
      <link>https://igouist.github.io/post/2020/04/css-variables/</link>
      <pubDate>Sun, 26 Apr 2020 23:09:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/04/css-variables/</guid>
      <description>&lt;p&gt;這禮拜忙了些，只好先偷懶打張安牌。這邊就記一下前陣子同學弄主題切換時用到的 CSS 變數（Variables）功能用法&lt;/p&gt;
&lt;p&gt;原本使用 CSS 時就會有許多重複使用的部分，例如說網站的主色彩和副色彩等，然而在管理上，或是要修改的時候就會很麻煩，通常都要另外借助工具來處理。然而 CSS 其實原生就有變數可以使用，大大地增加了改動時的方便性。用法上也相當簡單。&lt;/p&gt;
&lt;p&gt;在 CSS 宣告變數時，建議放在 &lt;code&gt;:root&lt;/code&gt; 裡，並使用 &lt;code&gt;--變數名&lt;/code&gt; 的方式宣告。例如&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-css&#34; data-lang=&#34;css&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;:&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    --color: &lt;span style=&#34;color:#ae81ff&#34;&gt;#000000&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而使用的時候只要 &lt;code&gt;var(--變數名)&lt;/code&gt; 就可以囉。例如&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-css&#34; data-lang=&#34;css&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;background&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;var&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;color&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Feedly —— 用 RSS 訂閱來主動篩選資訊吧</title>
      <link>https://igouist.github.io/post/2020/04/feedly/</link>
      <pubDate>Sun, 19 Apr 2020 23:56:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/04/feedly/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;「你看，我認為人的腦子本來就像一間空空的小閣樓，應該有選擇地把傢俱放進去，傻瓜才會把他見到的所有破爛一古腦兒的裝進去。這樣一來，那些對他有用的知識反而被擠了出來；或者，最多不過是和許多其他的東西摻雜在一起，在取用的時候也會很困難。所以一個會工作的人，在要把一些東西裝進他那間小閣樓似的頭腦中的時候，確實是非常小心謹慎的。」&lt;/p&gt;
&lt;p&gt;　　——《福爾摩斯探案記：血字的研究》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在咱們寫程式這行中，幾乎所有人都必須要在網路上找尋資料；而就算非這一行的朋友們，也會在網路上多方攝取資源。隨著時間的累積，都會開始有一份列表，諸如一些崇拜的大神或是固定追蹤的部落格，又或是文風比較喜歡、素質感覺比較高的新聞或評論等等。&lt;/p&gt;
&lt;p&gt;然而列表越來越長，就算加到書籤也總不能沒事就逛一大圈，也常常逛到不知道到底在幹嘛囧。因此把多個資訊來源集中起來整理就成了面對資訊爆炸的關鍵一步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://feedly.com/&#34;&gt;Feedly&lt;/a&gt; 就是一個協助資訊來源管理的工具，可以很方便地把不同訂閱來源整理在一起&lt;/strong&gt;，例如你可能追隨了五六個大神的部落格，只要這些大神都有提供 RSS 訂閱，Feedly 就會將大神更新的文章收集到平台上。&lt;/p&gt;
&lt;p&gt;每天只需要上去 Feedly 看一下有沒有哪位大神更新，就可以化主動為被動，穩定接收新資訊。並且由於集中管理的關係，也可以檢視是否有哪個資料來源，如新聞網站，實際上更新的文章並不太合你胃口，或是哪些已經停止更新了，就可以進行剪枝的動作，建立自己的篩選機制。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>EPPlus —— 輕鬆處理 Excel</title>
      <link>https://igouist.github.io/post/2020/04/epplus/</link>
      <pubDate>Sun, 12 Apr 2020 10:19:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/04/epplus/</guid>
      <description>&lt;p&gt;前陣子工作需要匯出一些資料表，因此用到了 &lt;a href=&#34;https://github.com/EPPlusSoftware/EPPlus&#34;&gt;EPPlus&lt;/a&gt; 這套工具來把資料匯出成 Excel。由於這需求似乎會挺常遇到的，決定記一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目標：稍微紀錄一下這次碰到 EPPlus 的用法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;EPPlus 是在 .NET Framework 或 .NET Core 上提供控制 Excel 的元件，操作簡單好懂&lt;/strong&gt;，當有需要在網頁上讓人將表格資料下載成 Excel 的功能時就可以試著使用。常常一併被提起的還有另一個一樣老牌的相似功能元件 NPOI，不過我個人只用過 EPPlus 便不再贅述。關於更詳細的介紹，可以參閱黑暗執行緒的這篇 &lt;a href=&#34;https://blog.darkthread.net/blog/epplus/&#34;&gt;比 NPOI 更討喜的 Excel 元件 - EPPlus!&lt;/a&gt;，儘管是有些久遠的文章但仍能迅速了解 EEplus 的賣點和差異。&lt;/p&gt;
&lt;p&gt;我在使用 EPPlus 時主要的參考來自於 &lt;a href=&#34;https://github.com/EPPlusSoftware/EPPlus/wiki&#34;&gt;EPPlus 的 Wiki&lt;/a&gt;，每個功能都有說明及範例，同時也有範例專案可以下載，寫得相當詳細。另外還找了如 &lt;a href=&#34;https://www.cnblogs.com/rumeng/p/3785748.html&#34;&gt;導出 Excel 之 Epplus 使用教程 - Wico&amp;rsquo;s Blog&lt;/a&gt;、&lt;a href=&#34;https://dotblogs.com.tw/malonestudyrecord/2018/03/21/103124&#34;&gt;使用 EPPLUS 操控 Excel - 碼農的學習日誌&lt;/a&gt; 這些有逐步說明的文章，在此感謝。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>我要訂便當 (3): 用 Python &#43; Line Notify 傳送通知</title>
      <link>https://igouist.github.io/post/2020/04/bandon-3-line-notify/</link>
      <pubDate>Sun, 05 Apr 2020 19:36:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/04/bandon-3-line-notify/</guid>
      <description>&lt;p&gt;前情提要：&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&#34;https://igouist.github.io/post/2020/03/bandon-1-selenium/&#34;&gt;我要訂便當(1) —— 用 Python + Selenium 控制瀏覽器取得訂單&lt;/a&gt; 中，我們嘗試了用 Selenium 控制瀏覽器去取回訂便當團購網的訂單內容&lt;/p&gt;
&lt;p&gt;而在 &lt;a href=&#34;https://igouist.github.io/post/2020/03/bandon-2-sqlite/&#34;&gt;我要訂便當(2) —— 用 Python + Sqlite 儲存訂單&lt;/a&gt; 中，我們使用 Sqlite 達到將訂單儲存起來以判斷是否有新的訂單，因此這邊的下一步就是需要進行通知。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目標：&lt;strong&gt;使用 Line Notify，當有新訂單的時候就發送通知&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://notify-bot.line.me/zh_TW/&#34;&gt;Line Notify&lt;/a&gt;&lt;/strong&gt; 是 Line 上面的通知服務，不像 Line@ 一樣可以有品牌有互動等等，Line Notify 純粹就是訊息通知；但同時對比 Line@ 最近吵得沸沸揚揚的收費和大量跳槽，Line Notify 則是免費的服務。&lt;/p&gt;
&lt;p&gt;Line Notify 的運作上分為發送訊息和接受訊息。當我們使用 Line 帳號申請 Line Notify 的服務後就可以得到一個 Access Token，藉由這組 Access Token 就能夠讓我們的程式和服務去發送通知。這些通知會由一個叫做 LINE Notify 的官方帳號發送給有訂閱這個通知的人。&lt;/p&gt;
&lt;p&gt;基於這個工作原理，像是需要經營品牌的服務就不太適合 Line Notify，反之像是&lt;strong&gt;伺服器斷線、設備超載等等這些個人通知性質比較高的服務就很適合使用 Line Notify&lt;/strong&gt;。這點從 &lt;a href=&#34;https://notify-bot.line.me/zh_TW/&#34;&gt;Line Notify 網頁&lt;/a&gt; 下方的示意圖也可以略知一二。&lt;/p&gt;
&lt;p&gt;當然像我們這次的需求是「如果有新的團購便當 就 通知我」，相當符合使用場景，因此這邊就嘗試使用看看並記錄下來。&lt;/p&gt;
&lt;p&gt;如果需要更多 Line Notify 的說明，保哥的這篇 &lt;a href=&#34;https://blog.miniasp.com/post/2020/02/17/Go-Through-LINE-Notify-Without-Any-Code&#34;&gt;上手 LINE Notify 不求人：一行代碼都不用寫的推播通知方法&lt;/a&gt; 介紹的更為完整，推薦參閱。當然，也可以閱讀 &lt;a href=&#34;https://notify-bot.line.me/doc/en/&#34;&gt;Line Notify 官方文件&lt;/a&gt;。那麼，我們開始吧～&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Visual studio 環境設定 —— 字型、套件、快捷鍵</title>
      <link>https://igouist.github.io/post/2020/03/visualstudio/</link>
      <pubDate>Sat, 28 Mar 2020 00:11:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/03/visualstudio/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;目標：整理一下自己用的&lt;strong&gt;字型、插件和快捷鍵&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天在工作時寫到一半突然藍屏，重開機之後俺的地表最強編譯器 Visual Studio 整個就開始鬧脾氣，打開專案整排都是 Error，連 System.Object 都找不到，差點往生。還好用了修復功能之後一切恢復正常，但是載入的插件和一些個人設定就這樣重置了……&lt;/p&gt;
&lt;p&gt;為了之後可能還會遇到相同的事情，這邊就先將平常的 Visual Studio 環境用到的設定做一份紀錄，之後遇到新插件或是什麼功能也可以回來更新這篇文，如此一來下次又被洗白的時候就可以回來參考了。&lt;/p&gt;
&lt;p&gt;這邊主要會記錄三個部分，並隨時可能更新。主要是字型、使用的插件以及常用的快捷鍵。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;不過我的 Visual Studio 也被洗白了所以這篇會跟著找回失落插件的歷程慢慢補上QQ&lt;/del&gt;&lt;/p&gt;
&lt;h2 id=&#34;字型&#34;&gt;字型&lt;/h2&gt;
&lt;p&gt;字型部分必定、絕對要使用&lt;strong&gt;等寬字型&lt;/strong&gt;，這是必要的前提也是絕對的共識，畢竟你不會希望有什麼神秘空白，或是推個版就排版大炸裂之類的。&lt;/p&gt;
&lt;p&gt;推薦先參閱 &lt;a href=&#34;https://kevintsengtw.blogspot.com/2014/08/blog-post.html&#34;&gt;換個好字型讓程式開發有效率&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(2021/1/27) 補充：字型也可以看 &lt;a href=&#34;https://devfonts.gafi.dev/&#34;&gt;devfonts&lt;/a&gt; 。裡面直接放了超多 Coding 常用字型，也可以貼上 Code 直接進行比較，相當貼心。想逛一下挑個順眼字型的朋友直接試試唄。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;consolas&#34;&gt;Consolas&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/az9u0B3.png&#34; alt=&#34;&#34;&gt;
內建就有的字體，個人認為在不想另外下載字體的時候是相當優質的選擇。&lt;/p&gt;
&lt;p&gt;看起來粗粗圓圓的很放鬆。&lt;/p&gt;
&lt;h3 id=&#34;firacode&#34;&gt;FiraCode&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/9OJpMXL.png&#34; alt=&#34;&#34;&gt;
&lt;a href=&#34;https://github.com/tonsky/FiraCode&#34;&gt;FiraCode&lt;/a&gt;，整體看起來就是乾淨優雅，尤其是連字能使得整個 Code 更有滑順的感覺，十分推薦。&lt;/p&gt;
&lt;p&gt;然而，FiraCode 雖然陪伴我一段不短的時間，但還是有一個致命的缺陷：不支援中文！&lt;/p&gt;
&lt;p&gt;於是後來我基本上都使用下面介紹的這款&lt;/p&gt;
&lt;h3 id=&#34;更紗黑體&#34;&gt;更紗黑體&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/yVMe5wC.png&#34; alt=&#34;&#34;&gt;
&lt;a href=&#34;https://github.com/be5invis/Sarasa-Gothic&#34;&gt;更紗黑體&lt;/a&gt; 除了同樣支援連字以外，更支援多國語系。例如繁中就是有標註 TC 的字形，看見中英文都套用上去就是一陣舒服。是現在我的主力。&lt;/p&gt;
&lt;p&gt;至於不想用等寬字體的朋友，都看到這裡了，沒關係。下面這套推薦給你們&lt;/p&gt;
&lt;h3 id=&#34;ink-free&#34;&gt;Ink Free&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/EShjvS5.png&#34; alt=&#34;&#34;&gt;
就是這麼直接！這麼舒服！如果你的同事要過來 Code Review，不要猶豫字體直接換下去！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SikuliX —— 針對圖形介面寫自動化腳本的小幫手</title>
      <link>https://igouist.github.io/post/2020/03/sikulix/</link>
      <pubDate>Sun, 22 Mar 2020 13:11:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/03/sikulix/</guid>
      <description>&lt;p&gt;最近因緣際會下開始玩一些自動化測試的小工具，發現即使不是用在正規的測試時也相當實用，畢竟我們這行能讓電腦自動幫我們省事就是一種樂趣嘛。正巧這禮拜比較忙，無法準時推出訂便當系列的續集，因此決定直接紀錄一下試玩 Sikulix 的過程，以後有需要自動化的時候也方便回來參考。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sikulix 是一款針對圖形介面編寫腳本達到自動操作&lt;/strong&gt;的軟體，操作上相當方便。主要是將目標的圖示等畫面擷取下來，再編寫程式對目標進行操作。它編寫腳本時使用的語言是 &lt;a href=&#34;https://www.jython.org/&#34;&gt;Jython&lt;/a&gt; —— 用 Java 實現的 Python，關於 Jython 的基本操作可以參見 &lt;a href=&#34;https://iowiki.com/jython/jython_overview.html&#34;&gt;Wiki 教程：Jyhton&lt;/a&gt;，對於「實現 Python？」這句話感到疑惑的朋友可以參見 &lt;a href=&#34;https://zhuanlan.zhihu.com/p/58492338&#34;&gt;知乎：各種 Python 實現的簡單介绍與比較&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此外，本篇對於 Sikulix 的參考主要來自於&lt;a href=&#34;https://ypwalter.blogspot.com/2018/06/sikuli-sikulix.html?view=classic&#34;&gt;【測試】圖形化的自動測試 Sikuli / SikuliX 的相關技巧&lt;/a&gt;以及 &lt;a href=&#34;https://www.tpisoftware.com/tpu/articleDetails/876&#34;&gt;Sikulix 圖形辨識自動化測試開發工具&lt;/a&gt;兩篇，特此感謝。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>我要訂便當 (2): 用 Python &#43; Sqlite 儲存訂單</title>
      <link>https://igouist.github.io/post/2020/03/bandon-2-sqlite/</link>
      <pubDate>Sun, 15 Mar 2020 20:49:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/03/bandon-2-sqlite/</guid>
      <description>&lt;p&gt;前情回顧：上一集在 &lt;a href=&#34;https://igouist.github.io/post/2020/03/bandon-1-selenium/&#34;&gt;我要訂便當(1) —— 用 Python + Selenium 控制瀏覽器取得訂單&lt;/a&gt; 中，我們藉由自動化套件 Selenium 控制 Chrome 成功從訂便當網站裡取得訂單資訊了。但只能夠取得現在的訂單，和原本有新訂單的時候才通知的目標仍然有點差距，那麼，如何判斷有沒有新訂單呢？只要和上一次讀取時的訂單相比就能知道了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目標：將訂單儲存起來，判斷有沒有新訂單。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這一篇主要的做法主要參考自 &lt;a href=&#34;https://www.youtube.com/watch?v=pI3FDACJFAs&#34;&gt;大數軟體 - 如何透過 Line 發送最新一集的漫畫&lt;/a&gt; 中，關於如何判斷是否有最新一集漫畫的部分。這系列的影片步驟明瞭，說明直接，同時標題也很對我胃口（我就喜歡把工具拿來生活周遭玩的感覺），因此這邊也推薦一下，有興趣的可以去看看。&lt;/p&gt;
&lt;p&gt;回歸正題，這篇的第一部分就是要使用 Sqlite 將抓到的訂單儲存起來。Sqlite 顧名思義就是 SQL + Lite 的感覺，主打小巧輕便。它會將資料儲存在一個檔案中，並且支援精簡的 SQL 指令，可以說是相當方便。&lt;/p&gt;
&lt;p&gt;在 Python 要對 Sqlite 做操作主要是藉由 sqlite3 這個包，因此在接下來的步驟前，請先安裝這個包。關於 Sqlite3 的基本操作，可以參閱 &lt;a href=&#34;https://www.runoob.com/sqlite/sqlite-python.html&#34;&gt;菜鳥教程的 SQLite - Python&lt;/a&gt; 教學。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>我要訂便當 (1): 用 Python &#43; Selenium 控制瀏覽器取得訂單</title>
      <link>https://igouist.github.io/post/2020/03/bandon-1-selenium/</link>
      <pubDate>Sun, 08 Mar 2020 18:47:23 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/03/bandon-1-selenium/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;p&gt;這是參加&lt;a href=&#34;https://www.hexschool.com/2019/11/14/2019-11-14-w3Hexschool-2020-challenge/&#34;&gt;六角鼠年全馬&lt;/a&gt;的第一篇，主要是希望能夠養成寫部落格的習慣。由於我本身並沒有主要技能，因此這次參賽文章會以我最近玩的玩具、使用的套件或是遇到的問題做紀錄。&lt;/p&gt;
&lt;p&gt;希望能夠派上用場。&lt;/p&gt;
&lt;p&gt;目標：使用 &lt;strong&gt;Python&lt;/strong&gt; 及 &lt;strong&gt;Selenium&lt;/strong&gt; 連線到訂便當網站，自動輸入帳號密碼登入後，取回網站上的訂單資訊&lt;/p&gt;
&lt;p&gt;(2020/12/4) 更新: 由於訂便當網站改版，所以程式碼已經不能照抄了。但有興趣的朋友還是能自己摸索做點變動，也能夠照常進行喔，加油～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近在公司的時候有個莫大的煩惱，就是關於辦公室團購這回事兒。現在待著的公司主要是從 &lt;a href=&#34;https://dinbendon.net/&#34;&gt;Dinbendon&lt;/a&gt; 這套系統來揪團購，舉凡品客、火鍋等都在上面訂過，據我觀察最受歡迎出現最多次的當屬雞排了。煩惱就在於，每次都會錯過雞排的團購，光在辦公室聞著四面八方傳來的雞排香味，就令人無法忍受！因此趁著這個機會，來嘗試能不能像之前的 &lt;a href=&#34;https://igouist.github.io/post/2019/12/ptt-crawler-and-listener/&#34;&gt;PTT&lt;/a&gt; 一樣來弄出一個通知，順便玩玩最近看到的工具。這系列的文章會分成多個部分，主要是以使用的工具來分集。&lt;/p&gt;
&lt;p&gt;由於在從團購網取得訂單的過程中需要跟網頁進行互動，因此這次要使用的工具是 &lt;strong&gt;&lt;a href=&#34;https://www.selenium.dev/&#34;&gt;Selenium&lt;/a&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Selenium 是一個對網頁做自動化測試的工具&lt;/strong&gt;，但我個人比較常在爬蟲的時候用到XD。它能夠經由腳本或錄製的方式對瀏覽器進行操作，並且也支援相當多語言可以使用，例如我同事便使用 C# 和 Hangfire 來完成訂便當的目標（對，這麼無聊的人不只我一個），而我則用相對比較熟悉的 Python 來實作。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python: 用爬蟲在 PTT 上監聽關鍵字並寄通知信</title>
      <link>https://igouist.github.io/post/2019/12/ptt-crawler-and-listener/</link>
      <pubDate>Mon, 09 Dec 2019 10:05:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2019/12/ptt-crawler-and-listener/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;前陣子很想跟 Netflix 的團購，三不五時就上 PTT 看一下團購板，但看到的時候大多已經截止，還有填單填到一半發現已經收滿的，氣得七竅生煙。故嘗試寫了一個通知，在這邊記錄下來。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目標：當團購板上新發了一篇 Netflix 的文，馬上寄信告訴我。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;為了這個目標，我們基本上需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用爬蟲取得團購板的文章標題&lt;/li&gt;
&lt;li&gt;能夠寄信（使用 Gmail）&lt;/li&gt;
&lt;li&gt;持續監視，也就是重複執行&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Android: MySQL 連線筆記（使用XAMPP）</title>
      <link>https://igouist.github.io/post/2019/12/android-fetch-mysql-using-xampp/</link>
      <pubDate>Mon, 09 Dec 2019 00:09:10 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2019/12/android-fetch-mysql-using-xampp/</guid>
      <description>&lt;p&gt;之前做給學弟妹參考的簡單筆記，順手放上來，以後遇到的時候可以回來參考。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目標：利用 XAMPP 簡單地架設一個伺服器環境，建立資料庫，並且能在 Android 上取得資料庫的資料。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;架設伺服器環境&#34;&gt;架設伺服器環境&lt;/h2&gt;
&lt;p&gt;在電腦架設伺服器環境的工具有很多種，例如 &lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10190366&#34;&gt;Windows 內建就有的 IIS&lt;/a&gt;（通常拿來搭配 ASP.net）以及微軟的 &lt;a href=&#34;https://snippetinfo.net/media/1869&#34;&gt;WAMP&lt;/a&gt; 等等，或是直接用 &lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10075496&#34;&gt;Node.js&lt;/a&gt; 跑環境兼後端，不勝枚舉。今天要拿來實作的是 &lt;strong&gt;XAMPP&lt;/strong&gt; 這一款。XAMPP 嚴格說起來並不算是一個軟體，而是一個&lt;strong&gt;架站懶人包&lt;/strong&gt;，它的名字是由這些東西組成的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;X = 跨平台&lt;/li&gt;
&lt;li&gt;A = Apache：網頁伺服器軟體&lt;/li&gt;
&lt;li&gt;M = MySQL：資料庫軟體&lt;/li&gt;
&lt;li&gt;P = PHP：程式語言，可以閱覽 &lt;a href=&#34;http://www.w3school.com.cn/php/&#34;&gt;w3school：PHP&lt;/a&gt; 和 &lt;a href=&#34;http://www.runoob.com/php/php-tutorial.html&#34;&gt;菜鳥教程：PHP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;P = Perl：程式語言，可以閱覽 &lt;a href=&#34;http://www.runoob.com/perl/perl-tutorial.html&#34;&gt;菜鳥教程：Perl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Asp.net MVC: 連線資料庫、簡單實作 CRUD</title>
      <link>https://igouist.github.io/post/2019/12/aspnet-connect-db/</link>
      <pubDate>Mon, 09 Dec 2019 00:09:09 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2019/12/aspnet-connect-db/</guid>
      <description>&lt;p&gt;在教學時直接使用 EF 對資料庫跑繫結的方式產生各頁面，但得到了「點一點東西就跑出來了搞不懂呀」的回饋，心想有道理。因此從頭開始實作一遍，並記錄下來。&lt;s&gt;（雖然做完還是覺得，直接用 EF 跑的話果然比較安全方便啊）&lt;/s&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目標：&lt;strong&gt;實作一個 MVC 架構，具資料庫基本操作功能的網站&lt;/strong&gt;，其中包含連線至資料庫的 model、對其進行調用的 controller 以及顯示的 view。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;註：本文預設已在本地電腦上安裝了 &lt;a href=&#34;https://www.microsoft.com/zh-tw/sql-server/sql-server-editions-express&#34;&gt;SQL Server&lt;/a&gt;，並且建立了測試用的資料庫 Test 及表 card，詳情會在文章內述。另外，由於在寫這邊的時候是為了練習手動從編碼開始嘗試連線，故將不使用 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/aspnet/mvc/overview/getting-started/getting-started-with-ef-using-mvc/creating-an-entity-framework-data-model-for-an-asp-net-mvc-application&#34;&gt;EF 連線產生 Edmx&lt;/a&gt; 的方式，而是直接手工編寫程式碼進行操作。&lt;/p&gt;
&lt;p&gt;另外，關於直接從資料表自動產生可操作的頁面，亦即使用 Entity Framework 做資料繫結的方式，請見 &lt;a href=&#34;https://igouist.github.io/post/2019/12/aspnet-connect-db-ef/&#34;&gt;Asp.net MVC 筆記：Entity Framework 連線資料庫&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Asp.net MVC: Entity Framework 連線資料庫</title>
      <link>https://igouist.github.io/post/2019/12/aspnet-connect-db-ef/</link>
      <pubDate>Mon, 09 Dec 2019 00:09:08 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2019/12/aspnet-connect-db-ef/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;目標：將 &lt;a href=&#34;https://igouist.github.io/post/2019/12/aspnet-connect-db/&#34;&gt;上一篇的 Asp.net MVC：連線資料庫、簡單實作 CRUD&lt;/a&gt; 的資料庫基礎功能改成以 &lt;strong&gt;Entity Framework&lt;/strong&gt; 產生的方式跑一遍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然上一篇介紹了土法煉鋼動手做的資料庫取值方式，就覺得不順手把從 EF 建立出基本功能介面的方式記錄下來似乎是有點奇怪。實際上開始寫成筆記之後才發現對內容尚不是很了解，例如一直用 Data First 產生頁面但對 Code First 以程式碼產生架構的方式很不熟。儘管如此仍稍微紀錄一下，之後有更深的了解（例如 ASP.NET Identity 或 Code First 等部分）再進一步做成筆記。另外也可參考較詳細的&lt;a href=&#34;https://docs.microsoft.com/zh-tw/aspnet/mvc/overview/getting-started/getting-started-with-ef-using-mvc/creating-an-entity-framework-data-model-for-an-asp-net-mvc-application&#34;&gt;官方文檔&lt;/a&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>archives</title>
      <link>https://igouist.github.io/archives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://igouist.github.io/archives/</guid>
      <description></description>
    </item>
    
    <item>
      <title>reposts-archives</title>
      <link>https://igouist.github.io/repost/archives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://igouist.github.io/repost/archives/</guid>
      <description></description>
    </item>
    
    <item>
      <title>關於我</title>
      <link>https://igouist.github.io/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://igouist.github.io/about/</guid>
      <description>剛踏入程式業的小菜雞，什麼都想碰一點，但沒有一項敢自稱熟練。 儘管文筆不佳學得又淺，但相信把過程記下來，將來需要時就能左手抄右手，想想就樂不可</description>
    </item>
    
  </channel>
</rss>