<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>w3HexSchool on 伊果的沒人看筆記本</title>
    <link>https://igouist.github.io/tags/w3hexschool/</link>
    <description>Recent content in w3HexSchool on 伊果的沒人看筆記本</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hant-TW</language>
    <lastBuildDate>Sun, 20 Dec 2020 23:57:00 +0800</lastBuildDate><atom:link href="https://igouist.github.io/tags/w3hexschool/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>菜雞與物件導向 (15): 最少知識原則</title>
      <link>https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle/</link>
      <pubDate>Sun, 20 Dec 2020 23:57:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/FOWZ8zY.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;上一篇&lt;/a&gt;我們紀錄了依賴反轉原則，到此五大原則介紹完畢…是這樣嗎？太天真了！就像四天王總是五個人一樣，五大原則當然也有第六個！&lt;/p&gt;
&lt;p&gt;今天的主角就是五大原則中Ｌ位的第一候補：&lt;strong&gt;最少知識原則&lt;/strong&gt;，也被稱作&lt;strong&gt;迪米特法則&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;最少知識原則-least-knowledge-principle&#34;&gt;最少知識原則 (Least Knowledge Principle)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;只和直接的朋友溝通，不和陌生人說話&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那麼所謂的朋友是什麼呢？就是指這個物件或方法有直接相關的物件啦。例如當我們使用一個方法時，這個方法應該只認識：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;該方法所屬的類別&lt;/li&gt;
&lt;li&gt;該方法所接收的參數&lt;/li&gt;
&lt;li&gt;該方法中建立的類別&lt;/li&gt;
&lt;li&gt;該方法所屬的類別所依賴的對象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外對這個方法而言都是陌生人。什麼情況會遇到陌生人呢？有一個蠻常遇到的狀況就符合定義：當我們使用依賴對象的方法，該方法給了我們另一個類別時，我們就正在接觸毫無關係的陌生人。&lt;/p&gt;
&lt;p&gt;這個原則的要求就是：不要跟陌生人說話，就算是朋友介紹了他的朋友給你也一樣，不認識就是不認識，更不能拿陌生人的東西。換個方式就是說：&lt;strong&gt;不應該使用其他類別的方法所回傳的類別的方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;用文字的可能會有點繞口令，簡單來說就是像 &lt;code&gt;Foo.GetBoo().BooDoSomeThing()&lt;/code&gt; 這種情況，我們不該去跟 &lt;code&gt;Foo&lt;/code&gt; 要 &lt;code&gt;Boo&lt;/code&gt; 回來然後使用 &lt;code&gt;Boo&lt;/code&gt; 的方法，因為我們只認識 &lt;code&gt;Foo&lt;/code&gt;，而不認識 &lt;code&gt;Boo&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;畢竟，很多時候我們不該直接插手控制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主人可以叫狗坐下，但主人不應該直接控制狗的腿坐下&lt;/li&gt;
&lt;li&gt;當我們按下牆壁的開關時，是希望燈直接打開。而不是彈出兩條電線讓你自己接起來&lt;/li&gt;
&lt;li&gt;當我們去餐廳時，會讓服務生替你把要求的餐點交給廚師烹調，而不是我們直接殺進去廚房對著廚師吼「你給我煮啊！」&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這種直接叫廚師煮給你看、甚至自己搶過來煮的做法，就是平常直接伸手進去其他模組的控制狂、完全和 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;封裝&lt;/a&gt; 的概念背道而馳。&lt;/p&gt;
&lt;p&gt;腿的動作就應該讓狗去自己控制，讓燈泡亮就應該隱藏在開關之後。物件就該只和直接的朋友溝通。&lt;/p&gt;
&lt;p&gt;除了只和直接的朋友溝通，也就是只和直接依賴的類別互動，這個互動也是要講究一點的。畢竟朋友之間也還是會有共通的默契和距離，類別之間的互動也應該只做必要的溝通。&lt;/p&gt;
&lt;p&gt;這就是我們在封裝提過的「給程式碼隱私的空間」：為了避免物件之間的互動情況過於複雜，我們應該加以控制，把各自的工作封裝在各自的物件內部，使其只有必要的往來。&lt;/p&gt;
&lt;p&gt;因此最少知識原則就要求了：&lt;strong&gt;一個物件應該對其他物件應該只有最少的了解&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;到這邊讓我們稍微整理一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只和直接的朋友溝通，不和陌生人說話：物件或方法應該只和自己及直接接觸的對象互動&lt;/li&gt;
&lt;li&gt;不應該使用其他類別的方法回傳的類別的方法：不該破壞封裝並造成額外且違反邏輯的互動&lt;/li&gt;
&lt;li&gt;一個物件對其他物件應該只有最少的了解：類別只開放 (Public) 必要的功能，並且類別之間應該只有必要的互動&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是說：&lt;strong&gt;只依賴應該依賴的對象，只開放應該開放的方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;聰明的朋友應該能從這邊看出最少知識原則的核心理念了，就是&lt;strong&gt;解除耦合&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我們在 &lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;耦合篇&lt;/a&gt; 提過，物件彼此有關聯就會產生耦合，而不好的耦合就會散發出臭味。為了方便管理和降低複雜性，減少臭味出現的機率，我們的目標就是追求耦合。&lt;/p&gt;
&lt;p&gt;相對於 &lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;依賴反轉原則&lt;/a&gt; 利用 &lt;a href=&#34;https://igouist.github.io/post/202007-oo-7-interface&#34;&gt;抽象和介面&lt;/a&gt; 的方式在模組之間做出隔離和控制的作法。最少知識原則則是利用 &lt;a href=&#34;https://igouist.github.io/post/202007-oo-3-encapsulation&#34;&gt;封裝&lt;/a&gt; 的概念來解除耦合，畢竟，關聯越少耦合也越少嘛。&lt;/p&gt;
&lt;p&gt;所以我們可以說：良好的封裝就是符合最少知識原則的封裝。複雜性隱藏到自己內部，對外只開放必要的功能，並且只使用到直接關聯的對象，確保不會造成意外的耦合，且讓關聯的模組之間更加靠攏。如此一來，就能夠更加提高內聚、降低耦合了。&lt;/p&gt;
&lt;p&gt;然而，為了好好地切分朋友和陌生人，也可能會變成需要&lt;strong&gt;建立更多的中間類別&lt;/strong&gt;，或是更多的依賴關係。&lt;/p&gt;
&lt;p&gt;例如人原本可以直接把電線接起來讓燈泡亮起來，但為了把電線使燈泡變亮這件事的複雜度封裝起來，我們就必須要有一個開關，再把電線放到開關後面去，變成了人按下開關，開關藉由電線點亮燈炮等等，整體來說會使系統內的類別變多。&lt;/p&gt;
&lt;p&gt;因此，在設計的時候也必須要考量到整個方法串的深度，可以用 &lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;單一職責&lt;/a&gt; 的角度下去衡量。請不要越封裝越細，類別越做越多，反而變成過度設計了。&lt;/p&gt;
&lt;p&gt;那麼，今天就記錄到這裡。由於最少知識原則的概念，大多在封裝篇和耦合篇的時候就已經偷渡完了，所以這邊就針對觀念簡單介紹，實務上處理類別間的耦合時，就可以稍微從最少知識原則的角度想一想，一定會有幫助的。那麼，我們下次見～&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列下一篇：&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/hatelove/2010/10/16/least-knowledge-principle&#34;&gt;[ASP.NET]91之ASP.NET由淺入深 不負責講座 Day19 - LoD/LKP 最少知識原則 - In 91&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@ckpattern35/ck-patt-%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F-11-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%89%87-demeter-law-931fefc4abda&#34;&gt;[CK Patt 設計模式#11] 迪米特法則(Demeter Law)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yuchitung.github.io/2019/06/24/least-knowledge-principle/&#34;&gt;最小知識原則 - Yuchi 的學習筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-3_law-of-demeterlod-%E7%8B%84%E7%B1%B3%E7%89%B9%E6%B3%95%E5%89%87/&#34;&gt;Object Oriented物件導向設計原則SOLID-3:Law of Demeter(LoD) 狄米特法則 - Sian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://c.biancheng.net/view/1331.html&#34;&gt;迪米特法則——面向對象設計原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/gaochundong/p/least_knowledge_principle.html&#34;&gt;最少知识原则（Least Knowledge Principle） - 熵碼匠藝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ithome.com.tw/voice/98670&#34;&gt;封裝與迪米特法則 - 林信良&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同系列文章&#34;&gt;同系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (14): 依賴反轉原則</title>
      <link>https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle/</link>
      <pubDate>Sun, 13 Dec 2020 21:53:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ywiHuis.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在聊依賴反轉之前，先讓我們聊聊什麼是依賴，所謂的依賴就是一種「受到某個東西影響、牽制」的狀態。&lt;/p&gt;
&lt;p&gt;例如說如果有個像我一樣的肥宅每天一定要來一片雞排才能療癒身心，那我就是依賴雞排；&lt;br/&gt;
同樣的，如果有個大叔不抽菸就會全身不舒服，就是對香菸有所依賴。&lt;/p&gt;
&lt;p&gt;當有「必須要藉由某個人事物來達到目的」的狀況時，就是依賴。&lt;/p&gt;
&lt;p&gt;而在程式設計裡面的概念也差不多，如果&lt;strong&gt;Ａ模組直接受到Ｂ模組的影響，我們就稱Ａ依賴了Ｂ&lt;/strong&gt;，最明顯的狀況就是Ａ模組需要藉由Ｂ模組的實例來完成某個功能的時候。&lt;/p&gt;
&lt;p&gt;例如「匯出報表」功能建立了一個「Excel 控制類別」的實例以建立檔案；&lt;br/&gt;
或是「會員查詢」功能建立了一個「DB 連線」的實例來進入資料庫取得會員資料&lt;/p&gt;
&lt;p&gt;遇見這種「必須要藉由某個模組的實例來完成想要的動作」的狀況時，就是依賴。&lt;/p&gt;
&lt;h2 id=&#34;依賴與耦合&#34;&gt;依賴與耦合&lt;/h2&gt;
&lt;p&gt;我們在之前的 &lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;耦合篇&lt;/a&gt; 提過，如果模組和另一個模組之間有關連，那這兩者之間就耦合。以此來看，依賴就是一種耦合的關係，那麼，依賴是健康還是不健康的耦合呢？&lt;/p&gt;
&lt;p&gt;現在讓我們用 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;多型篇&lt;/a&gt; 用過的「老闆徵工程師」的例子來舉例一下：現在有間小小公司，老闆請來了小明當工程師，並請他開工撰寫產品程式碼。&lt;/p&gt;
&lt;p&gt;當「撰寫產品程式」對「工程師」直接依賴的時候，狀況可能是這樣的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Product Work()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Ming programmer = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Ming();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; product = programmer.Programming();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; product;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;過一陣子，老闆發現小明寫出來的東西似乎不太行，於是把小明趕走，另外請了小華。這時候因為「工程師」這個實作類別不一樣了，我們就必須要改一次程式碼：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Product Work()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Hua programmer = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Hua();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; product = programmer.Programming();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; product;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;又過了好一陣子，老闆又另外請了小美來工作。於是又要再改一次，而且小美的工作方式甚至不叫做 &lt;code&gt;Programming&lt;/code&gt;，而是 &lt;code&gt;Coding&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Product Work()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Mei programmer = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Mei();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; product = programmer.Coding();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; product;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;現在有感覺到一點問題了嗎？如果一直換人，&lt;code&gt;Work&lt;/code&gt; 的程式碼豈不是每次都要修改？甚至根據依賴對象的不同，連使用方式都可能受到影響，很明顯這樣就是所謂不健康的耦合。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這邊還有個例子我很喜歡，在這篇 &lt;a href=&#34;https://notfalse.net/1/dip&#34;&gt;依賴倒置原則&lt;/a&gt; 的文章中，用吃東西來舉例：如果寫死了依賴漢堡，難道一輩子就只能吃漢堡了嗎？如果想改成吃義大利麵，就要修改程式碼；有一百種食物，難道就要改一百次嗎？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;試想，因為「DB 的連線方法」有了一些變更，使用到該方法的「會員查詢」就連帶要更動，甚至有關聯的地方都必須要變動，如此一來改動的範圍如森林大火般延燒。&lt;/p&gt;
&lt;p&gt;同時由於我們在開發功能的時候，都是讓大功能（高階模組）調用各個小功能（低階模組）來實現目標，越高層的就越整體、越抽象、越接近目標；而越低階就越細節、越接近實作，關注點越小。而我們的思維通常是由大範圍往下到小實作，從整體目標逐漸拆解成各個步驟。&lt;/p&gt;
&lt;p&gt;但是，當我們的高階模組直接依賴低階模組的時候，事情就會變得有點怪怪的。就像董事長必須清潔廁所導致沒空進行公司決策一樣，&lt;strong&gt;原本職責在於高層次、整體的模組，卻不得不因為這些低階模組的變動受到影響&lt;/strong&gt;。那麼隨著層次越高，底下依賴的模組越多，改動的頻率就會提高。&lt;/p&gt;
&lt;p&gt;既然改動範圍又大，改動頻率又高，耦合又不健康，就代表這樣的依賴是有問題的。然而，物件導向的精神就在於讓物件之間互相協作，消除多餘的重複。因此，依賴又是不可能消除的。&lt;/p&gt;
&lt;h2 id=&#34;依賴反轉原則-dependency-inversion-principle&#34;&gt;依賴反轉原則 (Dependency-Inversion Principle)&lt;/h2&gt;
&lt;p&gt;面對這樣的困境，依賴反轉原則告訴我們：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;高階模組不應該依賴於低階模組。兩者都應該依賴抽象。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是的，不應該直接去依賴，而是必須藉由抽象來隔開。不應該直接去受到實作的影響，而是只要關注在所需要的功能。&lt;/p&gt;
&lt;p&gt;這部分其實已經破梗完了，我們在 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;介面篇&lt;/a&gt; 已經說明過依賴反轉最基本的思維路線。我們並不是用低階模組的功能直接拼湊出高階模組，讓高階模組直接依賴低階模組然後受到影響；而是把關注點放在需要的功能上，用介面隔開實作，解開他們彼此之間的耦合，介面就是模組之間的抽象層。&lt;/p&gt;
&lt;p&gt;同時也要明白一件重要的事：&lt;strong&gt;並不是高階模組去依賴低階模組。而是高階模組提出它需要的功能，低階模組去實作出這些功能、達成高階模組的目標&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我們並不是因為有「DB 的連線方法」和「處理會員資料的方法」所以才說「我們有這兩個東西欸，那我們來組成會員查詢功能吧」；而是「我們想做一個會員查詢功能，所以我們需要連線到 DB，然後對這些資料做篩選和處理」&lt;/p&gt;
&lt;p&gt;就如同我們在介面的例子所提的一樣：「老闆為了製造產品（高階模組的目標），開出了工程師的應徵條件（介面），而小明前來應徵（低階模組的實作）」&lt;/p&gt;
&lt;p&gt;如此一來，依賴就「反轉」了。原本是 &lt;code&gt;高階模組 → 低階模組&lt;/code&gt; 的關係，變成了 &lt;code&gt;高階模組 → 介面 ← 低階模組&lt;/code&gt;。並不是高階去依賴低階，而是低階去依賴高階要求的功能。&lt;/p&gt;
&lt;p&gt;這也就是依賴反轉原則的第二點：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;抽象不應該依賴細節；細節應該依賴抽象。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;到這邊我們就推完 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;介面篇&lt;/a&gt; 的前提了，請大家再回顧一下介面篇的內容。也就是說，上面的例子改用抽象層隔離之後，就會和介面篇的例子相同，變成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Product Work()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    IProgrammer programmer = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Ming();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; product = programmer.Programming();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; product;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這邊就會遇到我們介面篇結束時所問的問題：我們使用功能之前，必須先建立該類別的實例，也就是 &lt;code&gt;new Ming()&lt;/code&gt;，那麼，我們不就還是直接依賴了實作嗎？&lt;/p&gt;
&lt;h2 id=&#34;控制反轉-inversion-of-control-ioc-br-依賴注入-dependency-injection&#34;&gt;控制反轉 (Inversion of Control, IoC) &amp;amp;&lt;br/&gt; 依賴注入 (Dependency Injection)&lt;/h2&gt;
&lt;p&gt;即使我們反轉了依賴關係，但總是要建立實例才能使用的呀。所以，只是將對具體的依賴更改為對抽象的依賴，仍然是不夠的，在要使用的瞬間就會遭遇到問題。面對這個問題，大大們提出了許多個解決的方法，今天就介紹一個比較常見的方向：&lt;strong&gt;控制反轉 (Inversion of Control, IoC)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;思路非常的簡單：既然如此，我們把實例的建立和實例的使用切分開來就好了，&lt;strong&gt;不再是由高階模組去建立並控制低階模組，而是我們讓一個控制反轉中心去建立低階模組，然後高階模組要使用的時候再把這個低階模組交給高階模組使用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如此一來，控制權也跟著反轉過來了，高階模組從&lt;strong&gt;主動&lt;/strong&gt;建立低階模組，變成&lt;strong&gt;被動&lt;/strong&gt;接收低階模組；也就是從原先的 &lt;code&gt;高階模組 —(建立)→ 低階模組&lt;/code&gt;，變成了 &lt;code&gt;高階模組 ←(傳遞低階模組)— 控制反轉中心&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;控制反轉的概念比較像是：當肚子餓的時候，如果自己煮菜的時候，必須自己備料、自己烹調、才能有東西吃。但如果去餐廳點餐，只要說出自己想要的餐點，店家就會負責備料，廚師就會烹調，最後就把需要的餐點送上桌來吃。&lt;/p&gt;
&lt;p&gt;也就是說，&lt;strong&gt;高階模組再也不需要關心如何建立，該建立哪個實體，只專注於使用功能，真正達到介面的精神。低階模組也只需要等待控制反轉中心分發，到了崗位就把份內事做好，專心在自己的職責身上即可&lt;/strong&gt;。如此一來就能解除兩者之間的耦合。&lt;/p&gt;
&lt;p&gt;但是，要怎麼把控制中心建立的低階模組，交給高階模組做使用呢？這時候的實作方式就是我們所謂的 &lt;strong&gt;依賴注入 (Dependency Injection)&lt;/strong&gt; 了。&lt;/p&gt;
&lt;p&gt;依賴注入說穿了很簡單，就是&lt;strong&gt;用各種姿勢把東西丟進去給類別使用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如說我們先前提過的 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;建構式&lt;/a&gt;，就是其中一種解決方法。用上面的例子，就會變成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ProductService&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; IProgrammer _programmer;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; ProductService(IProgrammer programmer)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;._programmer = programmer;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Product Work()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; product = &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;._programmer.Programming();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; product;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在這個例子中，我們利用建構式的方式，從外部傳入該介面的實體來使用。現在撰寫產品程式碼的工作再也不用為了換工程師而改變，也不用因為實作細節或是方法名稱而煩惱，只要照個介面合約使用就可以了。至於要傳遞哪個實體進來，這份工作要交給小明還是小美，就讓控制中心去決定，大家各司其職，落實單一職責。&lt;/p&gt;
&lt;p&gt;當然，注入的方式不只建構式注入，還有設值注入（也就是從外部改變目標的某個屬性值來達到注入）等等；提供 IOC 的方式也不只一種，例如 .net 的 Unity，甚至到了 .net Core 時代 IOC 還直接是內建的功能呢，由於口味眾多，此處暫且按下不表。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;補充：下個系列文補了 &lt;a href=&#34;https://igouist.github.io/post/2021/11/newbie-6-dependency-injection&#34;&gt;使用 依賴注入 (Dependency Injection) 來解除強耦合吧&lt;/a&gt;，有興趣的朋友可以接續看看&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;結語&#34;&gt;結語&lt;/h2&gt;
&lt;p&gt;那麼，我們最後再來複習一遍：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高階模組不應該依賴於低階模組，兩者都應該依賴抽象&lt;/strong&gt;。為了解除耦合，必須用介面這種抽象層進行隔離。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象不應該依賴細節。細節應該依賴抽象&lt;/strong&gt;。介面應該是高階模組提出的要求，然後才去使用實作了這些要求的低階模組。這些實作應該圍繞著這些要求，而不是讓要求去配合實作，更不要讓要求中包含實作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;為了解決介面實例化仍然會產生依賴的問題，就有了控制反轉&lt;/strong&gt;。把控制權交給第三方，藉此讓使用者能夠不用關心實例化的過程，而注重在使用並達成目標的職責上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而控制反轉的具體實現方法是依賴注入&lt;/strong&gt;，藉由從建構式傳遞、更改目標的屬性等方式，把低階模組交給高階模組使用者。當我們藉由依賴注入的方式實現控制反轉，就能夠讓物件的設計符合依賴反轉原則。&lt;/p&gt;
&lt;p&gt;這個部份的做法還是挺複雜的，&lt;del&gt;所以才拖稿這麼久&lt;/del&gt;，因此決定把原因的順序推過一遍，也算是幫自己重新了解一次。參考資料有蠻多篇我都相當喜歡，想更了解依賴反轉、控制反轉等等的朋友可以再自行閱讀。那麼，我們下次見～&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列下一篇：&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://notfalse.net/1/dip&#34;&gt;依賴倒置原則 (Dependency-Inversion Principle, DIP) - NotFalse 技術客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://notfalse.net/3/ioc-di&#34;&gt;控制反轉 (IoC) 與 依賴注入 (DI) - NotFalse 技術客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@f40507777/%E4%BE%9D%E8%B3%B4%E5%8F%8D%E8%BD%89%E5%8E%9F%E5%89%87-dependency-inversion-principle-dip-bc0ba2e3a388&#34;&gt;依賴反轉原則 Dependency Inversion Principle (DIP) - Finn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10191603&#34;&gt;從被動變主動—依賴反轉 - 伊恩 - iT邦幫忙&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dustinhsiao21.github.io/dp/solid-dependency-inversion-principle/&#34;&gt;SOLID 原則 - Dependency Inversion Principle(依賴反轉原則) - Dustin;s murmur&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-6_dependency-inversion-principledip-%E4%BE%9D%E8%B3%B4%E5%8F%8D%E8%BD%89%E5%8E%9F%E5%89%87/&#34;&gt;Object Oriented物件導向設計原則SOLID-6:Dependency Inversion Principle(DIP)依賴反轉原則 - Sian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sunnyday0932.github.io/2020/%E4%BE%9D%E8%B3%B4%E6%B3%A8%E5%85%A5-didependency-injection/&#34;&gt;依賴注入 DI(Dependency Injection) - Sian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/supershowwei/2018/07/30/144329&#34;&gt;[小菜一碟] 談談物件導向設計原則中 DIP（依賴反轉原則）中的 Dependency（依賴） - 軟體主廚的程式料理廚房&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jyt0532.com/2020/03/24/dip/&#34;&gt;深入淺出依賴反向原則 Dependency Inversion Principle - jyt0532&amp;rsquo;s Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/daniel/2018/01/17/140435&#34;&gt;IOC(控制反轉)，DI(依賴注入) 深入淺出~~ - 石頭的coding之路&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同系列文章&#34;&gt;同系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>7&#43; Taskbar Tweaker —— 簡單方便的 Windows 工作列調整工具</title>
      <link>https://igouist.github.io/post/2020/12/7_taskbar/</link>
      <pubDate>Sun, 06 Dec 2020 23:49:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/12/7_taskbar/</guid>
      <description>&lt;p&gt;故事是這樣的——&lt;/p&gt;
&lt;p&gt;Win10 工作列的合併設定有這些選項：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/yZypwQD.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;當選擇「一律、隱藏標籤」時，工作列上同樣的程式就會摺疊起來：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/8JvOmkJ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;而「永不」和「當工作列滿時」則會將工作列展開：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/BqA2ERo.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;好的，那麼像我個性這麼麻煩的人，如果覺得顯示名字很佔位置，可是又不想要摺疊之後按兩次才能打開我要的應用程式，偏偏又很愛開一整排 IDE 的話，有沒有什麼簡單的辦法&lt;strong&gt;不要讓圖示合併，但也不要顯示名字呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果有個小工具，可以讓這些工作列的設定更彈性就好了，會有嗎？&lt;/p&gt;
&lt;p&gt;有的！&lt;/p&gt;
&lt;p&gt;今天要記錄的是 &lt;strong&gt;7+ Taskbar Tweaker&lt;/strong&gt; 這個小東東，他的畫面是長這樣的&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/bSDYzFO.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以調整的部分挺多的，可以隨個人喜好進行調整，從滑鼠操作工作列一路到時間要不要顯示秒都有。&lt;/p&gt;
&lt;p&gt;例如我前面想要的需求，就可以把分組的部分改成「&lt;strong&gt;不分組&lt;/strong&gt;」&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/UePSYB9.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;這樣工作列的圖示就變成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/XJHECgm.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;就是這樣！&lt;/p&gt;
&lt;p&gt;另外如果對這些選項仍然不滿足的朋友，也可以右鍵開啟&lt;strong&gt;進階選項&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/TrJ7IhJ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;像我就有開啟大 icon，看了就是比較舒服&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/oTshGL4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;另外也能自訂一些滑鼠操作、鍵盤快速鍵等等，能微調的地方蠻多的，很適合有興趣的朋友可以自己研究看看。另外也要感謝巴哈的這篇 &lt;a href=&#34;https://forum.gamer.com.tw/C.php?bsn=60030&amp;amp;snA=525114&#34;&gt;徹底爆改&lt;/a&gt; 多挖了很多小玩具可以玩，哈。&lt;/p&gt;
&lt;p&gt;那麼今天就介紹到這裡，絕對不是玩小工具和逛耶誕城結果就廢掉沒寫文囧，抱歉啦催稿的碰油，我們下次見～&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>讀《離開公司，我過得還不錯》</title>
      <link>https://igouist.github.io/post/2020/11/i-am-doing-well-after-leaving-the-company/</link>
      <pubDate>Sun, 29 Nov 2020 23:54:06 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/11/i-am-doing-well-after-leaving-the-company/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/8QX3RPd.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;無論喜不喜歡自己的工作，都應該好好思考自己和工作的關係，畢竟每天花三分之一的時間做這件事，如果和它處得不好，人生也不可能會變好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這本書並不是那種精神勝利法，又或是超猛接案全攻略之類的書；反而給我的感覺比較像是作者藉著這本書，分享他這一路摸索的心得，和遭遇到的一些困難，看的時候有種像在和作者聊聊天的感覺。&lt;/p&gt;
&lt;p&gt;也因為這本書比較接近作者分享他選擇的道路、內容比較廣雜，遇到的部分都稍微說一些，但不是那種針對某個議題深入探討的書籍，所以比較適合想稍微了解自由工作的朋友閱讀。同時也必須了解到，自由工作者也只是眾多職業道路的其中一種，每個人的條件也不盡相同，因此抱持著好奇的心情閱讀，會更有收穫的感覺。&lt;/p&gt;
&lt;p&gt;從 &lt;a href=&#34;https://www.books.com.tw/products/0010810277&#34;&gt;博客來&lt;/a&gt; 的書籍簡介就可以看到，目錄真的把自由工作遇到的議題都碰了一些：從適不適合接案工作，到報稅、勞保、合約、工作場所都聊了一點。因為真的挺廣的，這邊我就只記錄一些我比較感興趣的話題。&lt;/p&gt;
&lt;h2 id=&#34;我們和工作之間的關係&#34;&gt;我們和工作之間的關係&lt;/h2&gt;
&lt;p&gt;本書最開始的時候作者敘述了他踏入自由工作的歷程：太過熱情工作、燃燒殆盡、失去熱情、休養了一年，最後重新思考人與工作之間的關係，才決定踏上接案的道路。&lt;/p&gt;
&lt;p&gt;就像我這篇文章決定引用作者前輩說過的話作為開場，我也相當認同：&lt;strong&gt;不管你做什麼，工作在大多數人的生命中都佔了不少的份量&lt;/strong&gt;。但我們真的有好好思考過我們和工作之間的關係嗎？有思考我們為什麼工作、想要什麼工作、適合什麼工作嗎？只要曾經思考過這些問題，就會明白我們和工作之間的關係，其實就是我們和生活之間的關係。而我們想要的工作，就是我們想要的生活。&lt;/p&gt;
&lt;p&gt;當作者的前言問說：「總是人去符合職位的要求，把我們原本奇怪的形狀塞進方方正正的外框，身處職場當然不可能完全舒服，但，有沒有可能換個角度，從自己原本奇怪的形狀延伸，慢慢長出各種不同的工作」這倒讓我好像看到了 &lt;a href=&#34;https://igouist.github.io/post/2020/06/darkhorse&#34;&gt;黑馬思維&lt;/a&gt; 的影子，黑馬思維也是要求我們要先了解自己的微動力，再根據自身去選擇策略。&lt;/p&gt;
&lt;p&gt;因此，當作者接著說明上班的心態和接案的心態：上班打混過了一天也是一天的薪水，但接案為了生存就會講究效率；但上班相對比較穩定，有安心感，接案則是有做有錢沒做沒錢，兩者之間對於效率和時間的意義相當不同。從這開始，其實也就區分了適合接案和適合上班的人們了。&lt;/p&gt;
&lt;p&gt;書中也有了一小段來接續這個話題，說明作者認為誰適合上班，誰又適合自由工作。上班相對於自由工作，有三個明顯的優勢：明確的社會位置、穩定的收入來源、勞基法保障的福利。因此，不確定想做什麼的朋友，或是喜歡穩定、安全的朋友就比較適合上班。&lt;/p&gt;
&lt;p&gt;反過來說，自由工作者必須了解自己在社會中的位置，用專業來取代職稱，在開始接案的時候，也得要先找一件有趣的事情開始做，其他任務才會找上門來。也因此最好有點存款，才能保留接案時的選擇權等等。所以比較適合能承受不穩定性，又或是有想持續追求的目標的人。&lt;/p&gt;
&lt;p&gt;要注意，這邊的承受不穩定性包含的心理和經濟能力等方面。例如作者的家人能夠經濟獨立，並且作者對工作的要求是能夠賺取生活所需的金錢讓他能夠自由做想做的事情即可，因此在衡量接案和上班之間的差異時，千萬別忘了要從自身的條件、想要的生活等方面開始估算。試著去想想兩者之間的條件，和自己比較傾向哪邊的生活。&lt;/p&gt;
&lt;p&gt;即使最後發現此路不可行，但就像書中說的：「&lt;strong&gt;光是從不同角度去思考工作和自己的關係，換個視野看看職場十字路口的風景，也都會有收穫。&lt;/strong&gt;」&lt;/p&gt;
&lt;h2 id=&#34;自由與不自由&#34;&gt;自由與不自由&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;自由意味著責任，正因為如此，多數人都懼怕自由。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;都說自由接案比較自由，但聽來聽去也不知道到底有多自由，曾經聽到唉呀那個接案的又出國玩啦，也曾聽到欸那個誰案子趕不完了好像三天沒睡了，總感覺這族群對我來說有點…太過動盪？所以「接案有多自由？」一直是我蠻有興趣的問題。&lt;/p&gt;
&lt;p&gt;作者在書中也列出了幾項接案工作者的自由和不自由，例如能夠隨心所欲安排時間、能夠自己選擇案子、可能自己調整工作內容等等。同時也會有偷懶就沒有收入，必須維持工作成果等壓力。&lt;/p&gt;
&lt;p&gt;但就像本節引用的這句「&lt;strong&gt;自由意味著責任&lt;/strong&gt;」，為了能夠隨心所欲安排時間，必須先學會時間規劃，必須要能夠遵守紀律；為了能夠自己選擇案子，必須要維持住經濟水準，也必須要磨練專案到擁有話語權；為了能夠自己調整工作內容，就必須好好思考過工作和生活的比例，必須自己找到目標。所有的自由相對都需要先有所付出，因此自由並不是比較簡單的道路，而是學會對自己負責，還有可能餓死。&lt;/p&gt;
&lt;p&gt;也因為這些責任，所以自由工作者必須具備一些能力，大多數作者都會在書中提到，例如：&lt;/p&gt;
&lt;p&gt;在財務管理方面，就不能像領薪水的上班族一樣，每個月五號十號無腦等錢入帳，必須主動按照專案去管理每一筆帳。&lt;/p&gt;
&lt;p&gt;而且&lt;strong&gt;通常是同時多個專案非同步地進行著&lt;/strong&gt;，例如Ａ專案做到一半Ｂ專案開始，同時手上還有Ｃ專案準備啟動會議等等，這些專案簽訂的合約、入賬的時機也都有可能不同。&lt;/p&gt;
&lt;p&gt;所以就必須學會掌握各個專案的進度和帳務狀況等等，所以自由接案者只能被迫好好學記帳，才能掌握住工作和款項的節奏，避免周轉不靈或是破產。&lt;/p&gt;
&lt;p&gt;同時，既然都有可能多個專案非同步地進行了，為了能夠自由地工作和生活，也就必須好好把工作狀況記錄下來，回顧和規畫整體的時間。&lt;/p&gt;
&lt;p&gt;就像公司前輩曾經說過的：&lt;strong&gt;能夠估算工時，也是工程師專業中的一環&lt;/strong&gt;。那麼保持對時間的敏感度，把主導權拉回自己身上，自然也是自由工作者的一項專業與責任吧。&lt;/p&gt;
&lt;p&gt;針對時間管理，作者認為應該從記錄開始，並提出了四個步驟：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每天記錄做了什麼&lt;/li&gt;
&lt;li&gt;每周歸納整體工作&lt;/li&gt;
&lt;li&gt;每月回顧時間使用狀況&lt;/li&gt;
&lt;li&gt;每年檢討新目標&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;說實在的，我看到這段不自主驚呼，這不是子彈筆記的精神嗎？因此這邊就不再贅言，直接丟幾篇對我影響比較大的時間管理文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.playpcesor.com/2015/07/calendar-project.html&#34;&gt;實作進攻型行事曆：學會留時間給自己的進度排程心法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/how-gipi-learn/iterate-your-week-schedule-81e1aa8843b2&#34;&gt;把週行事曆當專案管，實現每週自我迭代&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://readingoutpost.com/the-bullet-journal-method/&#34;&gt;看膩了繽紛的子彈筆記？手殘派科技人的6個月實踐心得&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然前面都計算了賺錢的效率，在選擇案子的時候，自然就會開始有所取捨。就如同書中所說的：什麼案子都接的話，跟在公司上班有什麼兩樣？&lt;/p&gt;
&lt;p&gt;因此，就會劃分出賺錢與不賺錢的案子、有興趣和沒興趣的案子，甚至感覺不太對勁的案子等等。&lt;/p&gt;
&lt;p&gt;在書中，作者的工作收入要求只要能維持生活即可，因此他會主動搭配賺錢的案子和比較有興趣的案子，讓自己邊維持生活又能有時間做有興趣的工作。&lt;/p&gt;
&lt;p&gt;關於案件的選擇和搭配這部份，畢竟比較吃個人經驗，我就沒什麼特別的心得。但書中有個建議仍然值得參考：&lt;strong&gt;請相信直覺&lt;/strong&gt;，當直覺有問題，那通常就真的有問題。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/2kTqFln.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;當你感覺到危，猶豫就會敗北。&lt;/p&gt;
&lt;p&gt;除了上面這三項以外，還有許多篇幅用來說明 工作場所、報價與合約等等，過於實際操作的部份，這邊就略過不提了。&lt;/p&gt;
&lt;h2 id=&#34;重新定義&#34;&gt;重新定義&lt;/h2&gt;
&lt;p&gt;書中最後的篇幅，作者用自己的看法重新定義了生活、職涯、退休、成功等等話題。&lt;/p&gt;
&lt;p&gt;其中有幾個部分我挺有興趣的，例如作者說：「在討論斜槓、自由工作時，有幾個前提條件得說清楚：只是兼差很多，卻沒有自己的熱情與專長，不能算斜槓；如果接一堆案子，卻沒有挑案子的自由、沒有安排時間的原則、說不出對工作和生活的想法，也稱不上是自由工作者。」&lt;/p&gt;
&lt;p&gt;無情的接案機器，似乎也跟爆肝上班族沒什麼兩樣，都一樣沒有自由。接著作者又問：能否不依賴公司，以個人名義在職場生存？&lt;/p&gt;
&lt;p&gt;從這些出發點思考，到「&lt;strong&gt;拿回人生的選擇權&lt;/strong&gt;」就是作者對自由工作者的「自由」下的定義。&lt;/p&gt;
&lt;p&gt;想要自由，也得先從思考生活和培養熱情、磨練專長開始。&lt;/p&gt;
&lt;p&gt;不過這就像是書中提到的：「自由工作者憑什麼生存？小說家尼爾蓋曼（Neil Richard Gaiman）說，&lt;strong&gt;才華洋溢、交件準時、人好相處，是三項重要能力&lt;/strong&gt;」並且，只要能符合其中兩項就足以好好生存了。&lt;/p&gt;
&lt;p&gt;但這些能力，和上面能夠自由的條件，不管放到自由工作者或是職場，我個人覺得都是適用的，因為這些就是個人的軟實力。所以，不論你選擇上班工作，或是自由接案，終究還是要走向自我成長。&lt;/p&gt;
&lt;p&gt;而成長的方向和道路何其多，又怎麼不讓人好好思考、好好摸索呢？&lt;/p&gt;
&lt;p&gt;最後謝謝這本書，算是讓我思考了一個新的方向。書中其實還介紹了蠻多作者的心得和自由工作的一堆眉眉角角，也推薦有興趣的朋友可以讀看看，當作了解自由工作的入門磚，多多少少也會有收穫的吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這本書，描述的就是我的嘗試方法、犯錯教訓，還有交換的代價。不過我摸索出來的道路，也只是解開工作謎團的其中一條路線而已，每個人都可以有自己的路線，而且比我的更寬廣自在才對。&lt;/p&gt;
&lt;p&gt;《離開公司，我過得還不錯：成為自由工作者的理想生活提案》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;延伸閱讀&#34;&gt;延伸閱讀&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.thenewslens.com/article/112375&#34;&gt;《離開公司，我過得還不錯》：能否不依賴公司，以個人名義在職場生存？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://imjanet.com/freelancer/&#34;&gt;閱讀心得｜離開公司，我過得還不錯 成為自由工作者的理想生活提案 劉揚銘 - JJ&amp;rsquo;S TRAVEL &amp;amp; LIFESTYLE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/unique-reader/%E9%9B%A2%E9%96%8B%E5%85%AC%E5%8F%B8-%E6%88%91%E9%81%8E%E5%BE%97%E9%82%84%E4%B8%8D%E9%8C%AF-b92a2bae0ac9&#34;&gt;離開公司，我過得還不錯！ - 優‧悅讀&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.books.com.tw/products/0010825335&#34;&gt;一人公司：為什麼小而美是未來企業發展的趨勢&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>菜雞抓蟲: 在 Amazon Linux AMI 安裝 .net Core 時卡在 Requires: openssl-libs</title>
      <link>https://igouist.github.io/post/2020/11/bugs-install-dotnet-core-on-amazon-ami-requires-openssl/</link>
      <pubDate>Sun, 22 Nov 2020 23:40:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/11/bugs-install-dotnet-core-on-amazon-ami-requires-openssl/</guid>
      <description>&lt;p&gt;最近遇到在 Amazon Linux AMI 要安裝 .net Core 3.1 環境的時候，會一直跳出&lt;br/&gt; &lt;code&gt;Requires: openssl-libs&lt;/code&gt; 而無法安裝的問題，儘管明明已經有 openssl 了，但還是解析失敗找不到依賴，過程一直碰壁，因此在這邊紀錄一下。&lt;/p&gt;
&lt;p&gt;過程中嘗試了安裝 openssl-libs（會找不到該套件）、下載 Dotnet 的 tar.gz ，再直接對執行檔下 Dotnet 指令起站台（雖然網站起得來，但執行者會是當下的登入身分，也就是 &amp;lsquo;&amp;rsquo;@連線進來的IP-伺服器位置，而非由本機執行。後續如果有連線資料庫等檢查權限的地方就很容易出錯）&lt;/p&gt;
&lt;p&gt;最後在 Dotnet Core 的 issue 翻到這篇 &lt;a href=&#34;https://github.com/dotnet/core/issues/930&#34;&gt;Cannot install .NET Core 2.0 on Amazon Linux AMI&lt;/a&gt; 才成功解決。&lt;/p&gt;
&lt;p&gt;首先先將 openssl-libs 的 SPEC 抓下來，然後給 RPM 建置一下。這兩句可以參考一下這篇 &lt;a href=&#34;https://medium.com/linux-%E9%96%8B%E7%99%BC%E5%85%A5%E9%96%80/rpm-%E6%89%93%E5%8C%85-%E7%94%B1%E4%B8%80%E7%AB%85%E4%B8%8D%E9%80%9A%E5%88%B0%E5%8B%95%E6%89%8B%E6%BF%AB%E7%94%A8-%E4%BA%8C-df9eea70bd7b&#34;&gt;RPM 打包︰由一竅不通到動手濫用 (二)&lt;/a&gt; 的說明。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;wget https://github.com/dotnet/core/files/2186067/openssl-libs-ami.spec.txt
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rpmbuild --bb openssl-libs-ami.spec.txt
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接著我們去把打包好的 openssl-libs 安裝起來，路徑可能會有不同，所以記得先用 find 找一下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo find / -iname RPMS
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo rpm -i /usr/src/rpm/RPMS/x86_64/openssl-libs-1.0.0-0.x86_64.rpm
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;到這邊應該就解決標題遇到的問題囉！讓我們回到安裝的正軌&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo yum install -y powershell
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo yum install dotnet-sdk-3.1.0
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最後就可以 &lt;code&gt;dotnet&lt;/code&gt; 試試囉！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (13): 介面隔離原則</title>
      <link>https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle/</link>
      <pubDate>Sun, 15 Nov 2020 12:00:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/itHN6VZ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;今天要記錄的是介面隔離原則，顧名思義是和介面高度相關的原則。因此在閱讀本篇之前，可能需要先對 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;介面&lt;/a&gt; 有一點了解呦。&lt;/p&gt;
&lt;p&gt;事情就從上一篇 &lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;里氏替換原則&lt;/a&gt; 的鳥類物流公司開始說起。老闆痛定思痛，決定先用&lt;strong&gt;介面&lt;/strong&gt;先規定好物流士們的應徵條件，例如裝貨、卸貨、飛行、必須有帥氣的喙等等。&lt;/p&gt;
&lt;p&gt;這道命令下來後，倉庫們的企鵝都慌了，來檢查的編譯器瘋狂跳出 Error:「您未實作 IBird 的 Fly() 方法！」這下怎麼辦呢，為了要保住飯碗，企鵝們就必須實作出飛行才行，可是企鵝真的就不會飛呀！&lt;/p&gt;
&lt;p&gt;這下子企鵝們只剩下兩個選擇：不實作飛行，但是就不能被當成物流士，最後就會被開除；或是……空實作。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Penguin&lt;/span&gt; : IBird
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Fly()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// Do nothing;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;企鵝們終於騙過了編譯器檢查員，然而當送貨的命令下來之後，企鵝們再一次卡在倉庫門口發呆，最終物流公司仍然踏上了虧損的老路，再度面臨倒閉危機…&lt;/p&gt;
&lt;h2 id=&#34;介面隔離原則interface-segregation-principle&#34;&gt;介面隔離原則（Interface Segregation Principle）&lt;/h2&gt;
&lt;p&gt;不知道大家對企鵝遇到的狀況有沒有經驗呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;當介面規定了太多要求，而我們實作的子類別只需要其中一部份，或是有些要求根本無法達成，就會發生這個困境：放棄實作介面，或是用空實作和錯誤處理去欺騙介面&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如資料庫存取的介面要求太多和當下資料庫過於一致的方法，結果替換資料庫的時候導致部份方法實作不出來；或是像 &lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-4_interface-segregation-principleisp-%E4%BB%8B%E9%9D%A2%E9%9A%94%E9%9B%A2%E5%8E%9F%E5%89%87/&#34;&gt;俺同事文章&lt;/a&gt; 中的例子，交通工具的介面要求能開關車門，結果電動機車無法實作。&lt;/p&gt;
&lt;p&gt;然而，如果我們選擇用空實作或是拋出錯誤的方式，去欺騙介面，等到需要呼叫該方法的時候，就會發生許多非預期的錯誤。甚至讓接手程式碼的人在什麼都不知道的情況之下就讓系統掛掉。聰明的朋友們一定發現了，這就是違反了 &lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;里氏替換原則&lt;/a&gt;！&lt;/p&gt;
&lt;p&gt;為了迴避到處都是空實作地雷的結局，大前輩們就提出了介面隔離原則：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;不應該強迫用戶依賴它們未使用的方法&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這邊的用戶也就是我們的子類別，它們等同是這個介面的使用者。當我們必須強迫使用者去實作一些他們不需要的方法時，就代表了一個事實：我們的介面太「胖」了！裡面的某些要求可能是非必要的，以至於造成了實作上的冗餘。&lt;/p&gt;
&lt;p&gt;也基於這條原則延伸出了一個方向：&lt;strong&gt;應該最小化類別與類別之間的介面&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;介面也要單一職責&#34;&gt;介面也要單一職責&lt;/h2&gt;
&lt;p&gt;但是，我們要怎麼知道是我們設計的介面太胖，還是子類別在偷懶呢？又要怎麼知道我們的介面設計是否已經「最小化」呢？&lt;/p&gt;
&lt;p&gt;那就是 &lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;單一職責原則&lt;/a&gt; 出場的時候了。一個合理的介面設計是能夠符合單一職責原則的，反過來說，我們可以用單一職責原則來檢視我們的介面設計是否良好。&lt;/p&gt;
&lt;p&gt;當我們設計介面的時候，或是像上面遇到必須空實作的時候，就可以思考一下：&lt;strong&gt;這個介面的職責是否單一？這個介面的意圖是什麼？這個介面是否只對一個角色負責、只有一個原因改變？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;當我們的介面符合單一職責、足夠 &lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;內聚&lt;/a&gt; 的時候，我們自然就能夠說這個介面已經足夠精簡了。&lt;/p&gt;
&lt;h2 id=&#34;用組合實現功能&#34;&gt;用組合實現功能&lt;/h2&gt;
&lt;p&gt;有些人可能就會有點疑惑了：「但是我就是需要這個功能呀，如果我不塞在介面，要放去哪呢？」&lt;/p&gt;
&lt;p&gt;很簡單，&lt;strong&gt;放去另一個該職責的介面就可以了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;和繼承需要注意的部分一樣，濫用介面也是濫用繼承，我們應該用&lt;strong&gt;組合&lt;/strong&gt;去實現功能而不是用繼承去綁死功能。一個資料串列能做的功能可能相當多，但我們並不需要一次就要求實現全部能做的事情，而是將這些工作分組，再從中組合出我們需要的部份。&lt;/p&gt;
&lt;p&gt;此處以 C# 來說，例如我們很常接觸的 &lt;code&gt;List&lt;/code&gt; 類別，並不是只實作了 &lt;code&gt;IList&lt;/code&gt;，而是實作了 &lt;code&gt;ICollection&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;IEnumerable&lt;/code&gt;, &lt;code&gt;IList&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;IReadOnlyCollection&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;IReadOnlyList&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;ICollection&lt;/code&gt;, &lt;code&gt;IList&lt;/code&gt; 這些介面，層層堆疊，相互嵌合。&lt;/p&gt;
&lt;p&gt;那我們就知道 List 由這些介面「組合」而成，也知道了我們 List 具有這些介面要求的能力，讓我們能在合適的時候使用這個類別。同時又保留了這些介面能搭配出另一種組合的彈性，例如 &lt;code&gt;Array&lt;/code&gt; 就是由 &lt;code&gt;ICollection&lt;/code&gt;, &lt;code&gt;IEnumerable&lt;/code&gt;, &lt;code&gt;IList&lt;/code&gt;, &lt;code&gt;IStructuralComparable&lt;/code&gt;, &lt;code&gt;IStructuralEquatable&lt;/code&gt;, &lt;code&gt;ICloneable&lt;/code&gt; 組合而成。&lt;/p&gt;
&lt;p&gt;就像可能有位大神，名片一拿出來就是一串「程式設計師／架構師／攝影師／貓奴」，&lt;strong&gt;我們的類別也要懂得斜槓&lt;/strong&gt;。如此一來類別就比較不容易被介面綁死，也能因應不同場合來決定身分，從「每次都被逼著買套餐可是又不喜歡小菜」變成「餐餐自由配」，組合就該如此自由！&lt;/p&gt;
&lt;p&gt;回到開頭的例子，把想要的行為全部定義在一個介面裡，然後用一個類別去實現它遇到不需要的動作就詐騙介面，是相當不 OK 的；而是應該&lt;strong&gt;把想要的行為用職責的角度去思考&lt;/strong&gt;，根據職責建立成一或多個介面。然後只&lt;strong&gt;挑選&lt;/strong&gt;並實作該類別需要的動作（介面），如此就可以讓介面不再臃腫，而是變得靈活。&lt;/p&gt;
&lt;p&gt;就像是武術秘笈中的招式，其實也是一連串的動作所組成；所謂的功能，其實也是一連串行為所組成的。既然行為組合成了功能，我們也要從組合的角度去思考如何建立類別。&lt;strong&gt;組合就像是積木一樣&lt;/strong&gt;，我們用積木堆疊來完成作品，同時每個積木又可以各自靈活運用。&lt;/p&gt;
&lt;p&gt;而積木也分成了好用的積木，和很難使用的積木，在程式中可以從夠不夠 SOILD 看出來。不好用的那些用起來會覺得卡卡的，測試也很難寫；好用的則會讓你面對變化的時候，就像拆裝樂高一樣順手方便。聰明的朋友可能聯想到了，這就是 &lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;開放封閉原則&lt;/a&gt; 中我們提過的模組化。&lt;/p&gt;
&lt;p&gt;通常來說積木的形狀越複雜、體積越大，就越難以靈活使用，介面也是如此，因此我們在設計介面的時候，要謹記&lt;strong&gt;介面隔離原則&lt;/strong&gt;，利用我們在單一職責原則、里氏替換原則學到的原則來檢驗我們的介面，如此就可以迴避相當多尷尬兩難的實作場面，也能讓介面的使用更加靈活。&lt;/p&gt;
&lt;p&gt;那麼，在結束之前，有興趣的朋友可以跟我一起想一想：介面隔離原則，只適用於設計類別架構時的介面嗎？其他的介面（Interface）呢？例如 &lt;a href=&#34;https://igouist.github.io/post/2021/05/newbie-2-webapi&#34;&gt;API&lt;/a&gt;，是不是也可以按照介面隔離原則的精神下去設計呢？&lt;/p&gt;
&lt;h2 id=&#34;後日談&#34;&gt;後日談&lt;/h2&gt;
&lt;p&gt;企鵝詐騙介面的事情終究還是暴露了。&lt;/p&gt;
&lt;p&gt;但是這群企鵝的夢想就是成為物流士，老闆也狠不下心把牠們趕走。&lt;/p&gt;
&lt;p&gt;「也許……」&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%B0%8F%E9%BB%84%E9%B8%AD%E8%B0%83%E8%AF%95%E6%B3%95&#34;&gt;鴨子顧問&lt;/a&gt;說：「我們可以有別的方法。只要使用&lt;strong&gt;介面隔離原則&lt;/strong&gt;。」&lt;/p&gt;
&lt;p&gt;老闆：『介面隔離？怎麼做呢？』&lt;/p&gt;
&lt;p&gt;「我們可以把送貨放到 IDelivery，然後讓他們用不同的介面來實作移動方式，例如 IFly、ISwim、IRun 等等。用&lt;strong&gt;組合&lt;/strong&gt;的方式來完成不同種類的物流士類別，這樣就可以有很多種送貨方式了」&lt;/p&gt;
&lt;p&gt;『原來如此，不只是空運 —— 我們要征服陸海空嗎！』&lt;/p&gt;
&lt;p&gt;改變作法的鳥禽物流公司搖身一變成了動物物流公司，同時廣徵天下動物，除了企鵝也能從南極發貨中心快速運貨以外，公司還招到了明星成員獵豹物流士，從此蒸蒸日上、強勢打入各大物流市場，最後進軍宇宙。可喜可賀，可喜可賀。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列下一篇：&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@f40507777/%E4%BB%8B%E9%9D%A2%E9%9A%94%E9%9B%A2%E5%8E%9F%E5%89%87-interface-segregation-principle-isp-6854c5b3b42c&#34;&gt;介面隔離原則 Interface Segregation Principle (ISP) - Finn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10192464&#34;&gt;SOLID 之 介面隔離原則（Interface segregation principle）- Miles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/hatelove/2010/10/17/interface-segregation-principle&#34;&gt;91 之 ASP.NET 由淺入深 不負責講座 Day20 - ISP 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://daydaynews.cc/zh-tw/technology/346506.html&#34;&gt;設計模式之美十六：介面隔離原則有哪三種應用？介面該如何理解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yncbearz.github.io/2020/06/03/Interface-Segregation-Principle/&#34;&gt;介面隔離原則 - YNCBearz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-4_interface-segregation-principleisp-%E4%BB%8B%E9%9D%A2%E9%9A%94%E9%9B%A2%E5%8E%9F%E5%89%87/&#34;&gt;Object Oriented物件導向設計原則SOLID-4:Interface Segregation Principle(ISP) 介面隔離原則 - Sian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tenlong.com.tw/products/9789864342099&#34;&gt;《無瑕的程式碼：物件導向原則、設計模式與C#實踐》&lt;/a&gt; Ch.12 ISP：介面隔離原則&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同系列文章&#34;&gt;同系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Dark Reader —— 暗黑模式愛好者的 Chrome 必備套件</title>
      <link>https://igouist.github.io/post/2020/11/dark-reader/</link>
      <pubDate>Sun, 08 Nov 2020 23:39:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/11/dark-reader/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/G4OjUzE.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不能信任那些 Terminal 或編輯器用白底的人。&lt;/br&gt;
—— &lt;a href=&#34;https://github.com/CodeTengu/JokeKappa/blob/master/jokekappa/jokes/codetengu_weekly.json&#34;&gt;JokeKappa&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這禮拜推薦了個常用的 chrome 套件給同樣喜歡黑色背景的同事，這邊也推薦給大家。&lt;/p&gt;
&lt;p&gt;&lt;s&gt;絕對不是因為隻狼更新了不小心砍太爽，結果來不及寫介面隔離只能介紹套件水一下，Heiya～&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;今天要介紹的就是這款 &lt;a href=&#34;https://chrome.google.com/webstore/detail/dark-reader/eimadpbcbfnmbkopoojfekhnkhdbieeh&#34;&gt;Dark Reader&lt;/a&gt;，這是我用 chrome 時首選的暗黑模式擴充套件，在俺寫文的這時候已經超過了三百萬次的下載次數，現在就讓我來記錄一下這款擴充套件的一些特色唄。&lt;/p&gt;
&lt;p&gt;照慣例先上個預覽圖：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/OOEraiY.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;當我們安裝完成之後，就可以從 Chrome 右上角的擴充套件區看到 DarkReader 的 icon。點開就可以看到它的選單：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/rveo4TK.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;由上而下分別就是最常用的主要調整，左上角可以選擇是否套用，右上則是套件開啟關閉和快捷鍵。接著是一些對比度、亮度等等的調整，可以隨著個人喜好條找到舒適的程度。&lt;/p&gt;
&lt;p&gt;其中我覺得最中意的就是最下面的「&lt;strong&gt;僅適用於ＯＯＯ&lt;/strong&gt;」的功能，這代表我們可以將上面的設定&lt;strong&gt;僅僅針對某個特定網站作變更&lt;/strong&gt;，而不會遇到在Ａ網站辛辛苦苦調整後覺得順眼了，結果到了Ｂ網站同樣的配置卻相當刺眼的狀況。&lt;/p&gt;
&lt;p&gt;如此一來，對於某幾個常用的網站，我們完全可以自主微調再套用，甚至針對一些不太適合轉黑色的網站也能夠選擇關閉，這個彈性對我來說是相當實用的功能，幾乎是我最後愛用這款暗黑模式套件的主因。&lt;/p&gt;
&lt;p&gt;這些紀錄是否要開啟黑色模式的網站，就會記錄在第二個「網站列表」的頁籤。雖然可以手動增加，但我個人是不常用到，在首頁設定即可。&lt;/p&gt;
&lt;p&gt;而在第三個「更多」的頁籤，就有一些有趣的設定可以調整了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/2IMcXW4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;首先是文字描邊的部分。由於黑暗主題下的白色字會 &lt;a href=&#34;https://www.u-walker.com/news/2464.html&#34;&gt;讓人覺得字的筆劃較粗&lt;/a&gt;，因此大多時候字體就會經過調整。但如果覺得太超過了太細怎麼辦呢？這邊可以調整&lt;strong&gt;文字描邊&lt;/strong&gt;，讓字看起來不要看不見，也不要過眩過粗。&lt;/p&gt;
&lt;p&gt;再往下則是有四種模式可以設定，預設是動態模式，這邊直接上圖給各位感受一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;過濾
&lt;img src=&#34;https://i.imgur.com/6I58vhi.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;過濾+
&lt;img src=&#34;https://i.imgur.com/FvCr7iQ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;-靜態
&lt;img src=&#34;https://i.imgur.com/NISE8xa.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;-動態
&lt;img src=&#34;https://i.imgur.com/sQ6YreP.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中靜態會有一個編輯畫面，可以自己加入 CSS 達到完全客製。&lt;/p&gt;
&lt;p&gt;而動態則是就交給 Dark Reader 幫你算，像我這種懶人仔就是一路動態到底；像我這種會喜歡 &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme&#34;&gt;One Dark Pro&lt;/a&gt; 主題，這類非純黑、漸層質感配色的人，動態的結果也比較符合我的口味
。&lt;/p&gt;
&lt;p&gt;當然，動態產生的 CSS 也是能修改的，點選下面的開發者工具就可以看到完整的 CSS 囉。像本部落格也是基於 &lt;a href=&#34;https://github.com/flysnow-org/maupassant-hugo&#34;&gt;maupassant&lt;/a&gt; 這款好看的白色主題，再加上 Dark Reader 處理後產生的暗黑模式當底來逐步修改出來的。這方面真的要感謝製作主題和套件的大大們呢。&lt;/p&gt;
&lt;p&gt;今天的介紹就到這裡囉，推薦喜歡暗黑模式又想懶人用套件的朋友可以試試這款套件，真的相當好用！那麼，我們下次見～&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (12): 里氏替換原則</title>
      <link>https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle/</link>
      <pubDate>Sun, 01 Nov 2020 11:31:44 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ZAuxFRy.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;里氏替換原則-liskov-substitution-principle&#34;&gt;里氏替換原則 (Liskov Substitution Principle)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;子類別必須能夠替換父類別&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;里氏原則還包含了一個概念：子類別替換父類別後，&lt;strong&gt;不需要改變，也不會發生任何錯誤或異常&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;從定義就可以看出來，這項原則是來替我們處理繼承問題的。因此，在開始本篇之前，可能需要先對 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;繼承&lt;/a&gt; 以及 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;多型&lt;/a&gt; 有基本的認識。如果可以的話，也請先看過 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;介面&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;那麼，就讓我們從很久很久以前開始說起…&lt;/p&gt;
&lt;h2 id=&#34;我的子類別進入叛逆期了怎麼辦&#34;&gt;我的子類別進入叛逆期了，怎麼辦？&lt;/h2&gt;
&lt;p&gt;很久很久以前，有一間公司受到 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%BB%A5%E9%B8%9F%E7%B1%BB%E4%B8%BA%E8%BD%BD%E4%BD%93%E7%9A%84%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE&#34;&gt;鴿子封包&lt;/a&gt; 所啟發，打算發展鳥類運輸技術，強勢打入無人機市場，用生物智慧掀起對人工智慧的革命。既然&lt;strong&gt;鳥類都會飛行&lt;/strong&gt;，理所當然可以藉由飛行來進行空運，甚至還可以偷偷擊墜那些無人機對手，野心勃勃的老闆立馬徵了一批鳥類物流士，打出「凡是鳥類都可應徵」的旗號，各式各樣的猛禽響應而來，一時之間掀起整個物流業的風暴！&lt;/p&gt;
&lt;p&gt;但是好景不常，公司營運之後發貨狀況不佳，頻繁發生丟包問題，甚至有些貨根本就出不了倉庫，虧損越來越大，心急如焚的老闆下令徹查，這才發現—&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;企鵝是鳥，企鵝不會飛&lt;/strong&gt;。一堆企鵝在倉庫門口發呆。&lt;/p&gt;
&lt;p&gt;但是一切已經來不及，虧損已經造成，這家鳥禽物流公司最後也慢慢消失在塵埃之中……&lt;/p&gt;
&lt;p&gt;這個故事告訴我們：如果子類別（企鵝）沒有達到我們對父類別（鳥）的期待，就很容易在不知不覺中出事！&lt;/p&gt;
&lt;p&gt;我們已經預期了「鳥＝會飛行」這個前提，但繼承的企鵝卻無法實作飛行，如此就會讓我們被誤導、在使用時&lt;strong&gt;誤入陷阱&lt;/strong&gt;。這種子類繼承時搞叛逆，和父類別行為相違所發生的問題，難以預期也難以察覺，絕對是我輩不能容忍的。因此，里氏替換原則就出現了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;註：感謝這篇 &lt;a href=&#34;https://medium.com/@f40507777/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8F%9B%E5%8E%9F%E5%89%87-liskov-substitution-principle-adc1650ada53&#34;&gt;里氏替換原則 Liskov Substitution Principle (LSP) - Finn&lt;/a&gt; 的附圖，我之後就想不出比企鵝更貼切的例子了囧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;所以我們該如何遵守里氏替換原則&#34;&gt;所以，我們該如何遵守里氏替換原則？&lt;/h2&gt;
&lt;p&gt;我們再提一次：子類別必須要能替換掉父類別，而&lt;strong&gt;不需要改變&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我們在 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;多型篇&lt;/a&gt; 的時候提過「用子類別實作出各式各樣不同的方法，藉此讓父類別的方法藉此達到延伸和多樣化的效果」如此我們的物件彼此之間才能保持彈性，擁有可替換可擴充的特性，進而達到 &lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;開放封閉原則&lt;/a&gt; 所要求的：&lt;strong&gt;對修改封閉（不需要修改使用到父類別的地方），對擴展開放（而是只需要用子類別進行擴充，就能完成變動）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然而，這個擴展不該是天馬行空隨便亂擴的，必須要有原則。&lt;/p&gt;
&lt;p&gt;最首要的就是：至少&lt;strong&gt;父類別能做到的事情，子類別也要能做到&lt;/strong&gt;，不能說今天換成子類別就整組壞光光。畢竟，如果原本的東西變少了或壞掉了，那就不叫延伸了，對吧？&lt;/p&gt;
&lt;p&gt;也就是說，一個好的擴展方式，應該能滿足這些條件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要求不應該比父類別多&lt;/li&gt;
&lt;li&gt;回饋不應該比父類別少&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如說：爸爸每天都去市場賣香蕉，一支二十，數十年間颳風下雨從未改變。某一天爸爸生病，不想打破這個傳統，就請兒子去代班。這時：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;熟客們知道一支是二十元，他們順路來買香蕉的時候也只會準備二十元。&lt;br/&gt;
所以，兒子不能隨便亂漲價到五十元，因為客人也拿不出來，而且臨時漲價還會被留負評&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;熟客們知道給了錢就可以拿到香蕉，他們給了錢之後就會等著老闆把香蕉給他們。&lt;br/&gt;
所以，兒子不能今天收了人家二十元，然後只給半支香蕉，客人會很傻眼，攤子會很危險&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些熟客，其實就是我們工程師。&lt;strong&gt;我們預期了這個函式或類別需要準備的輸入參數，也預期了應該要有的輸出結果。如果某一天替換了子類別，卻不是這麼一回事，就會發生很多意料外的錯誤&lt;/strong&gt;。對買香蕉這件事而言：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;給足夠的錢就是所謂的「前置條件」或「先驗條件」&lt;/li&gt;
&lt;li&gt;預期拿到香蕉就是「後置條件」或「後驗條件」，&lt;/li&gt;
&lt;li&gt;每天都會去市場賣香蕉就是「不變條件」&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此當我們想要符合里氏替換原則時候，其實就可以試著遵守這幾條規則：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先驗條件不可以強化&lt;/strong&gt;：&lt;br/&gt;
父類別要求的是矩形，子類別就不能要求得更嚴，只准人家給正方形&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;後驗條件不可以弱化&lt;/strong&gt;：&lt;br/&gt;
父類別產出的是正方形，子類別不能說沒關係啦，就給人家隨便一個矩形&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不變條件必須保持不變&lt;/strong&gt;：&lt;br/&gt;
父類別是一個產生矩形的方法，子類別不能背骨，跑去產生圓形&lt;/p&gt;
&lt;p&gt;只要確保了&lt;strong&gt;輸入和輸出都是一致的&lt;/strong&gt;，就可以減少很多神奇妙妙問題。這個也就是所謂的&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%A5%91%E7%BA%A6%E5%BC%8F%E8%AE%BE%E8%AE%A1&#34;&gt;契約式設計 (Design By Contract)&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;稍微想一想你可以不要隨便繼承&#34;&gt;稍微想一想，你可以不要（隨便）繼承&lt;/h2&gt;
&lt;p&gt;有沒有發現，這個契約式的描述，和我們提過的 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;介面&lt;/a&gt; 概念是不是很像呢？可以稍微想一想：&lt;strong&gt;介面和繼承&lt;/strong&gt;間的關係，以及&lt;strong&gt;介面與里氏替換原則&lt;/strong&gt;的關係。&lt;/p&gt;
&lt;p&gt;首先，為什麼我們要使用繼承呢？如果只是為了減少重複程式碼，那實在是，呃，相當不建議。&lt;/p&gt;
&lt;p&gt;這邊需要了解一個觀念：&lt;strong&gt;我們不應該因為單純的「IS-A」就濫用繼承，那樣是危險的&lt;/strong&gt;。企鵝「是」鳥類、正方形「是」矩形，在想法上似乎是沒有問題的，但是貿然繼承就會遇到「企鵝不會飛」、「正方形四邊等長」等問題，讓實作上有種綁手綁腳的感覺。&lt;/p&gt;
&lt;p&gt;真正的繼承應該是基於行為的：&lt;strong&gt;這個子類別能不能做到父類別期望的行為&lt;/strong&gt;？這才是里氏替換原則的核心。&lt;/p&gt;
&lt;p&gt;不要用繼承去掠奪父類的程式碼，而是把目光放在行為，試著去思考父類別期望的行為是什麼、哪些是不可變的；期望的前置條件、後置條件，也就是輸入和輸出又代表什麼。&lt;/p&gt;
&lt;p&gt;當我們需要繼承時，就稍微想一想，把&lt;strong&gt;觀看物件的角度集中在它的功能上，去試著了解父類別所期望的繼承方式，和使用者期望的預期結果&lt;/strong&gt;。如此一來，我們自然就會朝向遵守契約式設計精神的&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;介面&lt;/a&gt;來取代繼承，又或是釐清功能之間的&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;職責&lt;/a&gt;，利用組合各個功能的子模組的方式來完成我們要的行為。&lt;/p&gt;
&lt;p&gt;放下繼承的包袱，了解繼承的原則，才能真正達到多型的精神，這就是里氏替換原則替我們指引出的方向。&lt;/p&gt;
&lt;p&gt;既然我們需要用到介面，那介面又有什麼要注意的地方呢？這就要到我們的介面隔離原則再聊了。欲知後續如何，且待下回分曉。&lt;/p&gt;
&lt;p&gt;那麼，我們下次見～&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文主要參考至這幾篇，建議想對里氏替換原則更了解的朋友可以閱讀一下呦：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://wadehuanglearning.blogspot.com/2019/12/blog-post_31.html&#34;&gt;物件導向設計原則：里氏替換原則，定義、解析 - WadeHuang的學習迷航記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/%E7%A8%8B%E5%BC%8F%E6%84%9B%E5%A5%BD%E8%80%85/%E4%BD%BF%E4%BA%BA%E7%98%8B%E7%8B%82%E7%9A%84-solid-%E5%8E%9F%E5%89%87-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8F%9B%E5%8E%9F%E5%89%87-liskov-substitution-principle-e66659344aed&#34;&gt;使人瘋狂的 SOLID 原則：里氏替換原則 (Liskov Substitution Principle) - 程式愛好者&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列下一篇：&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@f40507777/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8F%9B%E5%8E%9F%E5%89%87-liskov-substitution-principle-adc1650ada53&#34;&gt;里氏替換原則 Liskov Substitution Principle (LSP) - Finn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/%E7%A8%8B%E5%BC%8F%E6%84%9B%E5%A5%BD%E8%80%85/%E4%BD%BF%E4%BA%BA%E7%98%8B%E7%8B%82%E7%9A%84-solid-%E5%8E%9F%E5%89%87-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8F%9B%E5%8E%9F%E5%89%87-liskov-substitution-principle-e66659344aed&#34;&gt;使人瘋狂的 SOLID 原則：里氏替換原則 (Liskov Substitution Principle) - 程式愛好者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://teddy-chen-tw.blogspot.com/2012/01/4.html&#34;&gt;亂談軟體設計（4）：Liskov Substitution Principle - 搞笑談軟工&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wadehuanglearning.blogspot.com/2019/12/blog-post_31.html&#34;&gt;物件導向設計原則：里氏替換原則，定義、解析 - WadeHuang的學習迷航記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-5_liskov-substitution-principlelsp-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8F%9B%E5%8E%9F%E5%89%87/&#34;&gt;Object Oriented物件導向設計原則SOLID-5:Liskov Substitution Principle(LSP) 里氏替換原則 - Sian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%A5%91%E7%BA%A6%E5%BC%8F%E8%AE%BE%E8%AE%A1&#34;&gt;契約式設計 - 維基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tenlong.com.tw/products/9789864342099&#34;&gt;《無瑕的程式碼：物件導向原則、設計模式與C#實踐》&lt;/a&gt; Ch.10 LSP －－Liskov替換原則&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同系列文章&#34;&gt;同系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (11): 開放封閉原則</title>
      <link>https://igouist.github.io/post/2020/10/oo-11-open-closed-principle/</link>
      <pubDate>Sun, 25 Oct 2020 11:58:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/10/oo-11-open-closed-principle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/6pQOti2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;開放封閉原則-open-close-principle&#34;&gt;開放封閉原則 (Open-Close Principle)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;軟體實體（類別、模組、函式等等）應該對擴展開放，而對修改封閉&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我們了解什麼是「對擴展開放」和「對修改封閉」之前，先讓我們談談：什麼是擴展，什麼又是修改呢？&lt;/p&gt;
&lt;p&gt;用白話一點的方式來形容，修改就是把東西拆開來改，像是手術；而擴展就是對東西額外加裝模組，像是添購設備。我們用飛行來舉例，像是鳥類直接用翅膀飛行，如果有需要修改飛行方法的話就得對鳥直接進行手術；但如果今天是一個裝備了噴射背包的人，我們只需要把噴射背包換成噴射鞋子、甚至噴射翅膀就可以了，不需要去修改人這個本體。&lt;/p&gt;
&lt;p&gt;這邊可以發現開放封閉原則是針對「改變的時候」去做一個行動的建議，例如需求追加和變更等等。&lt;strong&gt;凡是變化都有成本&lt;/strong&gt;，例如變動的難易度、變動造成的影響範圍等等都會影響到成本，若是程式碼冗長、內部邏輯複雜，類別之間互相耦合、影響範圍很廣，導致綁手綁腳或壞東壞西等等狀況，使得修改很困難，成本就會變高，進而使得開發效率變低。&lt;/p&gt;
&lt;p&gt;然而，軟體並不是製造完畢就完工的東西，而是隨需求而生、隨需求而變的動態作品，因此程式碼的修改或重構相當頻繁。就像我們在 &lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;內聚耦合篇&lt;/a&gt; 提過的：軟體面對改變的能力，就像基因適應環境並生存下去的能力。因此，程式必須具有彈性，也就是需要盡可能降低修改的成本。&lt;/p&gt;
&lt;p&gt;那麼讓我們回到前面：動手術跟換道具，哪個的成本比較高呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;面對需求，對程式碼的改動是透過增加新程式碼進行的，而不是更改現有的程式碼&lt;/strong&gt;　　
&lt;br/&gt;（《大話設計模式》）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，我們希望能夠用擴充的方式去完成變化，而不是用針對內部進行修改的方式來做；希望藉由良好的設計，能迴避上面那串修改困難導致成本高昂的問題。&lt;/p&gt;
&lt;p&gt;而這個思路，其實你我都已經很習以為常了，就是&lt;strong&gt;模組化&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;模組化&#34;&gt;模組化&lt;/h2&gt;
&lt;p&gt;組裝電腦的時候，就是針對主機板加裝各種模組；寫程式的時候，我們也很習慣引入套件來使用；甚至使用 Visual Studio 或是 Chrome 這類軟體的時候，我們也都會使用擴充套件來加上我們需要的功能。甚至洛克人也是，我們打倒 BOSS 之後就能替洛克人加裝各種模組，讓他能夠具備各個 BOSS 的功能。噢當然我們不會把整台洛克人拆開然後改造成另一台，不然拆來拆去多麻煩。&lt;/p&gt;
&lt;p&gt;我們的周遭四處可見模組化，用模組來擴充本體的想法自古以來比比皆然。&lt;/p&gt;
&lt;p&gt;這邊就可以發現到：主機板上面事先會留好許多讓你接顯示卡或記憶體等等的插槽、Chrome 這類軟體會開放 API 和權限等功能給擴充套件來使用。當我們想要利用擴展的方式來擴充本體的能力時，我們需要留下一個供對接的地方，也就是&lt;strong&gt;擴充點&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;擴充點可以說是留給後人的貼心禮物（跟另一種留給後人的炸死人禮物並不相同）但是，我們要怎麼知道哪些地方可以擴充、可能擴充呢？我們可以先區分&lt;strong&gt;主要邏輯&lt;/strong&gt;和&lt;strong&gt;附加邏輯&lt;/strong&gt;，像是洛克人跟技能，你和噴射背包，又或者是「查詢客戶」的主邏輯和各種不同「查詢客戶的條件」等等的組合。&lt;/p&gt;
&lt;p&gt;因為如果不加以區分，我們就沒辦法把附加邏輯做成模組，也就找不到主要邏輯和附加邏輯之間的擴充點，如此一來就勢必要針對混成一坨的邏輯做修改和業務處理，接著就會落入我們在上一篇 &lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;單一職責原則&lt;/a&gt; 提過的各種悲慘下場：修改一個地方影響一狗票功能、修改前必須痛苦地閱讀大量不相關的程式碼…等等。&lt;/p&gt;
&lt;p&gt;這些問題，也正是&lt;strong&gt;單一職責原則&lt;/strong&gt;所要解決的。此處可以直接參考上一篇也引用過的 &lt;a href=&#34;https://wadehuanglearning.blogspot.com/2019/12/blog-post.html&#34;&gt;再談物件導向設計原則: 單一職責原則，定義、解析與實踐&lt;/a&gt; 這篇，裡面的學生列表例子就蠻直接好懂的。&lt;/p&gt;
&lt;p&gt;另外也必須推薦一下這位大大的 &lt;a href=&#34;https://wadehuanglearning.blogspot.com/2019/12/blog-post_11.html&#34;&gt;物件導向設計原則：開放封閉原則，定義、解析與實踐&lt;/a&gt; ，對業務邏輯和附加邏輯的說明也相當明確，從為什麼要隔離兩者，到如何實踐都有說明，值得一看。&lt;/p&gt;
&lt;p&gt;而我們辨認出主要邏輯跟附加邏輯之後，該怎麼實行開放封閉原則呢？&lt;/p&gt;
&lt;h2 id=&#34;實行&#34;&gt;實行&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;答案就是抽象。（《無瑕的程式碼：敏捷完整篇》）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這邊舉幾個方向：我們可以&lt;strong&gt;在主要邏輯和附加邏輯之間，加入抽象層來解耦合&lt;/strong&gt;，也就是我們 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;介面&lt;/a&gt; 大哥該出場的時候了。當我們的類別不再堅持依賴某個物件，例如說我就是要噴射背包，然後把背包黏死在背後；而是接受我只需要能飛的東西，不論傳遞進來的是噴射背包還是噴射鞋子，如此一來就夠用介面表達出需求，使得功能&lt;strong&gt;可以被任何符合需求的方式擴展&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;另外還有，使用外部注入來處理附加邏輯。除了不將附加邏輯寫在類別中，降低修改的機會以外，和介面的邏輯一致：你給什麼工具我就用什麼工具。當我們的附加邏輯是從外部丟給類別，使得類別預先留好擴充點，並且能由外部決定擴充方式，要擴展也就相當容易了。順便一提，我進公司學習以來，注入跟介面通常都是一起出現的 Combo 技。&lt;/p&gt;
&lt;p&gt;當我們在設置我們的擴充點（上個世紀稱作「放置鉤子」）時，有時會預測失敗，變成&lt;strong&gt;不必要的複雜性&lt;/strong&gt;。也很容易走火入魔，就變成&lt;strong&gt;過度設計&lt;/strong&gt;。因此，我們最終會等到足夠確信將會變化時，才進行重構的動作。&lt;/p&gt;
&lt;p&gt;在無瑕的程式碼中，建議可以接受「&lt;strong&gt;被愚弄一次&lt;/strong&gt;」，先假設不會變化，而當真的變化到來時，就將該變化相關的部份重構抽象起來，得了一次病，從此就免疫，還可以少走冤枉路。又或許，也可以嘗試看看 &lt;a href=&#34;https://shawnlin0201.github.io/Methodology/Methodology-004-Rule-Of-Three-principle/&#34;&gt;三次原則&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;結語&#34;&gt;結語&lt;/h2&gt;
&lt;p&gt;最後，開放封閉原則的範圍實在是太大了。事實上，其他設計原則，例如單一職責、依賴反轉等等，都是為了達到開放封閉這個終極的目標而產生的。但是，我們不可能預測到所有變化，也沒有任何做法能夠適用於所有狀況，因此要達到完全的封閉是不可能的。然而，這是我們應當嘗試精進的目標，只要謹記開放封閉原則，就能不斷改善架構，也就離良好的設計更進一步了。&lt;/p&gt;
&lt;p&gt;而對我而言，開放封閉的好處在於&lt;strong&gt;強迫像我這樣的工程師去思考：哪些地方是附加邏輯，哪些地方可以留作擴充，又該怎麼做才能方便擴充&lt;/strong&gt;，這個過程和嘗試對我輩菜鳥才是真正最有價值的地方吧。&lt;/p&gt;
&lt;p&gt;最後感謝一下 Ray 大大的路過指點。我當時問了不知道怎麼形容開放封閉原則，大大就說了個例子：咱們人哪，學新東西可是比改個性來得簡單多了。也基於這個例子讓我想到了手術和洛克人，還有變動的難易度、本性（核心邏輯）和新技能（附加邏輯）的差別可以這樣咻咻地串起來，這邊就謝過啦。順便也貼下大大的 &lt;a href=&#34;https://raychiutw.github.io/&#34;&gt;Blog&lt;/a&gt;，加減蹭一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列下一篇：&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jyt0532.com/2020/03/19/ocp/&#34;&gt;深入淺出開放封閉原則 Open-Closed Principle - jyt0532&amp;rsquo;s Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wadehuanglearning.blogspot.com/2019/12/blog-post_11.html&#34;&gt;物件導向設計原則：開放封閉原則，定義、解析與實踐 - WadeHuang的學習迷航記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/%E6%89%8B%E5%AF%AB%E7%AD%86%E8%A8%98/%E7%AC%AC-10-%E7%AB%A0-%E9%A1%9E%E5%88%A5-clean-code-1c7898d11cd7&#34;&gt;第 10 章 類別 | Clean Code 敏捷軟體開發技巧守則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://shawnlin0201.github.io/Methodology/Methodology-004-Rule-Of-Three-principle/&#34;&gt;程式設計心法 三次原則（Rule Of Three principle）- 璇之又璇的網路世界&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-2_open-close-principleocp-%E9%96%8B%E6%94%BE%E5%B0%81%E9%96%89%E5%8E%9F%E5%89%87/&#34;&gt;Object Oriented物件導向設計原則SOLID-2:Open-Close Principle(OCP) 開放封閉原則 - Sian&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同系列文章&#34;&gt;同系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>菜雞的 Markdown 筆記</title>
      <link>https://igouist.github.io/post/2020/10/markdown/</link>
      <pubDate>Sun, 18 Oct 2020 22:00:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/10/markdown/</guid>
      <description>&lt;p&gt;Markdown 是一種寫作用語言，特色是只要用簡單的符號就可以替文章進行排版，例如 &lt;code&gt;#&lt;/code&gt; 就代表了標題，因此能相當簡潔迅速地應用 Markdown 語法來撰寫出文件，目前已經被廣泛使用在各個撰寫文章或是文檔的場景中。&lt;/p&gt;
&lt;p&gt;例如 Github 用來說明專案的 Readme.md，從副檔名 md 就已經告訴你這是一篇 Markdown；又像是這個部落格的文章，也都是使用 markdown 來寫的。除此之外，像是 Facebook 和 Line 都開始支援簡單的 Markdown 語法了 —— 因為它實在是太方便好用了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用Markdown格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成 —— markdown.tw&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然用簡單的符號就能完成這些簡潔的排版，我們自然就能把專注的重心挪回到撰寫文章本身，這也就是 Markdown 最大的魅力：&lt;strong&gt;專注於內容&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;也因為 Markdown 的特色就是非常的簡潔乾淨，文檔本身的可讀性就相當的高，撰寫起來也很直覺容易。就如同其說明文件所說的：「Markdown 的目標就是實現『&lt;strong&gt;易讀易寫&lt;/strong&gt;』」&lt;/p&gt;
&lt;p&gt;這篇就來稍微紀錄一下 Markdown 的常用語法和好用的編輯環境吧！&lt;/p&gt;
&lt;h2 id=&#34;目錄&#34;&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%9B%AE%E9%8C%84&#34;&gt;目錄&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AA%9E%E6%B3%95&#34;&gt;語法&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A8%99%E9%A1%8C&#34;&gt;標題&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%86%E9%9A%94%E7%B7%9A&#34;&gt;分隔線&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%96%9C%E9%AB%94&#34;&gt;斜體&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%B2%97%E9%AB%94&#34;&gt;粗體&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%97%E8%A1%A8&#34;&gt;列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A0%B8%E5%8F%96%E6%96%B9%E5%A1%8A&#34;&gt;核取方塊&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BC%95%E7%94%A8&#34;&gt;引用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%80%A3%E7%B5%90&#34;&gt;連結&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9C%96%E7%89%87&#34;&gt;圖片&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A1%A8%E6%A0%BC&#34;&gt;表格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%A8%8B%E5%BC%8F%E7%A2%BC%E5%8D%80%E5%A1%8A&#34;&gt;程式碼區塊&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%B6%E4%BB%96&#34;&gt;其他&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A5%E5%85%B7&#34;&gt;工具&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#hackmd&#34;&gt;Hackmd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#typora&#34;&gt;Typora&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#visual-studio-code&#34;&gt;Visual Studio Code&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%B8%BD%E7%B5%90&#34;&gt;總結&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99&#34;&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;語法&#34;&gt;語法&lt;/h2&gt;
&lt;h3 id=&#34;標題&#34;&gt;標題&lt;/h3&gt;
&lt;p&gt;Markdown 中要加入標題，只需要在開頭加上 &lt;code&gt;#&lt;/code&gt; 就可以了。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 標題一 H1
## 標題二 H2
### 標題三 H3
#### 標題四 H4
##### 標題五 H5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/W20kTy7.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;或是使用底線標示的方式也可以告訴 Markdown 這是標題，例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;標題一 H1
========

標題二 H2
--------
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/q715Wbr.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;分隔線&#34;&gt;分隔線&lt;/h3&gt;
&lt;p&gt;如果是想區分段落，不想要輸入標題，也可以直接用分隔線 &lt;code&gt;---&lt;/code&gt;，但記得要空一行，不然會被誤認為標題，例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;我是紅海

---

我是紅海
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/cxLiHqU.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;斜體&#34;&gt;斜體&lt;/h3&gt;
&lt;p&gt;當我們需要斜體的時候，可以用 &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;_&lt;/code&gt; 來將文字包起來，例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;我是 *斜體* 啦！會有一點 _斜斜的_
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/PPq8IzB.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;粗體&#34;&gt;粗體&lt;/h3&gt;
&lt;p&gt;當如果需要強調某個語句或段落，則可以用 &lt;code&gt;**&lt;/code&gt; 或是 &lt;code&gt;__&lt;/code&gt; 來將文字包起來，例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;我是 **粗體** 啦！這一段 __很重要__ 哦！
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/IZXInCx.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;列表&#34;&gt;列表&lt;/h3&gt;
&lt;p&gt;列表分為有序和無序，其中有序的使用數字加上點來標示，例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1. 我是第一項
    1. 我是第一項的第一小項
    2. 我是第一項的第二小項
2. 我是第二項
3. 我是第三項
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/MZRCdPV.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;而無序清單則可以用 &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; 來標示，例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;- 蘋果
- 柳橙
- 香蕉
    - 香蕉？
    - 香蕉！
- 水蜜桃
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/O9kA2yG.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;核取方塊&#34;&gt;核取方塊&lt;/h3&gt;
&lt;p&gt;當我們需要建立待辦事項這類需要勾選的列表時，就可以考慮用核取方塊 &lt;code&gt;[ ]&lt;/code&gt; 和 &lt;code&gt;[x]&lt;/code&gt;：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;- [ ] 買蘋果
- [ ] 買柳橙
- [x] 買香蕉
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Ita9Wko.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;引用&#34;&gt;引用&lt;/h3&gt;
&lt;p&gt;需要引用某個片段或特別標示的時候，可以用 &lt;code&gt;&amp;gt;&lt;/code&gt;，例如：&lt;code&gt;&amp;gt; 我是一句名言&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;紙上得來終覺淺，絕知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大多數平台也會支援巢狀的用法，例如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;子非魚，安知魚之樂？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;子非我，安知我不知魚之樂？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/AdMF7DC.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;連結&#34;&gt;連結&lt;/h3&gt;
&lt;p&gt;需要加入連結的時候，可以使用 &lt;code&gt;[連結文字](網址)&lt;/code&gt;，例如當我要插入 Markdown.tw 的說明時就可以：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;請參見 [Markdown 語法說明](https://markdown.tw/)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/e8D1yFX.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;圖片&#34;&gt;圖片&lt;/h3&gt;
&lt;p&gt;當連結是圖片的時候，只需要在最前面加入 &lt;code&gt;!&lt;/code&gt; 變成 &lt;code&gt;![](圖片網址)&lt;/code&gt; 就可以囉，例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;![](https://avatars2.githubusercontent.com/u/16403463?s=460&amp;amp;u=fccdf65b21cb2dc5c544c3b473f135f00c574030&amp;amp;v=4)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就會跑出我家的貓（插入圖片也太難擷取成示意圖了吧，各位意會就好）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://avatars2.githubusercontent.com/u/16403463?s=460&amp;amp;u=fccdf65b21cb2dc5c544c3b473f135f00c574030&amp;amp;v=4&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;表格&#34;&gt;表格&lt;/h3&gt;
&lt;p&gt;表格應該是我在 Markdown 中覺得不太親切的東西了…&lt;/p&gt;
&lt;p&gt;其實就是要你直接畫一個表格出來（排版請見諒，已盡力）：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;| 水果名稱 | 好吃程度 | 昂貴程度 | 爆炸程度 |
| --- | --- | --- | --- |
| 蘋果 | 高 | 高 | 高 |
| 香蕉 | 中 | 低 | 無 |
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/yDwiiqK.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;也可以設定置中或靠右，例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;| 靠左 | 置中 | 靠右 |
| :--- | :---: | ---: |
| 芭樂 | 奇異果 | 蓮霧 |
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/EXSKe9T.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;程式碼區塊&#34;&gt;程式碼區塊&lt;/h3&gt;
&lt;p&gt;程式碼區塊使用反引號 &lt;code&gt;`&lt;/code&gt;，就是鍵盤左上角那個。如果只用一對把文字包起來就會是單行，例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;你可以使用 `Hello()` 這個語法來打招呼
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/HSlF7UZ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;而如果用三個反引號為一組，就可以產生程式碼區塊，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/fl5MDQs.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/MdtrbVx.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;有些平台會支援程式碼上色，這時候只要在第一組反引號後面加上程式語言就可以上色，例如
：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/BfrNXyR.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Main(&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;[] args)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Console.WriteLine(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello World!&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外有些平台也支援行號顯示，像 Hackmd 只需要在反組號的程式語言後加上等號就會顯示行號，例如 &lt;code&gt;csharp=&lt;/code&gt;，而我現在用的部落格主題，則是要到 config 統一配置才會顯示。&lt;/p&gt;
&lt;p&gt;由於 Markdown 力求簡潔，所以這些比較延伸的語法，通常需要看一下使用的編輯器是怎麼支援的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Xi48nAm.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;其他&#34;&gt;其他&lt;/h3&gt;
&lt;p&gt;另外隨著平台的支援，可能還有提供其他語法。例如用一或是兩個 &lt;code&gt;~&lt;/code&gt; 將文字包起來就常用於表達刪除號。提供寫作的平台多少都會有說明，開工前可以先翻翻看，畢竟語法糖不嫌多嘛。&lt;/p&gt;
&lt;h2 id=&#34;工具&#34;&gt;工具&lt;/h2&gt;
&lt;p&gt;接著讓我們介紹一些撰寫 Markdown 時的方便工具，以下這些是我比較常接觸的 Markdown 編輯環境，如果有什麼也挺不錯的還請告訴我一聲呦&lt;/p&gt;
&lt;h3 id=&#34;hackmd&#34;&gt;Hackmd&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/goVhwKW.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://hackmd.io/&#34;&gt;Hackmd&lt;/a&gt; 一定是必須推薦的！它是我目前做為主力的 Markdown 編輯器，它能夠：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供了方便的線上編輯環境，能用雙欄同時編輯和檢視&lt;/li&gt;
&lt;li&gt;多人協作&lt;/li&gt;
&lt;li&gt;貼上圖片自動上傳到 imgur&lt;/li&gt;
&lt;li&gt;可以嵌入 Youtube 影片等等&lt;/li&gt;
&lt;li&gt;將 md 檔直接儲存到 Github 或 Dropbox 等等空間&lt;/li&gt;
&lt;li&gt;可以使用&lt;a href=&#34;https://hackmd.io/c/tutorials-tw/%2Fs%2FMathJax-and-UML-tw&#34;&gt;語法&lt;/a&gt;直接產生 LaTeX、UML、流程圖甚至五線譜&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外還能夠將筆記分享給其他人，或是直接公開到網路上，甚至將筆記整理起來整理成&lt;a href=&#34;https://hackmd.io/s/how-to-create-book-tw&#34;&gt;書本&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;支援的用法相當多，打開瀏覽器就能用，可以說是使用 Mackdown 寫作的工具首選！甚至不少人直接當成團隊文檔庫或部落格在使用。有興趣的朋友，就從它的&lt;a href=&#34;https://hackmd.io/c/tutorials-tw/%2Fs%2Ftutorials-tw&#34;&gt;使用教學&lt;/a&gt;開始試試吧！&lt;/p&gt;
&lt;h3 id=&#34;typora&#34;&gt;Typora&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/CNC48VZ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;對我來說最方便的 Markdown 寫作環境是 Hackmd 的話，那最美的 Markdown 寫作環境就是 Typora 了。直接前往 &lt;a href=&#34;https://typora.io/&#34;&gt;Typora 的網站&lt;/a&gt; 就可以感受到它的那種極簡風格。&lt;/p&gt;
&lt;p&gt;另外 Typora 也支持使用自訂主題，只要從設定中打開主題資料夾，把 CSS 丟進去就好了，因此可以上社群（例如熟悉的 One Dark）甚至自製主題來讓編輯器更好看。&lt;/p&gt;
&lt;p&gt;Typora 也支援將文檔製作成 PDF 的功能，並且這個 PDF 是吃得到主題的 CSS 的！像我自己的履歷表就是用 Typora 寫完之後，調整 CSS 直接壓成 PDF 的，這邊也推薦給大家。&lt;/p&gt;
&lt;p&gt;改得順眼之後只能用舒服優雅來形容，寫起來都賞心悅目了，推薦熟悉 Markdown 語法之後可以試試。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/SChJiOf.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;但記得要先去偏好設定改成一體化視窗，並且去主題資料夾稍微修改一下字型讓中文舒服一點，像附圖就是使用了&lt;a href=&#34;https://github.com/be5invis/Sarasa-Gothic&#34;&gt;更紗黑體&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;整體來說，如果你要去咖啡廳之類的寫文章，那就真的可以帶 Typora 回去改個自己喜歡的主題，真的舒服。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;更新: Typera 也有主題下載頁囉！可以從 &lt;code&gt;設定 → 偏好設定&lt;/code&gt; 前往&lt;/p&gt;
&lt;p&gt;或是直接到 &lt;a href=&#34;https://theme.typora.io/&#34;&gt;https://theme.typora.io/&lt;/a&gt; 下載主題&lt;/p&gt;
&lt;p&gt;這邊也推薦一組很棒的主題：&lt;a href=&#34;https://github.com/liangjingkanji/DrakeTyporaTheme&#34;&gt;DrakeTyporaTheme&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;補充: 想要跟 HackMD 一樣能夠直接貼上圖片上傳的朋友，也可以參考這兩篇：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pjchender.blogspot.com/2020/08/app-typora-imgur-for-mac.html&#34;&gt;Typora 自動上傳圖片到 imgur (for Mac)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/130878433&#34;&gt;Windows 下采用 Typora + PicGo 搭建 Markdown 图床&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;visual-studio-code&#34;&gt;Visual Studio Code&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/EDccuCQ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;那真是太諷刺了紹安&lt;/del&gt;，繞了一圈最後最常用的還是 Visual Studio Code 直接開寫，畢竟 Hugo 寫部落格的時候也是在本機寫好推上去，過一陣子就懶得開東開西，只想直接開工。所以還是直接用 VSCode 最快了。&lt;/p&gt;
&lt;p&gt;安裝一下 Markdown 的套件之後就能直接開工了，我個人是安裝 &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one&#34;&gt;Markdown All in One&lt;/a&gt;，該有的都有了。&lt;/p&gt;
&lt;p&gt;不過上面的 Hackmd 也有推出 VScode 用的 &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=HackMD.vscode-hackmd&#34;&gt;Hackmd&lt;/a&gt; 套件包，像上面提到的繪製流程圖、數學式等功能也包含在內，有這類需求的朋友也可以使用看看。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;補充: 想要跟 HackMD 一樣能夠直接貼上圖片上傳的朋友，也可以試試 vscode-imgur 這套插件呦&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;總結&#34;&gt;總結&lt;/h2&gt;
&lt;p&gt;這篇記錄了一些常用的 Markdown 語法，並且推薦了三款 Markdown 編輯器，有興趣的朋友可以嘗試用 Markdown 打打文章或是規範文檔，相信一定能感受到 Markdown 的魅力。那麼，我們下周見～&lt;/p&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://markdown.tw/&#34;&gt;Markdown&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wcc723.github.io/development/2019/11/23/ten-mins-learn-markdown/&#34;&gt;十分鐘快速掌握 Markdown&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10203758&#34;&gt;Markdown - 易編易讀，優雅的寫文吧！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=vlFm3EVVj6Y&#34;&gt;筆記＆寫作神器 MarkDown 真希望我學生時期就懂！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pjchender.blogspot.com/2020/08/app-typora-imgur-for-mac.html&#34;&gt;Typora 自動上傳圖片到 imgur (for Mac) - PJCHENder 那些沒告訴你的小細節&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>聊一下外接螢幕</title>
      <link>https://igouist.github.io/post/2020/10/external-screen/</link>
      <pubDate>Sun, 11 Oct 2020 23:50:17 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/10/external-screen/</guid>
      <description>&lt;p&gt;這週入手了新玩具，在這邊記錄下～&lt;/p&gt;
&lt;p&gt;&lt;s&gt;我們家大神大大跟我說部落格就當推特發就對了，唉呀我也是深表認同吶&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/5BHHs9a.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;像我這種被實驗室和公司寵壞的人，已經習慣了雙螢幕的好。結果不管是在放不下兩台螢幕的家裡書桌，還是帶著筆電出門，尤其是一邊寫東西一邊查資料，需要來來回回切換視窗時，總是會想「唉呀真想把這丟到另一個螢幕啊！」&lt;/p&gt;
&lt;p&gt;因此！幾經掙扎之後，還是入手了外接螢幕！&lt;/p&gt;
&lt;p&gt;開場先說心得，雖然尚未有外出機會，但目前的使用相當滿意。這邊就說說個人體會的好壞：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2021/1/30 補充：外出也相當方便，只是桌面的空間就需要大一點&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;外接螢幕的讚&#34;&gt;外接螢幕的讚&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;有雙螢幕很爽&lt;/li&gt;
&lt;li&gt;可以攜帶出門，到圖書館之類的地方也能有雙螢幕很爽&lt;/li&gt;
&lt;li&gt;雙螢幕在一邊 Coding 一邊 &lt;s&gt;抄Stackoverflow&lt;/s&gt; 查資料，或是像部落格一邊編輯一邊看結果的時候很爽&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其實整個說起來就是帶著筆電也能雙螢幕的那種爽感，一旦用過雙螢幕，感受到不用一直切換視窗的流暢感之後，就真的回不去啦。&lt;/p&gt;
&lt;h3 id=&#34;外接螢幕的沒那麼讚&#34;&gt;外接螢幕的沒那麼讚&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;加上保護套之後幾乎都要一公斤左右，不太能忽視&lt;/li&gt;
&lt;li&gt;出門在外還要接一堆線有時候不太美觀&lt;/li&gt;
&lt;li&gt;背包裏面又是筆電又是螢幕又是手機錢包的，身家財產哪！包包離開視線就會心神不寧&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;誰適合用外接螢幕&#34;&gt;誰適合用外接螢幕&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;有出外工作習慣，例如跑去咖啡廳帥一天的朋友們&lt;/li&gt;
&lt;li&gt;像我一樣桌電筆電交替使用的朋友們&lt;/li&gt;
&lt;li&gt;只是想要出門用大螢幕打 Switch 的朋友們&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大概先這樣，推特也有字數限制呢。等有外出機會還是有什麼心得再來補充一下，先去享受新玩具了
這週也是今年最後一個連假了，各位開工愉快，咱們下周見&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/QDW7Xm9.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;補充一下：我個人入手的型號是 MSI Optix MAG161V，算是相當輕便好看。線材接的位置也挺不錯的，螢幕看著也挺舒服。&lt;/p&gt;
&lt;p&gt;Google 一下也有挺多&lt;a href=&#34;https://www.kocpc.com.tw/archives/315455&#34;&gt;開箱文&lt;/a&gt;和介紹影片的，有興趣可以看看。我這真拍不出像樣的開箱文，太難了，我嘗試過了…。這邊就推薦一下外接螢幕這東西，有興趣的朋友再自己做功課吧～&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (10): 單一職責原則</title>
      <link>https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle/</link>
      <pubDate>Fri, 02 Oct 2020 11:03:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/VyyeaYz.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我們在前面的 &lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;內聚和耦合&lt;/a&gt; 有提到過，內聚並不是無腦把相關的程式碼都封在一起就好了，也有分成健康的和不健康的。但我們要怎麼知道這個類別是否足夠健康呢？單一職責原則就是很好的檢驗方式，這篇就讓我們來紀錄一下。&lt;/p&gt;
&lt;h2 id=&#34;單一職責原則-single-responsibility-principle&#34;&gt;單一職責原則 (Single Responsibility Principle)&lt;/h2&gt;
&lt;p&gt;「單一職責」原則顧名思義，就是一個類別應該&lt;strong&gt;只負責一個職責&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但是這樣太過籠統了，「職責」相當容易產生誤會，容易變成各說各話。&lt;s&gt;畢竟咱們工程師最愛戰定義了嘛。&lt;/s&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;「你這類別不優，它有兩個職責！登入跟登出！」&lt;/p&gt;
&lt;p&gt;『沒有啦，我這個類別就是負責帳戶管理的啊』&lt;/p&gt;
&lt;p&gt;「&lt;a href=&#34;https://dailyview.tw/Daily/2019/11/07&#34;&gt;OSSO&lt;/a&gt;。乾脆你全部放一起，然後說是負責網站管理算了，呵」&lt;/p&gt;
&lt;p&gt;『……你存心來找碴的是不是？』&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;為了避免像這樣產生職場糾紛，我們需要先定義一下什麼是「職責」。經過前輩們的努力（解釋）之後，單一職責的定義就成了：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;就一個類別而言，應該只有一個引起它變化的原因&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外，我也看過「一個類別應該只對一個角色負責」的說法，這兩者的核心概念是一樣的。&lt;/p&gt;
&lt;p&gt;這邊讓我們簡單舉個例子。如果在訂單管理的類別中有一個新增訂單的方法，在收到訂單之後，會依序處理訂單、並取出會員的聯絡資訊，再依靠聯絡資訊寄送通知信件給會員。但它的實作全靠自己來，如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;新增訂單()
{
   // 收到訂單
   /*
     一些訂單的商業邏輯
   */

   // 寫入訂單
   /*
     一些和資料庫連線寫入資料的處理
   */

   // 取得聯絡資訊
   /*
     一些連到資料表或服務拿會員資料的處理
   */

   // 寄送通知
   /*
     一些寄送信件的處理，如寄送者和寄送方式等等
   */
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這樣一路就是流水帳打完收工，這樣的一個函式參雜了一堆不相干的邏輯，可能動輒數百行，每一段都處理各種不同的工作，一看就很明顯違反單一職責原則。&lt;/p&gt;
&lt;p&gt;當訂單處理的商業邏輯、查詢會員資料的邏輯或是通知會員的方式有變更的時候，這個函式都會受到影響，也就是說這個函式同時對多個不同對象負責。這樣的類別或函式就是&lt;strong&gt;不穩定的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;遇到這種情況，我們可以將其&lt;strong&gt;拆分&lt;/strong&gt;。讓上帝的歸上帝，讓凱薩的歸凱薩。&lt;/p&gt;
&lt;p&gt;例如說會員的處理一律封裝回會員管理類別，我們再藉由會員管理類別去調用其方法取回資料；寄送信件也封裝到通知管理類別，不用去管用什麼方法通知的，我們只需要去要求其通知即可。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有些朋友可能會有疑問，這樣不就會和會員處理類別、通知管理類別之類的其他類別有了&lt;strong&gt;耦合&lt;/strong&gt;關係嗎？有這樣的疑問是很合理的，這也就是為什麼我們會需要&lt;strong&gt;介面&lt;/strong&gt;來讓類別之間不要直接彼此依賴，這部份我們在 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;介面&lt;/a&gt; 有詳細介紹。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;新增訂單(訂單)
{
    處理訂單商業邏輯(訂單)

    訂單資料存取服務.儲存訂單() // 可能由資料存取層或連線管理等該職責的地方去實現

    通知服務.寄送訂單通知(訂單.訂購人編號)
}

處理訂單商業邏輯(訂單)
{
   // 專注在處理商業邏輯，不用管其他事
}

// 其他的職責拆分出去給負責該工作的類別
通知服務 { 寄送訂單通知(編號); }
訂單資料存取服務 { 儲存訂單(); }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我們&lt;strong&gt;把工作交給負責該職責的類別去做，自己只需要關注在自己正在處理的職責即可&lt;/strong&gt;。聰明的朋友可能已經注意到了，這就是&lt;strong&gt;封裝&lt;/strong&gt;的體現。封裝得夠舒服，我們就能舒服地處理自己的事情就好，這就是分工合作的偉大呀。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(2022-01-23) 補充：&lt;/p&gt;
&lt;p&gt;前面提到的「職責」的部分，雖然我們前面提過了是「引起變化的原因」，但可能還是太過模糊，&lt;s&gt;畢竟咱們工程師真的最愛戰定義了嘛。&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;今天在群組裡有前輩分享了講解單一職責原則的影片：&lt;a href=&#34;https://youtu.be/e0UOuQ_lCUY?t=1073&#34;&gt;Fred 聊聊 SOLID 設計原則&lt;/a&gt;，其中單一職責的部份，將前述的「引起變化」從&lt;strong&gt;業務需求變更&lt;/strong&gt;的方式切入&lt;/p&gt;
&lt;p&gt;影片中用實例來說明什麼時候該切分職責和其重點，例如 &lt;strong&gt;「業務耦合造成的問題就是職責不明確」、「不要讓類別去碰它不該做的事情等等」&lt;/strong&gt; ，我個人覺得非常不錯，推薦給想更了解單一職責原則或 SOLID 的朋友&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;雖然文章中的例子相對簡單。但有一個部份我個人覺得要特別注意：單一職責當然也可以用在函式上。甚至資料表或任何需要管理、分類抽象事物的東西上。&lt;/p&gt;
&lt;p&gt;有些朋友可能跟我前陣子一樣，覺得函式就是用來消除重複的程式碼，直到我看了 &lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10206839&#34;&gt;可不可以不要寫糙 code&lt;/a&gt; 和一句「難道只有重複才需要做成 Function 嗎？」才明白：函式真正的工作其實是封裝邏輯。&lt;/p&gt;
&lt;p&gt;既然是封裝邏輯這種抽象的東西，必然也會有其職責，自然也得好好注意單一職責囉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;走向單一職責&#34;&gt;走向單一職責&lt;/h2&gt;
&lt;p&gt;我們可以從上面的差別重新思考，遵守與不遵守單一職責原則會有哪些顯著的差異。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;當我們並未遵守單一職責原則時&lt;/strong&gt;，同個類別裡面充斥著不同工作的處理邏輯。也就是不健康的內聚：完全不夠聚，就只是盤散沙。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;容易產生&lt;strong&gt;意外的重複&lt;/strong&gt;。每個類別每個方法都自己去查詢會員資料，當查詢會員資料的方式或規則有變更的時候，影響範圍就會非常大，同樣的事情有一大堆地方要改，還得要先全部找出來，想到就頭痛。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同時我們在修改時也&lt;strong&gt;無法界定邊界&lt;/strong&gt;，無法確定這次修改影響到的範圍，我們並不知道這些放在一起的東西，或是同一段做的所有事之間&lt;strong&gt;是否會相互影響&lt;/strong&gt;，這將導致每次修改的時候都在挑戰我們自己的心臟負荷量，讓維護變成試膽大會，類別變成危樓改建。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;承上，我們為了要確保修改沒有問題，我們必須&lt;strong&gt;大量閱讀不相關的程式碼&lt;/strong&gt;，無形中造成開發負擔，降低開發效率。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你曾經有閱讀別人的程式碼，卻始終看不懂這東西到底在幹嘛，每分鐘髒話數筆直上升的經驗。答應我，&lt;strong&gt;我們不要讓別人經歷相同的悲劇&lt;/strong&gt;，我們要斬斷仇恨的鎖鏈。我們，今天就開始走向單一職責。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;當我們終於選擇單一職責&lt;/strong&gt;，我們的類別才能真的擁有健康的高內聚。以上的這些問題，也都變成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每個類別都專注在自己職責上，需要這個功能的其他類別就能來使用。大大提高了程式碼的&lt;strong&gt;重複使用&lt;/strong&gt;程度，同時也&lt;strong&gt;降低了程式碼的重複性&lt;/strong&gt;。並且因為類別內都是朝同樣職責前進的成員，彼此關聯性相當高，因此也&lt;strong&gt;提高了內聚&lt;/strong&gt;。這兩點讓我們能迴避掉「要改的地方太多了，就改天吧」的悲傷結局。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同時，當我們要修改時，只需要找到負責的類別修改。因為已經把不屬於職責的工作交給其他類別了，達到了封裝和隔離，所以我們就能輕鬆看出修改的區域和邏輯，並較少地被不相干的東西影響、馬上掌握修改的目標和影響範圍，使得架構和類別&lt;strong&gt;更容易管理&lt;/strong&gt;。也就是說，單一職責可以達到&lt;strong&gt;降低耦合&lt;/strong&gt;的效果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;展現你的意圖&#34;&gt;展現你的意圖&lt;/h2&gt;
&lt;p&gt;單一職責讓我想到前陣子看的&lt;a href=&#34;https://igouist.github.io/post/2020/09/start-with-why&#34;&gt;《先問為什麼》&lt;/a&gt;中的芹菜測試：當你在超市結帳時，手上拿著巧克力、豆漿、餅乾跟芹菜，沒有人看得出來你到底要幹嘛。&lt;/p&gt;
&lt;p&gt;寫程式也是如此，&lt;strong&gt;如果你的類別或方法裡什麼都要，彼此間又甚無關連，那就沒人看得懂這到底是幹嘛的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果團隊的其他人不能瞭解這個類別的職責，那後續協助修改的時候就會沒辦法把相同工作的程式碼歸類在一起，甚至難以修改，做起事綁手綁腳，新增個方法都會陷入混亂。整個架構就會開始腐敗。這也就是為什麼我們需要保持程式碼的可讀性，並且盡力實踐單一職責。&lt;/p&gt;
&lt;p&gt;如同我在先問為什麼文中所引用的「你的一言一行，都要能證明你的信念」。在這裡，你的類別、方法，甚至是程式碼中的每一區塊，都必須要能夠&lt;strong&gt;展現你的意圖&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因此，單一職責不只能用來檢驗類別。從一整個服務，到單一個函式，都可以用它的意圖來問問自己。這一段是否只有一個職責？&lt;strong&gt;是否只有一個原因造成改變？職責是否清晰？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;當然，從模組到函式每一層級的抽象概念是不一樣的，模組有模組關注的點，函式有函式關注的點，其規模有所差異，請不要用函式的職責大小去要求整個類別，我個人覺得這中間的差異還是挺吃經驗的，但不去嘗試思考，就沒得經驗可說嘛。這邊還是鼓勵大家多多利用單一職責去檢驗任何片段的程式碼。&lt;/p&gt;
&lt;p&gt;當我們利用單一職責原則去檢驗，或是思考方向的時候，如果&lt;strong&gt;列得出兩項以上的變更原因，且這些原因彼此關聯很薄弱的時候，就是警訊&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;反過來說，即使有兩個原因引起變化，但這些原因之間的關聯很強，例如總是一起變化，那其實就不必分離，或是可以暫緩分離，避免&lt;strong&gt;過度設計&lt;/strong&gt;所引起的&lt;strong&gt;不必要的複雜性&lt;/strong&gt;。（白話文來說就是走火入魔）&lt;/p&gt;
&lt;p&gt;如果能做到撰寫功能當下，或是重構的時候不斷自我檢驗，那寫出來的程式碼品質相信也能展現出一定的水準了吧！共勉之。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文整理時主要參考了這兩篇，寫得相當不錯，想更瞭解的朋友可以參考一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://wadehuanglearning.blogspot.com/2019/12/blog-post.html&#34;&gt;再談物件導向設計原則: 單一職責原則，定義、解析與實踐 - WadeHuang的學習迷航記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jyt0532.com/2020/03/18/srp/&#34;&gt;深入淺出單一職責原則 Single Responsibility Principle - jyt0532’s Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;看到這篇覺得很不錯，從另一個角度切入單一職責，回來補充給各位朋友：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ruddyblog.wordpress.com/2022/11/25/%e5%b7%a5%e7%a8%8b%e5%b8%ab%e7%9a%84%e7%b0%a1%e5%96%ae%e8%a7%80%e5%bf%b5/&#34;&gt;工程師的簡單觀念 – Ruddy Lee 分享空間 (wordpress.com)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列下一篇：&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://wadehuanglearning.blogspot.com/2019/12/blog-post.html&#34;&gt;再談物件導向設計原則: 單一職責原則，定義、解析與實踐 - WadeHuang的學習迷航記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10191955&#34;&gt;SOLID 之 單一職責原則（Single responsibility principle）- Miles - iT邦幫忙&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jyt0532.com/2020/03/18/srp/&#34;&gt;深入淺出單一職責原則 Single Responsibility Principle - jyt0532&amp;rsquo;s Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://youtu.be/e0UOuQ_lCUY?t=1073&#34;&gt;Fred 聊聊 SOLID 設計原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-1_single-responsibility-principlesrp-%E5%96%AE%E4%B8%80%E8%81%B7%E8%B2%AC/&#34;&gt;Object Oriented 物件導向設計原則 SOLID-1:Single Responsibility Principle(SRP) 單一職責 - Sian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@n26074273/solid-i-%E5%96%AE%E4%B8%80%E8%81%B7%E8%B2%AC%E5%8E%9F%E5%89%87-single-responsibility-principle-11e30ece0778&#34;&gt;SOLID-I 單一職責原則(Single Responsibility Principle) - 黃子源 - Medium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tenlong.com.tw/products/9789866761799&#34;&gt;《大話設計模式》&lt;/a&gt; Ch3. 拍攝UFO －－單一職責原則&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tenlong.com.tw/products/9789864342945&#34;&gt;《無瑕的程式碼：整潔的軟體設計與架構篇》&lt;/a&gt; Ch.7 SRP －－單一職責原則&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tenlong.com.tw/products/9789864342099&#34;&gt;《無瑕的程式碼：物件導向原則、設計模式與C#實踐》&lt;/a&gt; Ch.8 SRP －－單一職責原則&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同系列文章&#34;&gt;同系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>C#: 元組 (Tuple)</title>
      <link>https://igouist.github.io/post/2020/09/csharp-trulp/</link>
      <pubDate>Sun, 27 Sep 2020 23:56:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/09/csharp-trulp/</guid>
      <description>&lt;p&gt;因為隔壁介紹原則的部分有點卡住了，所以這週來紀錄一下挺常用到的方便東西：&lt;strong&gt;Tuple&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;這篇的 Tuple 指的是 C# 7.0 後提供的 &lt;strong&gt;ValueTuple&lt;/strong&gt; 和相關語法，舊版得用 &lt;code&gt;Tuple.Create&lt;/code&gt; 建立，成員的名稱也只能使用 Item1, Item2&amp;hellip;，實用性並不是很高。但新 Tuple 出現後，方便程度大大提升，這邊就稍作紀錄一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;註：此處使用的 &lt;code&gt;Dump&lt;/code&gt; 是 Linqpad 提供的輸出方法，把它當成 Print 就行了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; student = (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;王小明&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;student.Item1.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// 1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;student.Item2.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// 王小明&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;student.Dump();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到 Tuple 的建立相當簡單，只需要用小括號 &lt;code&gt;()&lt;/code&gt; 括選起來即可。建立後的內容就會像這樣：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/H0wJglN.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;但這樣使用就和之前一樣，取出來時只能拿 Item1, Item2，放個幾天根本就不記得 Item1 裡面是啥東西了。這時我們就可以&lt;strong&gt;替成員們取名字&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ID, &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; Name) student = (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;王小明&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;student.ID.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// 1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;student.Name.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// 王小明&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如此使用的時候就和一般操作物件的習慣沒有差別，也增加了可讀性。&lt;/p&gt;
&lt;p&gt;到這裡可能感覺只是個方便的變數打包小工具，但其真正順手的地方就在於作為&lt;strong&gt;回傳值&lt;/strong&gt;的時候。&lt;/p&gt;
&lt;p&gt;過去要一次回傳多個值，除了使用 Ref 等方式以外，就只能乖乖做一個類別來裝，但有時候傳的東西又相當簡單，實在不太願意就此建立一個類別，又或是事情已經無法挽回，專案虛胖了一堆&lt;strong&gt;米蟲類別&lt;/strong&gt;。有了 Tuple 之後，面對這種情況就可以&lt;strong&gt;直接使用 Tuple 解決&lt;/strong&gt;，並且替成員們命名之後，既簡便又好讀！&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 回傳型別使用 Tuple&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; IsSuccess, &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; Message) DoSomeThing()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 做了一堆事情&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;操作成功&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; result = DoSomeThing();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	result.IsSuccess.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	result.Message.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// 操作成功&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而當我們作為回傳值使用時，也可以直接原地解封：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 回傳型別使用 Tuple&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; IsSuccess, &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; Message) DoSomeThing()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 做了一堆事情&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;操作成功&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 直接拆開賦值給多個變數&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; (isSuccess, message) = DoSomeThing();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	isSuccess.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	message.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// 操作成功&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;作為一個簡易臨時型別挺方便的，但要注意不要用過頭了。兩三個成員還算方便，如果有七八個甚至十來個成員，請還是乖乖做成類別吧！&lt;/p&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.huanlintalk.com/2017/04/c-7-tuple-syntax.html&#34;&gt;C# 7 新增的 Tuple 語法 - Huanlin 學習筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/supershowwei/2018/10/01/135755&#34;&gt;[料理佳餚] 用 ValueTuple 解放雞肋類別 - 軟體主廚的程式料理廚房&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (9): SOLID</title>
      <link>https://igouist.github.io/post/2020/09/oo-9-solid/</link>
      <pubDate>Sun, 20 Sep 2020 13:51:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/09/oo-9-solid/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/U7iWMT9.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;終於進入了原則篇，接下來的幾篇我們會介紹幾個物件導向的原則（基本上就是指 SOLID 原則）。因此這篇就讓我 &lt;s&gt;水一下&lt;/s&gt; 當成後半段的目錄，方便之後可以把相關的部分整理進來。&lt;/p&gt;
&lt;h2 id=&#34;為什麼我們需要這些原則&#34;&gt;為什麼我們需要這些原則？&lt;/h2&gt;
&lt;p&gt;我們在前面的章節已經說明了一些物件導向的特性，例如繼承和多型等等。然而我們並沒有討論到怎麼運用、或是怎樣設計才能算是更好的、更優雅的、更符合物件導向精神的；我們並沒有提到一個評估的標準，或是指引一個更好的方向。&lt;/p&gt;
&lt;p&gt;然而，混亂的使用物件導向對整個專案的毀滅性甚至比乾脆不使用物件導向還高。&lt;/p&gt;
&lt;p&gt;這些特性使用起來很簡單，大多數語言只需要一個符號或標示就能完成繼承，把一堆東西全部塞在一起就可以說我在封裝。但怎麼使用得好，又該什麼時候使用呢？這就是難的地方吧。&lt;/p&gt;
&lt;p&gt;例如說濫用繼承，或是封裝時完全不隱藏複雜度一路 Puuuuublic 到底，又或者是類別之間過於相互依賴，全部耦合成一團等等。如果隨便地使用物件導向的各項特性，就會讓整個架構變得僵化、脆弱、危險、充滿臭味。&lt;/p&gt;
&lt;p&gt;更可怕的是，這個發臭的過程是每一次設計、每一次修改都會有所影響，所謂「持續發生，腐敗成真」，&lt;strong&gt;隨著物件導向的亂用、誤用、無腦用，軟體就會逐漸腐化&lt;/strong&gt;。一組腐化的軟體可能會有以下特徵：大量的依賴使得修改變得困難、修改後看似不相干的各個地方發生問題、或是修改時沒辦法依循原本的設計、到處出現不必要的複雜性和不必要的重複，模組也變得難以理解等等。&lt;/p&gt;
&lt;p&gt;阻止程式碼的腐化、追求更好的架構和設計、寫出更好的代碼，當然是我輩所追求的目標。儘管面對的可能是不同的問題和不同的環境，那些優質、穩固、具有&lt;strong&gt;反脆弱&lt;/strong&gt;特質的程式碼也必然會有些共通之處。例如說：需要具有&lt;strong&gt;面對改變&lt;/strong&gt;的能力、具有&lt;strong&gt;方便管理&lt;/strong&gt;的能力、具有&lt;strong&gt;隱藏複雜性&lt;/strong&gt;的能力。&lt;/p&gt;
&lt;p&gt;因此，大前輩們整理並提出了一些可以致力的方向，也就是所謂的「&lt;strong&gt;原則&lt;/strong&gt;」。如同心法、教義一般，只要實作的同時將其牢記在心，就能讓我們作為一些行動的準則和依據。&lt;/p&gt;
&lt;p&gt;所謂練拳不練功，到老一場空。我們可不能看了招式就無腦用，先讓我們看一下這些 SOLID 原則的目標是什麼。&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&#34;https://www.books.com.tw/products/0010786994&#34;&gt;Clean Architecture&lt;/a&gt; 裡是這樣說明的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這些原則的目標是建立中層級的軟體結構，這樣的結構包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能容忍變化&lt;/li&gt;
&lt;li&gt;容易理解&lt;/li&gt;
&lt;li&gt;在許多軟體系統中能夠使用的元件的基礎&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;「中層級」是指這些原則是程式設計師在模組層級工作時應用的原則。它們應用在程式碼層級之上，並且有助於定義模組和元件內使用的軟體結構類型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我們應用這些原則的場景，應該是在所謂的「中層級」發生。也就是並非小到一行程式碼，也並非是一整個專案，而是其中的各個「&lt;strong&gt;模組&lt;/strong&gt;」。不論是類別、介面又或是其他名稱的任何東西，凡是具有函式或資料的中層級，我們就可以運用這些原則來處理。&lt;/p&gt;
&lt;p&gt;而我們之所以要用這些原則，就是為了達到 &lt;strong&gt;能容忍變化&lt;/strong&gt;、&lt;strong&gt;容易理解&lt;/strong&gt;、&lt;strong&gt;能讓模組和元件使用&lt;/strong&gt; 這些目標。&lt;/p&gt;
&lt;p&gt;這些目標可以當作一個良好的程式碼模組該有的特徵。你的類別必須能容忍變化，必須具備可擴展性和可修改性，畢竟&lt;strong&gt;軟體的需求大多時候都是擴展跟修改&lt;/strong&gt;。更進一步說，功能和彈性之間甚至應該先選擇彈性，畢竟為了功能犧牲彈性的話，一但面對變化，整個程式就碎了；但優先選擇彈性的話，至少你還有機會能把它修改得更符合功能，所以對這些原則而言，能容忍變化是相當重要的。甚至，&lt;strong&gt;整個 SOLID 就是面對變化的作戰策略&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而容易理解就更重要了。Clean Code 裡有提過，&lt;strong&gt;閱讀程式碼和實際開工打字的時間大約是佔 10 : 1&lt;/strong&gt;，因此是否容易理解，是否乾淨好懂就是相當重要的一環。看得快，就寫得快；寫得越快，心越慢。&lt;/p&gt;
&lt;p&gt;如同我們在首篇所說，物件導向就是在替我們把概念抽象化，而這抽象過程所使用的這些特性，就是為了減少複雜性、提高可理解度而存在的。因此，一組優良的程式碼，容易理解是絕對必要的。&lt;/p&gt;
&lt;p&gt;另外關於為什麼我們需要這些原則，我個人推薦可以先閱讀這幾篇，對我個人來說很有收穫：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://wadehuanglearning.blogspot.com/2019/10/solid.html&#34;&gt;淺談物件導向 SOLID 原則對工程師的好處與如何影響能力 - WadeHuang的學習迷航記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wadehuanglearning.blogspot.com/2019/10/solid-why-solid.html&#34;&gt;再談 SOLID 原則，Why SOLID? - WadeHuang的學習迷航記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://teddy-chen-tw.blogspot.com/2014/04/solid.html&#34;&gt;SOLID：五則皆變 - 搞笑談軟工&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;說那麼多所以到底有哪些原則&#34;&gt;說那麼多，所以到底有哪些原則？&lt;/h2&gt;
&lt;p&gt;現在我們已經了解到，因為軟體會逐漸腐化，所以我們要找出原則；這些原則的目標，就在於設計出可變化可理解的優質模組。現在，是時候公布我們 SOLID 五大天王的名諱了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;單一職責原則 &lt;strong&gt;S&lt;/strong&gt;ingle Responsibility Principle (SRP)&lt;/li&gt;
&lt;li&gt;開放封閉原則 &lt;strong&gt;O&lt;/strong&gt;pen-Closed Principle (OCP)&lt;/li&gt;
&lt;li&gt;里氏替換原則 &lt;strong&gt;L&lt;/strong&gt;iskov Substitution Principle (LSP)&lt;/li&gt;
&lt;li&gt;介面隔離原則 &lt;strong&gt;I&lt;/strong&gt;nterface Segregation Principle (ISP)&lt;/li&gt;
&lt;li&gt;依賴反轉原則 &lt;strong&gt;D&lt;/strong&gt;ependency Inversion Principle (DIP)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;註：大多時候 L 的位置也會多一個 Law of Demeter 迪米特法則（= Least Knowledge Principle 最少知識原則），畢竟也挺重要的，而且四大天王都有五個人了，五大原則有六個也是剛剛好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而它們的首字合起來就是 &lt;strong&gt;&lt;code&gt;SOLID&lt;/code&gt;&lt;/strong&gt;，表達出那種穩固的、可靠的感覺！順便一提，順序沒有任何關係，會排成 SOLID 純粹只是作者朋友當時覺得這樣比較好記。&lt;/p&gt;
&lt;p&gt;那麼從&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;下一篇&lt;/a&gt;開始，我們就按照 SOLID 的順序，從單一職責開始介紹。我們下次見～&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列下一篇：&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://wadehuanglearning.blogspot.com/2019/10/solid.html&#34;&gt;淺談物件導向 SOLID 原則對工程師的好處與如何影響能力 - WadeHuang的學習迷航記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wadehuanglearning.blogspot.com/2019/10/solid-why-solid.html&#34;&gt;再談 SOLID 原則，Why SOLID? - WadeHuang的學習迷航記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://teddy-chen-tw.blogspot.com/2014/04/solid.html&#34;&gt;SOLID：五則皆變 - 搞笑談軟工&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@ChunYeung/%E4%BD%BF%E4%BA%BA%E7%98%8B%E7%8B%82%E7%9A%84-solid-%E5%8E%9F%E5%89%87-%E7%9B%AE%E9%8C%84-b33fdfc983ca&#34;&gt;使人瘋狂的 SOLID 原則：目錄 - YC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@f40507777/%E6%88%91%E8%A9%B2%E5%AD%B8%E6%9C%83solid%E5%97%8E-4e73887c9156&#34;&gt;我該學會SOLID嗎? - Finn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ycc.idv.tw/introduction-object-oriented-programming_3.html&#34;&gt;物件導向武功秘笈（3）：內功篇 — 物件導向指導原則SOLID - YC Chen&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://youtu.be/e0UOuQ_lCUY&#34;&gt;Fred 聊聊 SOLID 設計原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/%E6%89%8B%E5%AF%AB%E7%AD%86%E8%A8%98/clean-code-b45a89ea8c66&#34;&gt;第 1 章 無瑕的程式碼 | Clean Code - 手寫筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.books.com.tw/products/0010786994&#34;&gt;《無瑕的程式碼：整潔的軟體設計與架構篇》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同系列文章&#34;&gt;同系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (8): 內聚、耦合</title>
      <link>https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling/</link>
      <pubDate>Sun, 13 Sep 2020 23:56:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/cgxW9yZ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;做為前後段落的分水嶺，這篇文章我將紀錄一下 &lt;strong&gt;「內聚」(Cohesion)&lt;/strong&gt; 和 &lt;strong&gt;「耦合」(Coupling)&lt;/strong&gt;，這兩者是評估一個類別或元件的重要概念。&lt;/p&gt;
&lt;p&gt;在實務上，為了提升擴展性，降低維護成本等因素，我們對於單個類別或元件，會有著 &lt;strong&gt;「低耦合」&lt;/strong&gt; 及 &lt;strong&gt;「高內聚」&lt;/strong&gt; 的期待。例如我們在 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt; 中，我們就有提到封裝的好壞相當重要，其中也包含了「提高類別內的內聚性，降低對外的耦合性」。那麼，到底什麼是內聚，什麼又是耦合呢？&lt;/p&gt;
&lt;h2 id=&#34;內聚&#34;&gt;內聚&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;「把需要的程式和資料都包裝在同一個模組內，使得該模組能夠做為一個單獨的個體執行」&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;白話一點說，就是就是把用到的東西都打包到一處，該有的自己都有了，所以即使單獨一個人也能完成工作的能力、可以自己 Carry 整場不用看豬隊友臉色的能力。越能自己單幹，越不需要依賴其他類別的時候，內聚力也就越高。&lt;/p&gt;
&lt;p&gt;也就是說：如果你的類別什麼都要依賴其他類別，像小嬰兒一樣需要呵護照顧，那內聚力就很低。反之，如果像野外求生大師，啥都靠自己，那內聚力就超高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;內聚代表的是該模組的獨立性，當這個模組可以獨力完成工作，就代表我們能夠重複使用它，且不需要擔心影響到其他模組。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;並且也基於這點，我們不用擔心變動這個模組時需要先處理其他的模組，因為這個工作所需的都包含在模組內了，這樣就可以&lt;strong&gt;單獨修改&lt;/strong&gt;該模組，減少維護成本。&lt;/p&gt;
&lt;p&gt;例如你的筆已經包含了所有寫字工具的條件，具有墨水跟筆芯等等，可以只使用筆就完成寫字這個工作。那麼我們就可以隨身帶著，在任何需要的時候重複使用它，而不用擔心我們會不會漏了什麼必要零件沒有帶出門。同時，如果我們需要換筆芯或墨水，我們也知道要更換的部份就在筆裡面，不需要去找鉛筆盒中別的地方。&lt;/p&gt;
&lt;p&gt;而我們在物件導向的世界中，是將不同的邏輯和功能，封裝成不同的物件，藉由這些物件的互動來構築我們抽象化的世界和想法。為了隱藏這些物件內部的複雜性，同時又保持物件的整體性，讓物件能真的符合我們概念中的「一個」物件，那麼&lt;strong&gt;追求高內聚就是必然的&lt;/strong&gt;。內聚，是物件的一種美德。&lt;/p&gt;
&lt;p&gt;然而，&lt;strong&gt;盲目地追求高內聚是很危險的&lt;/strong&gt;。只要你希望，當然可以寫出一個超級內聚的類別，但這代表什麼呢？&lt;/p&gt;
&lt;p&gt;為了提高內聚，把所有相關的東西都一股腦塞進同一個類別，越塞越多越塞越多，沒那麼相關的東西也硬塞在一起。從模組變成義大利麵，再從義大利麵變成大補帖，最後終於變成&lt;a href=&#34;https://en.wikipedia.org/wiki/God_object&#34;&gt;神&lt;/a&gt;。這樣實際上根本就不內聚，類別裡面就是一堆散沙，&lt;strong&gt;功能一大堆動輒數千行，改個 Bug 先看三千行程式碼&lt;/strong&gt;，維護者莫不痛哭流涕…&lt;/p&gt;
&lt;p&gt;又或是為了避免上面的狀況，限制了功能範圍。但卻又為了能獨立作業，為了不依賴別人，硬是把別的地方已經有的功能複製一份過來，用到的東西都複製複製複製進來，人人都有一份。最後遇到修改時，&lt;strong&gt;要改這又要改那，等著改的地方遍地開花&lt;/strong&gt;，維護成本暴增，維護者再度痛哭流涕…&lt;/p&gt;
&lt;p&gt;到這邊應該能瞭解到&lt;strong&gt;完全內聚是不可能也不應該的&lt;/strong&gt;，過於執著就會走火入魔。那麼怎樣的內聚算是剛剛好呢？或是說，一個良好的高內聚？這就牽涉到這段程式碼的&lt;strong&gt;意圖&lt;/strong&gt;了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;良好的內聚應該只關注在一件事情上，並適時地將不屬於自身職責的工作交給別人&lt;/strong&gt;，達到所謂「&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10203659&#34;&gt;該內聚而內聚，該耦合而耦合&lt;/a&gt;」。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所謂「只關注一件事情」、「不屬於自身職責」云云，我們在之後的 &lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;單一職責原則&lt;/a&gt; 會更進一步地說明。且先按下不表。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;為了減少重複程式碼，和降低維護的困難，不管怎樣互動都是不可避免的。那既然我們的物件多多少少都得依賴別人，就不能不提到耦合了。&lt;/p&gt;
&lt;h2 id=&#34;耦合&#34;&gt;耦合&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;「如果模組和另一個模組有關聯，那這兩者之間就耦合」&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;耦合的定義就是這麼寬廣。不管是接收另一個物件傳入的值，或者是共用同個全域變數，更何況我中有你你中有我，都是耦合。&lt;/p&gt;
&lt;p&gt;當兩者之間的關聯越緊密，越無法分離，其耦合度就越高。例如說&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;繼承&lt;/a&gt;關係就是強耦合的代表。&lt;/p&gt;
&lt;p&gt;當我們的目標放在減少重複的程式碼時，就會有多個模組共用同一段程式碼的情形發生，也會造成這些模組和這段重複使用的程式碼彼此耦合。&lt;/p&gt;
&lt;p&gt;那當我們為了其中一個使用者修改了這段程式碼，就會連帶影響其他用到的地方。變成&lt;strong&gt;改了這裡壞那裡，修了那裡壞這裡&lt;/strong&gt;的詭異情況。這也就是我們追求降低耦合的最大原因。&lt;/p&gt;
&lt;p&gt;彼此關聯就會彼此牽連，因此我們要讓彼此之間保持一個&lt;strong&gt;舒適的距離&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;注意，是舒適的距離，而不是不相往來，從這點來看，&lt;strong&gt;健康的內聚就是健康的耦合&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;內聚與耦合&#34;&gt;內聚與耦合&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;內聚是模組的獨立性，耦合則是模組的關聯性&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;「低內聚高耦合」的組合，牽一髮動全身，改個一行程式碼動輒就是大規模傷害，我們甚至不能切分模組，完全和物件的精神背道而馳，這是萬不能接受的。&lt;/p&gt;
&lt;p&gt;「高內聚低耦合」則是大家所追求的目標。為了讓每個物件各自獨立又能彼此互動，從物件導向中&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;封裝&lt;/a&gt;的角度出發，這個方向絕對是正確的。&lt;/p&gt;
&lt;p&gt;但所謂過猶不及，若是太過火變成「超高內聚無耦合」，又會變成可怕的 All in one 融合怪物或是 Ctrl C VVVVV 的複製大軍……&lt;/p&gt;
&lt;p&gt;不健康的內聚和不健康的耦合都是問題，內聚和耦合這兩者就像天秤的兩端，我們的目標就是找到那個合適的平衡點，也就是&lt;strong&gt;健康的高內聚低耦合&lt;/strong&gt;才是我們所追求的。&lt;/p&gt;
&lt;p&gt;同時也可以注意到內聚和耦合會發生的問題，例如修改時影響其他物件導致壞一整片，又或是修改時太多地方要改成本過高，總是圍繞在擴展和維護，基本上就是&lt;strong&gt;面對改變時會發生的問題&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;就像基因的優劣在於適應環境並生存下去的能力，程式碼也是如此。為了協助我們追求健康的高內聚低耦合目標，也&lt;strong&gt;為了讓我們面對改變（遭遇災難）時有個方針，因此才有了一些原則&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;就像我們前面敘述內聚時一直迴避的這些問題：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;怎樣才是適合的內聚？怎樣才是健康的耦合？&lt;/li&gt;
&lt;li&gt;如果說過高的內聚會塞太多功能或複製重複功能而變成怪物，過低的內聚則會四處拈花惹草，那我們要怎麼知道這個類別或元件的功能範圍剛剛好？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些問題的參考準則，就在於我們之後要介紹的「&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;單一職責原則&lt;/a&gt;」！&lt;/p&gt;
&lt;h2 id=&#34;小結&#34;&gt;小結&lt;/h2&gt;
&lt;p&gt;過了兩個月再度接續這個系列，一回來就是一篇碎碎念充當預告片，總之就先交代一下內聚和耦合的概念。&lt;/p&gt;
&lt;p&gt;但要真的達到健康的內聚和健康的耦合，不造神、不亂依賴、物件裡面高內聚、物件彼此低耦合，就必須要有一些原則。&lt;/p&gt;
&lt;p&gt;所以&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;下回&lt;/a&gt;開始就要進入物件導向五大原則的段落了，那麼，我們下次見！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;註：內聚跟耦合算是相當重要又基礎的觀念，我個人也還在摸索，只聞其聲不見其影。想要更了解這兩個概念的朋友，可以將參考資料的文章都看過一遍，我個人覺得頗有幫助，尤其是&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10203659&#34;&gt;實務上的高內聚與低耦合&lt;/a&gt;、&lt;a href=&#34;http://teddy-chen-tw.blogspot.com/2011/12/1.html&#34;&gt;搞笑談軟工&lt;/a&gt;兩篇，值得特別推薦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列下一篇：&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10203659&#34;&gt;實務上的高內聚與低耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://teddy-chen-tw.blogspot.com/2011/12/1.html&#34;&gt;亂談軟體設計（1）：Cohesion and Coupling - 搞笑談軟工&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10191761&#34;&gt;斷開鎖鏈! 低耦合、高內聚&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10206839&#34;&gt;如何寫高品質 function (內聚性篇)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-5_%E5%85%A7%E8%81%9Acohesion%E8%80%A6%E5%90%88coupling/&#34;&gt;Object Oriented物件導向-5:內聚(Cohesion)、耦合(Coupling) - Sian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://youtu.be/e0UOuQ_lCUY&#34;&gt;Fred 聊聊 SOLID 設計原則&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同系列文章&#34;&gt;同系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>讀《先問為什麼》</title>
      <link>https://igouist.github.io/post/2020/09/start-with-why/</link>
      <pubDate>Sun, 06 Sep 2020 10:02:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/09/start-with-why/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/mC6ySzk.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你樂於接納新事物，希望成功能持久，也相信自己的成功需要別人的幫助&lt;/p&gt;
&lt;p&gt;我向你提出一個挑戰 ——&lt;/p&gt;
&lt;p&gt;從今天起，做任何事情之前，請先問自己「為什麼」。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這本書的中文副標很好地點出了本書的重點：顛覆慣性思考的&lt;strong&gt;黃金圈理論&lt;/strong&gt;，啟動你的&lt;strong&gt;感召領導力&lt;/strong&gt;。大多篇幅用在舉例以及逐步說明何謂感召，以及黃金圈。&lt;/p&gt;
&lt;p&gt;本書的想法和一些例子，尤其是書中最重要的黃金圈理論，在作者上 TED 的影片「&lt;a href=&#34;https://www.ted.com/talks/simon_sinek_how_great_leaders_inspire_action?language=zh-tw&#34;&gt;偉大的領袖如何鼓動行為&lt;/a&gt;」都有說明，有興趣的朋友可以直接看演講影片，足夠掌握到黃金圈理論的核心。&lt;/p&gt;
&lt;iframe src=&#34;https://embed.ted.com/talks/lang/zh-tw/simon_sinek_how_great_leaders_inspire_action&#34; width=&#34;100%&#34; height=&#34;480&#34; frameborder=&#34;0&#34; scrolling=&#34;no&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;（偉大的領袖如何鼓動行為 - TED）&lt;/p&gt;
&lt;p&gt;作者認為影響人類行為的方法有兩種：&lt;strong&gt;操弄&lt;/strong&gt;以及&lt;strong&gt;感召&lt;/strong&gt;，其中操弄是指使用手段或策略去影響他人，例如說談判、利誘、情緒勒索、削價競爭等等，所謂「人有所好，以好誘之無不取；人有所懼，以懼迫之無不納」就是操弄。&lt;/p&gt;
&lt;p&gt;同時操弄也是我們日常最常接觸到的方法，可說是無所不在，並且很容易達到目標，短期見效。但如果將目光放到建立長期關係，則操弄就不一定是個好方法：它能帶來短期的利益，但並不能帶來忠誠度和信任，過度依賴操控就像在懸崖邊跳舞，一失足就難以挽回。&lt;/p&gt;
&lt;p&gt;而感召，則是用激勵人心的方式去影響他人、促使別人展開行動。為了說明這些領導者如何能做到感召他人，作者提出了黃金圈理論。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/WM8Js7d.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;從最外圈到最內圈分別為：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;做什麼&lt;/strong&gt;：負責什麼工作、提供什麼商品等等。每個人都能說得出來。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;怎麼做&lt;/strong&gt;：流程、方法、技術。知道怎麼把事情做好，比做什麼更加抽象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;為什麼&lt;/strong&gt;：目的、使命、信念。真正的核心，但很少人能清楚說明。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我們能很清楚說出我們正在做什麼，有些時候也能說得出來該怎麼做，但很少人會提及為什麼要這樣做。這是因為大多數人傾向從較為清楚的點開始，而將模糊的事往後延，所以行為模式就會是從黃金圈由外往內。從具體的行為到模糊的原因。&lt;/p&gt;
&lt;p&gt;然而，能激勵熱情的做法卻不一樣，他們是由內往外的，他們會先問為什麼。作者針對這兩種的差異，給了一組電腦公司的銷售方式做為例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我們很會做電腦&lt;/li&gt;
&lt;li&gt;我們的電腦有最美的設計，不但使用簡單，也容易上手&lt;/li&gt;
&lt;li&gt;想要買一台嗎？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這就是先從最外圈做什麼開始的訴求，但這樣實在沒有什麼吸引力。然而，大多數的企業和廣告都採用這種方式行銷，先從「我們做的商品，這項商品和其他商品的不同處」開始，然而這並不能達到感召。接著，作者提出了蘋果的溝通模式來對比：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我們做的每件事，都是為了挑戰、改變現況，因為我們相信「不同凡想」的力量&lt;/li&gt;
&lt;li&gt;我們挑戰現況的方法，就是讓我們的產品有最美的設計，而且簡單好用&lt;/li&gt;
&lt;li&gt;剛好，我們做的就是最棒的電腦&lt;/li&gt;
&lt;li&gt;想要買一台嗎？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只是調整一下訴求的順序，並說明為什麼而已，感覺就會截然不同。&lt;/p&gt;
&lt;p&gt;這之間的差別在於，所謂設計、簡單、好用，只是你的理念具體化的表現。所有公司都能夠聘請厲害的設計師和工程師，所有公司也都各有優劣之分，多數人和企業認為有形的功能和價值會是致勝關鍵，不可否認產品和策略對於優勢息息相關，然而在這些背後，你為什麼而做，你所做的是否能夠表達出你的理念，這就會是關鍵的差別。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;吸引人們的，不是你做什麼，而是你為什麼做。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用優劣得失衡量而來的顧客，終究會因為優劣得失離開；但用理念吸引來的顧客，將會和你並肩作戰。這也就是開場時，作者將操弄和感召作為對比的原因，在這裡直接延伸成忠誠度，若只用手段和策略去鞏固顧客，這樣的關係危險且無法持久。但當你的目標和理念能和顧客產生共鳴時，顧客甚至能夠包容你產品的缺點，而以你產品的優點為傲。這是只講究手段、策略、怎麼做的人難以理解的。&lt;/p&gt;
&lt;p&gt;只執著在怎麼做的人，會用差異化的方式來試圖脫穎而出，也就是說服顧客自己和其他競爭者與眾不同。然而，大多數的產品對顧客來說都是所差無幾的，例如生活用品、衛生紙、牛奶，對顧客來說牛奶就是牛奶。並且，當我們只用怎麼做和做什麼兩個著眼點去進行這件事時，很容易陷入惡性循環。例如說削價競爭，用低價當做訴求，不斷削價的結果可想而知。&lt;/p&gt;
&lt;p&gt;真正最有效的差異，就在於你為什麼而做。&lt;/p&gt;
&lt;p&gt;「一台擁有5GB容量的MP3播放器」和「（為了）放一千首歌在你的口袋裡」中間的差別是顯而易見的。&lt;/p&gt;
&lt;p&gt;當然，知道了為什麼之後，還是得知道怎麼做。總不能都說要放一千首歌在你的口袋，然後連個撥放器都造不出來吧，因此知道為什麼的人，還是需要那些知道怎麼做的人。不是說想到好棒的點子就趕快找認識的工程師朋友去咖啡廳泡茶，而是先知道為什麼的好處在於，你能夠區分出選擇有哪些。&lt;/p&gt;
&lt;p&gt;當你的信念是為了改變世界，你就不會考慮削價競爭。當你的訴求是「讓每個人躺上我們的沙發都像個國王！」你就不會考慮用抽換劣質棉花的方式來降低成本。&lt;strong&gt;先知道為什麼之後，有助於讓你的怎麼做變得清晰&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而當你的黃金圈趨向一致、平衡的時候，你的為什麼足夠清晰、具有號召力，怎麼做和做什麼都能展現出你的信念的時候，自然就能吸引到那些和你志同道合的人們，創造忠誠度和歸屬感。所以，與其要求所謂「忠誠」、「誠信」這些結果（如果還必須特地要求這些，那應該也是相當危險了），不如把自己的「為什麼」表達出來，有紀律地根據「為什麼」去貫徹「怎麼做」，讓黃金圈完善，那麼自然就能達到這些效果。&lt;/p&gt;
&lt;p&gt;就像我們在&lt;a href=&#34;https://igouist.github.io/post/2020/06/darkhorse&#34;&gt;前一篇《黑馬思維》的心得&lt;/a&gt;所說，先知道微動力之後，就能據此選擇適合的策略，所以選擇並不難，符合自己就好。如果你能先找出為什麼，那麼你該怎麼做的選擇就會縮小到符合為什麼的範圍，如此一來也就簡單多了。再拿我喜歡的卡牌遊戲舉例，當所有人的牌組都一致時，&lt;strong&gt;對於核心概念的理解程度就會呈現在策略方針的差別，進而決定最後的高度&lt;/strong&gt;。因此，想要做出明智的選擇，就先從問為什麼開始。&lt;/p&gt;
&lt;p&gt;為了表達「為什麼」與「怎麼做」之間的關係，作者提出了&lt;strong&gt;芹菜測試&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假設你去參加一個晚宴，忽然有朋友跑來告訴你，「你知道你的組織需要什麼嗎？M&amp;amp;M巧克力。不用M&amp;amp;M，根本就是有錢不去賺。」&lt;/p&gt;
&lt;p&gt;這時，另一個朋友又跑過來，說：「你知道自己該做什麼嗎？豆漿。研究顯示，現在每個人都在買豆漿。你應該賣豆漿才對。」&lt;/p&gt;
&lt;p&gt;當你站在雞尾酒桌旁邊的時候，另一位朋友又給你一個建議。「Oreo餅乾，」他說。「我們靠Oreo餅乾賺進了好幾百萬美元。你絕對要做Oreo餅乾。」&lt;/p&gt;
&lt;p&gt;這時又來了一個人，告訴你：「芹菜！你一定得做芹菜這門生意。」&lt;/p&gt;
&lt;p&gt;所有這些有成就的朋友給了你那麼多重要建議。有些人和你身處同一產業，有些人比你成功，有些人也給別人相同的建議，結果讓人受益匪淺。這時，你該怎麼辦？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;當你跑去超市把上面提到的東西一股腦都買了，在排隊付錢時，所有人看著你手上的東西，根本不知道你相信什麼。你做的事情應該體現你的目標，但你手上什麼都有。&lt;/p&gt;
&lt;p&gt;但如果在你去超市之前，先確認好自己的為什麼。假設你的目標是為了健康，那你就只會拿著豆漿跟芹菜。而從結果來說，你在超市花的時間和金錢也比較少，每個人也都能感覺得到你的理念。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你的一言一行，都要能證明你的信念。為什麼的本質就是信念。怎麼做，則是你實踐信念的行為，而做什麼則是這些行為的結果。《先問，為什麼》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作者在書中小心叮嚀不要走歪，所謂的走歪就是為什麼和怎麼做兩者漸行漸遠，手段開始不符理念，策略遠離目標的時候。由於怎麼做的操弄和策略通常是立即有效的，而為什麼的感召則是緩慢的、可能會停滯的。一旦鐵粉量飽和了、理念號召的做法陷入停滯時，多數人會不斷嘗試採取各種手段以求突破現況，這中間難免會為了立即的甜頭而走上了岔路。&lt;/p&gt;
&lt;p&gt;為了抓住所謂市場機會或是尋求突破等等，而使得「為什麼」和「怎麼做」脫鉤的時候，很可能造成原本的忠誠度下降，進而引發其他問題。長久以來就會變得危險，如同不斷追尋成長的殭屍，但&lt;a href=&#34;https://www.books.com.tw/products/0010825335&#34;&gt;世界上沒有所謂的『持續成長』&lt;/a&gt;，失去信念後盲目亂竄只是變成我們開頭舉例的那些公司的其中一員罷了。&lt;/p&gt;
&lt;p&gt;因此時刻檢驗自己的「為什麼」，自己的「怎麼做」和「做什麼」有沒有符合「為什麼」是相當重要的。&lt;/p&gt;
&lt;p&gt;換句話說，就是&lt;strong&gt;莫忘初衷&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;釐清自己的做什麼並非最困難的部分。真正難的是相信自己的直覺、堅持自己的願景、使命或信念。保持平衡與真誠才是最困難的部分。《先問，為什麼》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最後，這本書的副標和內容似乎都展現出是一本管理學書籍的感覺，例如企業、忠誠度、領導力等等。但作者也說了：每個組織或團體，都是由一個人或一小群人來的。就像我們前一篇黑馬思維的心得提過的，你要把你個人當一個品牌來經營。這些道理應用在個人的生活和行為也是相當符合的。&lt;/p&gt;
&lt;p&gt;如同作者所說的：&lt;strong&gt;我們永遠只能從我們自己開始&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最後就放一下作者書中提到的工人故事，在 &lt;a href=&#34;http://www.evanlin.com/reading-why-first/&#34;&gt;[好書分享] 先問，為什麼？&lt;/a&gt; 看到之後就蠻喜歡的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有一位哲學家到一個建築工地分別問三個正在砌築的工人說：「你在幹什麼？」&lt;/p&gt;
&lt;p&gt;第一個工人頭也不抬地說：「我在砌磚。」&lt;/p&gt;
&lt;p&gt;第二個工人抬了抬頭說：「我在砌一堵牆。」&lt;/p&gt;
&lt;p&gt;第三個工人熱情洋溢、滿懷憧憬地說：「我在建一座教堂！」&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;願各位都能找到心中的教堂，找到自己為何而戰，找到「為什麼」，共勉之。&lt;/p&gt;
&lt;h2 id=&#34;延伸閱讀及參考資料&#34;&gt;延伸閱讀及參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.evanlin.com/reading-why-first/&#34;&gt;[好書分享] 先問，為什麼？顛覆慣性思考的黃金圈理論，啟動你的感召領導力 - KKDAI.GITHUB.IO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.guccidgi.com/2020/02/start-with-why/&#34;&gt;先問為什麼 如何徹底改變了我所有的行為? - 追日Gucci&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.inside.com.tw/article/13179-start-with-why&#34;&gt;【硬塞書摘】感召領導力：你要得到更多客戶，還是創造鐵粉？ - 張柏崧&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;遺珠之憾&#34;&gt;遺珠之憾&lt;/h2&gt;
&lt;p&gt;作者在書中將黃金圈的三層，和大腦的結構對應起來，並將為什麼類比為我們的緣腦，掌控情感、信任、決策等等，同時將做什麼類比為我們的新皮質，掌控理性和分析。並且認為我們常有無法理性分析的直覺，並且常常證明是對的，作者將其和為什麼的信念連結在一起。對直覺和理性之間的互動有興趣的朋友，可以試著讀讀看&lt;a href=&#34;https://www.books.com.tw/products/0010780181&#34;&gt;《快思慢想》&lt;/a&gt;，或是看過網路上大大整理的&lt;a href=&#34;https://www.books.com.tw/products/0010780181&#34;&gt;系統一和系統二關係圖&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另外，書中還有一些段落並沒有節錄出來，例如用黃金圈和市場溝通，如何引爆趨勢（可以參見&lt;a href=&#34;https://wiki.mbalib.com/zh-tw/%E7%BD%97%E6%9D%B0%E6%96%AF%E7%9A%84%E5%88%9B%E6%96%B0%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B&#34;&gt;創新擴散理論&lt;/a&gt;和&lt;a href=&#34;https://wiki.mbalib.com/zh-tw/%E7%97%85%E6%AF%92%E5%BC%8F%E8%90%A5%E9%94%80&#34;&gt;病毒行銷&lt;/a&gt;），以及關於「為什麼」的一些不錯的例子（西南航空、沃爾瑪、福特）等等。如果有興趣的話，還是推薦可以入手一本來看看，這邊就附上 &lt;a href=&#34;https://www.books.com.tw/products/0010926506&#34;&gt;博客來&lt;/a&gt; 和 &lt;a href=&#34;https://www.kobo.com/tw/zh/ebook/1iky1ahewzexetqpe6mraw&#34;&gt;Kobo&lt;/a&gt; 連結。有興趣的朋友可以考慮入手看看呦！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C#: 時區轉換、民國西元、國曆農曆、中文月份週期</title>
      <link>https://igouist.github.io/post/2020/08/csharp-timezone/</link>
      <pubDate>Sun, 30 Aug 2020 11:58:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/08/csharp-timezone/</guid>
      <description>&lt;p&gt;聊到將時間從 UTC 轉到台灣時間，居然還是聽到朋友表示使用 +8 小時的做法，驚為天人。這種做法可能會造成後續的問題，例如時區並不會跟著變動，或是遇到日光節約等特殊狀況就容易出事。和西元民國轉換直接 -1911 一樣不穩定。&lt;/p&gt;
&lt;p&gt;這篇就用來記錄一下之前看過比較優雅的時區轉換方式，順便將先前存著的時間處理相關資料整理一下，方便之後需要時可以馬上回來查詢。&lt;/p&gt;
&lt;h2 id=&#34;timezoneinfo-時區資訊&#34;&gt;TimeZoneInfo: 時區資訊&lt;/h2&gt;
&lt;p&gt;轉換方式主要參考自 &lt;a href=&#34;https://dotblogs.com.tw/supershowwei/2016/10/17/141620&#34;&gt;[食譜好菜] DateTime 具有文化特性的格式化及時區的轉換&lt;/a&gt; 及 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/standard/datetime/converting-between-time-zones&#34;&gt;在各時區間轉換時間&lt;/a&gt;，感謝前人的指引。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;關於文化特性，也可以參考本站的 &lt;a href=&#34;https://igouist.github.io/post/2021/10/csharp-datatime-tostring-cultureinfo&#34;&gt;菜雞抓蟲: DateTime.ToString() 之我們不一樣 &amp;amp; CultureInfo 文化特性小筆記&lt;/a&gt; 呦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 假設現在是要從標準時區 +00:00 轉換到台灣時區，故這邊使用 UtcNow 先取標準世界協調時間&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; nowDateTime = DateTime.UtcNow;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;nowDateTime.ToString(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;yyyy/MM/dd H:mm:ss zzz&amp;#34;&lt;/span&gt;).Dump();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 2020/08/30 15:56:05 +00:00&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ==================================================&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 傳統的 直接對時間做計算的方式…&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; addedDateTime = nowDateTime.AddHours(&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;addedDateTime.ToString(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;yyyy/MM/dd H:mm:ss zzz&amp;#34;&lt;/span&gt;).Dump();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 2020/08/30 23:56:05 +00:00&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 可以看到儘管時間變動了，時區仍然還在 +00:00&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ==================================================&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 使用 TimeZoneInfo 先取得台北時區&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; timeZone = TimeZoneInfo.FindSystemTimeZoneById(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Taipei Standard Time&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 再使用 TimeZoneInfo 來變更時間&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; convertedDateTime = TimeZoneInfo.ConvertTime(nowDateTime, timeZone);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;convertedDateTime.ToString(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;yyyy/MM/dd H:mm:ss zzz&amp;#34;&lt;/span&gt;).Dump();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 2020/08/30 23:56:05 +08:00&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 可以看到除了時間變更以外，時區也切換到 +08:00 了！&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面取得台北時區的步驟，可以參照 &lt;a href=&#34;https://docs.microsoft.com/en-us/previous-versions/windows/embedded/gg154758(v=winembedded.80)&#34;&gt;Time Zone IDs&lt;/a&gt; 來查詢想要的時區。這樣的時區切換方式，不僅副作用少，不會因為時區沒轉雷到後續接手的人，也省卻了擔心日光節約等等問題，這種事就交給微軟去煩惱吧！&lt;/p&gt;
&lt;p&gt;另外這邊也逐步放一些時區處理相關的參考資料：&lt;/p&gt;
&lt;h2 id=&#34;taiwancalendar-西元年轉民國年-br-taiwanlunisolarcalendar-國曆轉農曆&#34;&gt;TaiwanCalendar: 西元年轉民國年 &lt;br/&gt; TaiwanLunisolarCalendar: 國曆轉農曆&lt;/h2&gt;
&lt;p&gt;可以參考這篇 &lt;a href=&#34;https://kevintsengtw.blogspot.com/2014/06/c.html&#34;&gt;基本題 - C# 西元年轉換取得民國年格式字串 - mrkt 的程式學習筆記&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;內文示範了使用 &lt;code&gt;System.Globalization.TaiwanCalendar&lt;/code&gt; 和 &lt;code&gt;System.Globalization.TaiwanLunisolarCalendar&lt;/code&gt; 來進行安全轉換的作法。&lt;/p&gt;
&lt;p&gt;基本上來說就是指定文化特性中的時間格式（曆法）為農曆，至少依靠微軟爸爸，比自己加減 1911 來得安全多了囧。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; time = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; DateTime(&lt;span style=&#34;color:#ae81ff&#34;&gt;2021&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 直接從 TaiwanCalendar 取民國年，自組字串時常用&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; taiwanCalendar = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; TaiwanCalendar();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;taiwanCalendar.GetYear(time).Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// 110&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 將文化特性的曆法改成民國年&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; info = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; CultureInfo(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;zh-TW&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;info.DateTimeFormat.Calendar = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; TaiwanCalendar();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 西元年轉民國年(字串)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;time.ToString(info).Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// 110/12/1 00:00:00&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 民國年(字串)轉西元年&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; timeString = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;110/12/1&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;DateTime.Parse(timeString, info).Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// 2021/12/01 00:00:00&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;datetimeformatinfo-月週時間的格式&#34;&gt;DateTimeFormatInfo: 月、週、時間的格式&lt;/h2&gt;
&lt;p&gt;不用再傻傻地手刻陣列「星期一」、「星期二」、「星期三」…之類的了，只要用 &lt;code&gt;DateTimeFormatInfo.CurrentInfo&lt;/code&gt; 的就好啦：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; MonthCh = DateTimeFormatInfo.CurrentInfo.MonthNames;   &lt;span style=&#34;color:#75715e&#34;&gt;// 中文月份名稱列表&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; MonthEn = DateTimeFormatInfo.InvariantInfo.MonthNames; &lt;span style=&#34;color:#75715e&#34;&gt;// 英文月份名稱列表&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/se7XLZy.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;除了月份以外，&lt;code&gt;DateTimeFormatInfo.CurrentInfo&lt;/code&gt; 也包含了當地的其他欄位與格式。&lt;/p&gt;
&lt;p&gt;例如 &lt;code&gt;AbbreviatedDayNames&lt;/code&gt; 能拿到 週一、週二、週三…；&lt;code&gt;DayNames&lt;/code&gt; 則會拿到 星期一、星期二、星期三…&lt;/p&gt;
&lt;p&gt;時間格式的話，&lt;code&gt;FullDateTimePattern&lt;/code&gt; 就會拿到 &lt;code&gt;yyyy&#39;年&#39;M&#39;月&#39;d&#39;日&#39; tt hh:mm:ss&lt;/code&gt; 等等&lt;/p&gt;
&lt;p&gt;內容還有許多欄位，有興趣的可以用 LinqPad 來 Dump 看看，或是直接翻閱 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/api/system.globalization.datetimeformatinfo?view=netcore-3.1&#34;&gt;DateTimeFormatInfo&lt;/a&gt; 囉！&lt;/p&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kevintsengtw.blogspot.com/2014/06/c.html&#34;&gt;基本題 - C# 西元年轉換取得民國年格式字串 - mrkt 的程式學習筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/supershowwei/2016/10/17/141620&#34;&gt;[食譜好菜] DateTime 具有文化特性的格式化及時區的轉換&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/supershowwei/2019/04/15/095324&#34;&gt;[桌邊服務] DateTime 本身有沒有包含時區的資訊？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/ricochen/2016/02/12/114642&#34;&gt;[C#]UTC時區轉換 - RiCo技術農場&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.miniasp.com/post/2010/04/30/Concept-DateTime-TimeZone&#34;&gt;釐清觀念：.NET 日期結構(DateTime) 與 時區轉換&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.darkthread.net/blog/compare-datetime-with-diff-timezone&#34;&gt;笨問題 - UTC 與本地時區 DateTime 比較&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/standard/base-types/custom-date-and-time-format-strings?redirectedfrom=MSDN&#34;&gt;自訂日期與時間格式字串 - Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/standard/datetime/converting-between-time-zones&#34;&gt;在各時區間轉換時間 - Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://siyuantw.blogspot.com/2015/07/c.html&#34;&gt;Siyuan的程式開發筆記: C#民國年西元年轉換 (siyuantw.blogspot.com)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Powershell 美化作戰 —— 字型、執行原則和 oh-my-posh</title>
      <link>https://igouist.github.io/post/2020/08/powershell-beauty/</link>
      <pubDate>Sat, 15 Aug 2020 18:00:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/08/powershell-beauty/</guid>
      <description>&lt;p&gt;最近在兩天內經歷了記憶體死去、系統毀損、機殼碎裂等等，終於電腦重灌。一堆設定都要重弄，正好也是個機會，這篇順手記一下常用好幫手 Powershell 的美化步驟。&lt;/p&gt;
&lt;p&gt;先放一張施工後的圖鎮樓：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/417skJs.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以在開始圖示上用右鍵打開選單，之後點選 Powershell；或是 Win + X 打開選單，然後按 I 或 A （後者會以系統管理員身分開啟）就能開啟了。&lt;/p&gt;
&lt;p&gt;如果選單打開還是 CMD 而不是 Powershell 的，可以先去切換成 Powershell，真的是比較好用啦（&lt;a href=&#34;https://www.microsoft.com/zh-tw/p/windows-terminal/9n0dx20hk701?activetab=pivot:overviewtab&#34;&gt;Windows Terminal&lt;/a&gt; 笑而不語）&lt;/p&gt;
&lt;p&gt;剛打開的畫面是這樣的：
&lt;img src=&#34;https://i.imgur.com/JE6BTSU.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;抱歉，光細明體我就不太行了。所以接下來就從字型這些內建設定開始！&lt;/p&gt;
&lt;h2 id=&#34;基本設定&#34;&gt;基本設定&lt;/h2&gt;
&lt;p&gt;在上方的標題列按下右鍵，選擇內容&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/MkWyIv7.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;首先就讓我們修改&lt;strong&gt;字型&lt;/strong&gt;，我這邊還是採用習慣的 &lt;a href=&#34;https://github.com/be5invis/Sarasa-Gothic&#34;&gt;更紗黑體&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另外還有一些推薦的字體，可以參閱前陣子整理的 &lt;a href=&#34;https://igouist.github.io/post/2020/03/visualstudio&#34;&gt;Visual studio 環境設定 —— 字型、套件、快捷鍵&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;補充：還有擴充了 &lt;a href=&#34;https://www.nerdfonts.com/cheat-sheet&#34;&gt;Nerd Fonts&lt;/a&gt; 的等距更紗黑體：&lt;a href=&#34;https://github.com/jonz94/Sarasa-Gothic-Nerd-Fonts&#34;&gt;Sarasa-Gothic-Nerd-Fonts&lt;/a&gt; 可以選擇，Nerd Fonts 能提供許多精美的 icon 讓我們後續改主題的時候大大加分！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/93httvP.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;除了字型以外，我個人還推薦可以修改一個設定，保證質感 UPUP，那就是&lt;strong&gt;透明度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/OGR98I8.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我個人習慣採用 80~85% 左右的透明度，搭配黑色背景。在桌面使用的時候看起來就像這樣：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/XBFVEmU.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以拉回去和一開始的預設狀況做比較，透明感＝質感。&lt;/p&gt;
&lt;p&gt;另外，背景透明還有意想不到的好處，那就是——&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/4Yh5SvJ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;打指令偷看可以不用切換視窗！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基於以上兩點，推薦可以調整透明度，找個適合自己的區間。但要注意，如果太透明的話會讓字跟背景糊在一起，很容易眼花，自己斟酌一下。&lt;/p&gt;
&lt;p&gt;以上就做完了基本設定，沒意外要做兩次（一般身分和系統管理員）&lt;/p&gt;
&lt;h2 id=&#34;安裝-posh-git&#34;&gt;安裝 posh-git&lt;/h2&gt;
&lt;p&gt;然而我們並不打算在此停止！因緣際會之下，我拜讀了這篇 &lt;a href=&#34;https://blog.poychang.net/setting-powershell-theme-with-oh-my-posh/&#34;&gt;使用 oh-my-posh 美化 PowerShell 樣式&lt;/a&gt;，頓時驚為天人，跟預設的（請自己再拉回去比對第一張圖）實在是相當有差距，於是當時就直接安裝下來了。&lt;/p&gt;
&lt;p&gt;畢竟這是第二次安裝了，接下來的區段就記錄一下安裝 &lt;a href=&#34;https://github.com/JanDeDobbeleer/oh-my-posh&#34;&gt;oh-my-posh&lt;/a&gt; 主題的流程。&lt;strong&gt;oh-my-posh&lt;/strong&gt; 是受到 Linux 上 &lt;a href=&#34;https://github.com/ohmyzsh/ohmyzsh&#34;&gt;oh-my-zsh&lt;/a&gt; 的&lt;strong&gt;啟發&lt;/strong&gt;誕生的，總之就是個挺讚讚的主題載入工具。&lt;/p&gt;
&lt;p&gt;而且安裝相當方便，只需要從 Microsoft Store 或直接打 &lt;code&gt;Install-Module&lt;/code&gt; 指令，就能從 &lt;a href=&#34;https://www.powershellgallery.com/&#34;&gt;PowerShell Gallery&lt;/a&gt; 把模組安裝下來囉！&lt;/p&gt;
&lt;p&gt;在安裝 oh-my-posh 之前，由於顯示的內容包含 Git ，因此我們還要先下載另一個套件 &lt;code&gt;posh-git&lt;/code&gt;。讓我們用&lt;strong&gt;系統管理員&lt;/strong&gt;身份開啟 Powershell，並輸入以下指令來進行安裝：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Install-Module posh-git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;到這一步，會有幾種狀況：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提示安裝 NuGet：安裝就行了&lt;/li&gt;
&lt;li&gt;提示不安全儲存庫：安啦，選是就對了&lt;/li&gt;
&lt;li&gt;跳出錯誤，顯示「因為這個系統上已停用指令碼執行」云云，則接著看下一段落&lt;/li&gt;
&lt;li&gt;什麼事都沒發生，很順利地裝好了，請跳過下一段落&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;執行原則&#34;&gt;執行原則&lt;/h2&gt;
&lt;p&gt;如果跳出「因為這個系統上已停用指令碼執行…」的情況，代表遇到&lt;strong&gt;執行原則&lt;/strong&gt;的部份。因為安全性考量，預設是不能執行 Powershell 腳本的，連帶也不能使用 Install-Module 這類方法。&lt;/p&gt;
&lt;p&gt;關於執行原則，可以參閱這篇 &lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10028377&#34;&gt;Windows PowerShell 基本操作 - 執行 Windows PowerShell 腳本&lt;/a&gt; 的說明。該系列也挺實用的，值得一看，這邊我們就節錄一段來說明執行原則的種類：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Restricted&lt;/strong&gt; ：&lt;strong&gt;關閉腳本檔的執行功能&lt;/strong&gt;，這是&lt;strong&gt;預設&lt;/strong&gt;的設定值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AllSigned&lt;/strong&gt; ：只允許執行&lt;strong&gt;受信任發行者&lt;/strong&gt;簽署過的腳本檔。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RemoteSigned&lt;/strong&gt; ：在&lt;strong&gt;本機電腦所撰寫的腳本檔，不需要簽署就可執行&lt;/strong&gt;；但是從網際網路（例如：email、MSN Messenger）下載的腳本檔就必須經過受信任發行者的簽署才能執行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Unrestricted&lt;/strong&gt; ：&lt;strong&gt;任何腳本檔皆可被執行&lt;/strong&gt;，但是於執行網際網路下載的腳本檔時，會先出現警告的提示視窗。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果要確認目前的執行原則，可以使用 &lt;code&gt;Get-ExecutionPolicy&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;這個分類也是為了保護使用者，不要亂執行一些來路不行了奇怪腳本，整個電腦打包起來送人。不過我們身為 &lt;del&gt;白目&lt;/del&gt; 工程師，難免會有要裝套件和自己寫腳本的時候，這邊就直接調整為 Unrestricted 全面開啟吧！&lt;/p&gt;
&lt;p&gt;調整執行原則的語法如下（必須在系統管理員身分時才有效果呦）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Set-ExecutionPolicy Unrestricted
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;調整完就可以繼續下載囉！&lt;/p&gt;
&lt;p&gt;像我重灌的狀況，提示會如下圖，如果已經安裝過 Nuget 提供者，提示應該會更少。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/UoGkW7o.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;安裝-oh-my-posh&#34;&gt;安裝 oh-my-posh&lt;/h2&gt;
&lt;p&gt;接著讓我們安裝 oh-my-posh：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Install-Module oh-my-posh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/LQuE2hD.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;安裝完畢後就可以來試試看囉！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;更新：Oh-my-posh 也可以從 Microsoft 搜尋並安裝囉！&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/3WoVsvL.jpg&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;設定主題&#34;&gt;設定主題&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;更新：由於 Oh-my-posh 設定主題的語法已經改變，因此移除 2020 時的內容，改為 2023 重灌電腦時找到的指令。&lt;/p&gt;
&lt;p&gt;因為 Oh-my-posh 還蠻頻繁更新的，建議後續的操作可以開著 &lt;a href=&#34;https://ohmyposh.dev/docs/installation/customize&#34;&gt;Oh My Posh&lt;/a&gt; 的官方文檔來排查一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;要更改主題的話，我們會需要使用 &lt;code&gt;oh-my-posh init pwsh&lt;/code&gt; 這個指令，並且將該主題的 Json 檔案傳遞給 &lt;code&gt;--config&lt;/code&gt;&lt;/strong&gt;，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;oh-my-posh init pwsh --config &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$env&lt;span style=&#34;color:#e6db74&#34;&gt;:POSH_THEMES_PATH/powerlevel10k_rainbow.omp.json&amp;#34;&lt;/span&gt; | Invoke-Expression
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我們丟了一個 powerlevel10k_rainbow 這個主題的 Json 檔案路徑給 oh-my-posh，然後呼叫 &lt;code&gt;Invoke-Expression&lt;/code&gt; 執行它，這時候主題就會變啦～&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;補充：這邊用到一組環境變數 &lt;code&gt;$env:POSH_THEMES_PATH&lt;/code&gt; 實際上是一個資料夾路徑，Oh-my-posh 安裝的主題都會放在這個資料夾裡：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/lWBHJc3.jpg&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果你有自己下載的主題，可以也丟到 &lt;code&gt;POSH_THEMES_PATH&lt;/code&gt; 的位置，或是直接更改 &lt;code&gt;--config&lt;/code&gt; 的路徑就可以了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每個主題的樣式都不大一樣，可以翻一下 Oh-my-posh 的 &lt;a href=&#34;https://ohmyposh.dev/docs/themes&#34;&gt;Themes&lt;/a&gt; 頁面挑個喜歡的。&lt;/p&gt;
&lt;h2 id=&#34;撰寫腳本&#34;&gt;撰寫腳本&lt;/h2&gt;
&lt;p&gt;聰明的你一定發現了，每次重開都要重輸入一次 &lt;code&gt;init&lt;/code&gt; 實在是很麻煩。因此我們接著要設定讓它能一打開就載入主題。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;當 Powershell 開啟時，預設會去讀取使用者的設定檔（Profile）&lt;/strong&gt;，我們就是要把這些指定加到設定檔裡，讓 Powershell 一打開就能美美的。&lt;/p&gt;
&lt;p&gt;在 Powershell 裡輸入 &lt;code&gt;$PROFILE&lt;/code&gt; 就能取得當前的設定檔位置，通常來說會在 &lt;code&gt;我的文件\WindowsPowerShell&lt;/code&gt; 底下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/kRKV112.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;補充：Powershell 啟動時會依序檢查四個位置來載入設定檔，分別為&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有使用者及所有 Shell: &lt;code&gt;$PSHOME\profile.ps1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;所有使用者的 Powershell: &lt;code&gt;$PSHOME\Microsoft.PowerShell_profile.ps1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;目前登入者的所有 Shell: &lt;code&gt;$Home\My Documents\WindowsPowerShell\profile.ps1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;目前使用者的 Powershell: &lt;code&gt;$Home\My Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中的變數&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$PSHOME&lt;/code&gt; 是指 Powershell 的安裝目錄，通常在 system32 的 WindowsPowerShell 底下&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$Home&lt;/code&gt; 則是使用者的主目錄，也就是大家熟悉的 users/{你的名稱}&lt;/li&gt;
&lt;li&gt;而前面提到的 &lt;code&gt;$PROFILE&lt;/code&gt; 就是指「目前使用者的 Powershell」這組&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;對設定檔有興趣的朋友可以參照保哥的文章及官方文檔：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.miniasp.com/post/2013/01/02/How-to-auto-load-ps1-script-using-Windows-PowerShell-Profiles&#34;&gt;如何在 Powershell 開啟時自動引入常用的 ps1 指令檔腳本 | The Will Will Web&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/powershell/module/microsoft.powershell.core/about/about_profiles?view=powershell-7.2&#34;&gt;關於設定檔 - PowerShell | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;接著我們就前往此處去修改 Powershell 的腳本，如果發現並沒有這個檔案，那還請自己建立一個，檔名和路徑請和 &lt;code&gt;$PROFILE&lt;/code&gt; 一致，像我就取 &lt;code&gt;Microsoft.PowerShell_profile.ps1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/eJ8A5iY.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;之後開啟檔案，貼上我們引入套件和設定主題的指令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ps1&#34; data-lang=&#34;ps1&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;oh-my-posh init pwsh --config &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$env:POSH_THEMES_PATH&lt;span style=&#34;color:#e6db74&#34;&gt;/powerlevel10k_rainbow.omp.json&amp;#34;&lt;/span&gt; | Invoke-Expression
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;再次補充：oh-my-posh 改版之後一些語法有改變，如果有在 &lt;code&gt;Set-Theme&lt;/code&gt; 這步的時候遇到「無法辨識…」問題的朋友，可以嘗試改成用 &lt;code&gt;Set-PoshPrompt -Theme Paradox&lt;/code&gt; 試試看。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接著讓我們重開 Powershell&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/1kYjQSO.jpg&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看見它已經順利載入主題囉！&lt;/p&gt;
&lt;p&gt;因為我覺得切主題前跑那些 Powershell 提示之類的有點醜，所以我會回去 Profile 補一行 Clear：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ps1&#34; data-lang=&#34;ps1&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;oh-my-posh init pwsh --config &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$env:POSH_THEMES_PATH&lt;span style=&#34;color:#e6db74&#34;&gt;/powerlevel10k_rainbow.omp.json&amp;#34;&lt;/span&gt; | Invoke-Expression
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;clear
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;也可以在這裡寫一些 function 來使用，像我個人之前做 &lt;a href=&#34;https://igouist.github.io/post/2020/03/bandon-1-selenium&#34;&gt;我要訂便當&lt;/a&gt; 因為懶得每次都 cd 到腳本所在的位置還要 Pyhton 執行，所以就直接包成 &lt;code&gt;Get-Bandon&lt;/code&gt; 的方法直接叫，真的舒服，推薦嘗試&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果有想要自己試試新增主題，或是想像我一樣做小修改的，可以到 &lt;code&gt;$env:POSH_THEMES_PATH&lt;/code&gt; 這個路徑的資料夾，找到 &lt;code&gt;.omp.json&lt;/code&gt; 檔案來動手&lt;/p&gt;
&lt;p&gt;例如說把 &lt;code&gt;powerlevel10k_rainbow.omp.json&lt;/code&gt; 開啟後，就可以看見組出那一串資訊的過程，也就可以隨意更改囉。我就特愛把一些 icon 都改成 &lt;code&gt;°д°&lt;/code&gt;，感覺活潑多了（？）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;補充：該路徑會根據安裝 &lt;code&gt;oh-my-posh&lt;/code&gt; 的位置而變動，基本上開 Powershell 直接從環境變數的路徑下去找比較快。真的找不到的話也可以下載別人的主題改一改，再修改 `&amp;ndash;config`` 的路徑指到自己改好的 json 就好囉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;順便提一下，載入使用者設定對用到 Powershell 的地方都有效喲！&lt;/p&gt;
&lt;p&gt;例如 Visual Studio Code 的 Powershell&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/fqtRmwR.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;或是 Visual Studio 的開發人員用 Powershell&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ulEehB0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;都是會吃到個人使用者的設定的。&lt;/p&gt;
&lt;p&gt;那麼今天就到這裡，最後再把完成品跟預設狀況比對一次吧～&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/JE6BTSU.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/99DaSVP.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;2023 回來更新文章，順便附個現況：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/JOVI7hg.jpg&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;同場加映：&lt;/p&gt;
&lt;p&gt;跟朋友志得意滿地說明了 Powershell 美化作戰後，對方只說了淡淡的一句&lt;/p&gt;
&lt;p&gt;「哦，我都直接 &lt;a href=&#34;https://cmder.app/&#34;&gt;Cmder&lt;/a&gt;」&lt;/p&gt;
&lt;p&gt;那又是另一個故事了……&lt;/p&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.poychang.net/setting-powershell-theme-with-oh-my-posh/&#34;&gt;使用 oh-my-posh 美化 PowerShell 樣式 - POY CHANG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ppundsh.github.io/posts/ad6e/&#34;&gt;PowerShell 美化：oh my posh - Flymia 凡事用心之事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pcion123.github.io/2020/03/08/powershell-improve/&#34;&gt;美化PowerShell - oh-my-posh - Pcion&amp;rsquo;s note&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10028377&#34;&gt;Windows PowerShell 基本操作 - 執行 Windows PowerShell 腳本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://officeguide.cc/powershell-set-execution-policy-remote-signed/&#34;&gt;PowerShell 更改執行原則，解決無法執行 ps1 指令稿問題&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>C#: 字串插值 (String interpolation) 的格式化</title>
      <link>https://igouist.github.io/post/2020/08/csharp-string-interpolation/</link>
      <pubDate>Sun, 09 Aug 2020 20:35:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/08/csharp-string-interpolation/</guid>
      <description>&lt;p&gt;自從 C# 有了 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/csharp/language-reference/tokens/interpolated&#34;&gt;字串插值&lt;/a&gt; 這東西之後，我就一直是愛用者。畢竟比起 &lt;code&gt;string.format&lt;/code&gt; 這東西可是看起來優雅多了。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;哈囉，{userName} 您的點數將於 {cutoffTime} 到期。&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;簡潔又明瞭，一眼就能理解字串內容。實在是挺方便，後來發現這東西還有一些延伸用法，這邊就稍加紀錄一下：&lt;/p&gt;
&lt;p&gt;字串插值中能夠做&lt;strong&gt;簡易計算&lt;/strong&gt;，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;您輸入的數值為：{a}、{b}。他們相加為：{a + b}&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;同時，在字串插值時可以針對內容作格式化，只需要用 &lt;code&gt;:&lt;/code&gt; 來區隔，妥善運用可以省下一堆 &lt;code&gt;ToString()&lt;/code&gt; 的空間。&lt;/p&gt;
&lt;p&gt;例如當我們要將&lt;strong&gt;時間&lt;/strong&gt;格式化的時候，就可以：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; date = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; DateTime(&lt;span style=&#34;color:#ae81ff&#34;&gt;2020&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;您的商品已於 {date:yyyy/MM/dd} 抵達。&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 您的商品已於 2020/08/09 抵達。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外，&lt;strong&gt;數值&lt;/strong&gt;當然也可以格式化，不過數值的應用比較複雜，主要是用來定下小數點、百分比等符號的位置。
可以參見 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/standard/base-types/custom-numeric-format-strings&#34;&gt;自訂數值格式字串 - Microsoft Docs&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; cost = &lt;span style=&#34;color:#ae81ff&#34;&gt;2100&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message1 = &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;您的商品一共是 {cost:#,###} 元&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 用 # 可以替數字預留位置&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 您的商品一共是 2,100 元&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message2 = &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;您的商品一共是 {cost:#,###.00} 元&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 也可以用 0 來預留位置，若該數字有值就會顯示該數字，沒有就會自動補 0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 您的商品一共是 2,100.00 元&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而格式化也支援&lt;strong&gt;列舉&lt;/strong&gt;，在同時顯示列舉的意義和值的時候會很有幫助：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// public enum Color { Red = 1, Blue = 2, Green = 3 };&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; color = Color.Blue;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;編號 {color:D} 是 {color:G}&amp;#34;&lt;/span&gt;.Dump();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 編號 2 是 Blue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;承上部分，由於 &lt;code&gt;:&lt;/code&gt; 在字串插值裡已經有特殊意義了，因此想在字串插值中使用&lt;strong&gt;三元運算子&lt;/strong&gt;，必須先用 &lt;code&gt;( )&lt;/code&gt; 括起來，如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;您的包裹 {(isArrival ? &amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;已&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; : &amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;尚未&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;)} 抵達門市&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;對字串插值有興趣的朋友，也可用&lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/csharp/tutorials/exploration/interpolated-strings&#34;&gt;微軟官方的教學課程&lt;/a&gt;來試試呦。&lt;/p&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/eyelash/2019/07/06/205834&#34;&gt;【C# 6.0】字串插補（更容易插入變數） - EY＊研究院&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/csharp/language-reference/tokens/interpolated&#34;&gt;字串插值 - Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/csharp/tutorials/string-interpolation&#34;&gt;C# 中的字串插補 - Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/standard/base-types/custom-numeric-format-strings&#34;&gt;自訂數值格式字串 - Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/standard/base-types/enumeration-format-strings&#34;&gt;列舉格式字串 - Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/standard/base-types/formatting-types&#34;&gt;.NET 中的格式類型 - Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>C#: 使用 System.Environment 取得環境資訊、特殊資料夾路徑</title>
      <link>https://igouist.github.io/post/2020/08/system-environment/</link>
      <pubDate>Sun, 02 Aug 2020 13:31:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/08/system-environment/</guid>
      <description>&lt;p&gt;有時候我們會需要取得一些系統資訊，例如說取得設備和當前使用者等資料來寫 Log，或是取得特殊資料夾路徑、讀取環境變數等等。這些時候就可以使用 &lt;code&gt;System.Environment&lt;/code&gt; ，這邊就稍微紀錄一下用法。&lt;/p&gt;
&lt;p&gt;先列出幾個常用的&lt;strong&gt;環境資訊&lt;/strong&gt;，詳細可查詢的內容可以到 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/api/system.environment?view=netcore-3.1&#34;&gt;Environment Class&lt;/a&gt; 查詢：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/8L67T46.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;資料夾路徑&lt;/strong&gt;則需要用 &lt;code&gt;Environment.GetFolderPath&lt;/code&gt; 搭配 &lt;code&gt;Environment.SpecialFolder&lt;/code&gt; 列舉使用，該列舉包含資料夾可以到 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/api/system.environment.specialfolder?view=netcore-3.1&#34;&gt;Environment.SpecialFolder Enum&lt;/a&gt; 查詢。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/aOQ30KB.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;除此之外還有一些實用的方法，例如用 &lt;code&gt;GetEnvironmentVariable&lt;/code&gt; 取得&lt;strong&gt;環境變數&lt;/strong&gt;，如此就可以將部分資訊交由環境變數來決定：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/pRj4yEA.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;而最常用的應該就是 NewLine 了，畢竟不同環境的&lt;strong&gt;換行符號&lt;/strong&gt;可能會不同，養成用 NewLine 的習慣總是好的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/jvjNnJK.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://jjnnykimo.pixnet.net/blog/post/21585496&#34;&gt;C# 取得系統特殊目錄及環境變數 - 狼翔天地&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://apmtechtony.blogspot.com/2017/09/c-environmentspecialfolder.html&#34;&gt;C# 取得系統特殊目錄及環境變數 Environment.SpecialFolder 與 Environment.GetEnvironmentVariable 差別&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>