<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>w3HexSchool on 伊果的沒人看筆記本</title>
    <link>https://igouist.github.io/tags/w3hexschool/</link>
    <description>Recent content in w3HexSchool on 伊果的沒人看筆記本</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hant-TW</language>
    <follow_challenge>
      <feedId>56200764111934464</feedId>
      <userId>41821085092905984</userId>
    </follow_challenge>
    <lastBuildDate>Sun, 20 Dec 2020 23:57:00 +0800</lastBuildDate><atom:link href="https://igouist.github.io/tags/w3hexschool/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>菜雞與物件導向 (15): 最少知識原則</title>
      <link>https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle/</link>
      <pubDate>Sun, 20 Dec 2020 23:57:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/FOWZ8zY.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;上一篇&lt;/a&gt;我們紀錄了依賴反轉原則，到此五大原則介紹完畢…是這樣嗎？太天真了！就像四天王總是五個人一樣，五大原則當然也有第六個！&lt;/p&gt;
&lt;p&gt;今天的主角就是五大原則中Ｌ位的第一候補：&lt;strong&gt;最少知識原則&lt;/strong&gt;，也被稱作&lt;strong&gt;迪米特法則&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;最少知識原則-least-knowledge-principle&#34;&gt;最少知識原則 (Least Knowledge Principle)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;只和直接的朋友溝通，不和陌生人說話&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那麼所謂的朋友是什麼呢？就是指這個物件或方法有直接相關的物件啦。例如當我們使用一個方法時，這個方法應該只認識：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;該方法所屬的類別&lt;/li&gt;
&lt;li&gt;該方法所接收的參數&lt;/li&gt;
&lt;li&gt;該方法中建立的類別&lt;/li&gt;
&lt;li&gt;該方法所屬的類別所依賴的對象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外對這個方法而言都是陌生人。什麼情況會遇到陌生人呢？有一個蠻常遇到的狀況就符合定義：當我們使用依賴對象的方法，該方法給了我們另一個類別時，我們就正在接觸毫無關係的陌生人。&lt;/p&gt;
&lt;p&gt;這個原則的要求就是：不要跟陌生人說話，就算是朋友介紹了他的朋友給你也一樣，不認識就是不認識，更不能拿陌生人的東西。換個方式就是說：&lt;strong&gt;不應該使用其他類別的方法所回傳的類別的方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;用文字的可能會有點繞口令，簡單來說就是像 &lt;code&gt;Foo.GetBoo().BooDoSomeThing()&lt;/code&gt; 這種情況，我們不該去跟 &lt;code&gt;Foo&lt;/code&gt; 要 &lt;code&gt;Boo&lt;/code&gt; 回來然後使用 &lt;code&gt;Boo&lt;/code&gt; 的方法，因為我們只認識 &lt;code&gt;Foo&lt;/code&gt;，而不認識 &lt;code&gt;Boo&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;畢竟，很多時候我們不該直接插手控制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主人可以叫狗坐下，但主人不應該直接控制狗的腿坐下&lt;/li&gt;
&lt;li&gt;當我們按下牆壁的開關時，是希望燈直接打開。而不是彈出兩條電線讓你自己接起來&lt;/li&gt;
&lt;li&gt;當我們去餐廳時，會讓服務生替你把要求的餐點交給廚師烹調，而不是我們直接殺進去廚房對著廚師吼「你給我煮啊！」&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這種直接叫廚師煮給你看、甚至自己搶過來煮的做法，就是平常直接伸手進去其他模組的控制狂、完全和 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;封裝&lt;/a&gt; 的概念背道而馳。&lt;/p&gt;
&lt;p&gt;腿的動作就應該讓狗去自己控制，讓燈泡亮就應該隱藏在開關之後。物件就該只和直接的朋友溝通。&lt;/p&gt;
&lt;p&gt;除了只和直接的朋友溝通，也就是只和直接依賴的類別互動，這個互動也是要講究一點的。畢竟朋友之間也還是會有共通的默契和距離，類別之間的互動也應該只做必要的溝通。&lt;/p&gt;
&lt;p&gt;這就是我們在封裝提過的「給程式碼隱私的空間」：為了避免物件之間的互動情況過於複雜，我們應該加以控制，把各自的工作封裝在各自的物件內部，使其只有必要的往來。&lt;/p&gt;
&lt;p&gt;因此最少知識原則就要求了：&lt;strong&gt;一個物件應該對其他物件應該只有最少的了解&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;到這邊讓我們稍微整理一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只和直接的朋友溝通，不和陌生人說話：物件或方法應該只和自己及直接接觸的對象互動&lt;/li&gt;
&lt;li&gt;不應該使用其他類別的方法回傳的類別的方法：不該破壞封裝並造成額外且違反邏輯的互動&lt;/li&gt;
&lt;li&gt;一個物件對其他物件應該只有最少的了解：類別只開放 (Public) 必要的功能，並且類別之間應該只有必要的互動&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是說：&lt;strong&gt;只依賴應該依賴的對象，只開放應該開放的方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;聰明的朋友應該能從這邊看出最少知識原則的核心理念了，就是&lt;strong&gt;解除耦合&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我們在 &lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;耦合篇&lt;/a&gt; 提過，物件彼此有關聯就會產生耦合，而不好的耦合就會散發出臭味。為了方便管理和降低複雜性，減少臭味出現的機率，我們的目標就是追求耦合。&lt;/p&gt;
&lt;p&gt;相對於 &lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;依賴反轉原則&lt;/a&gt; 利用 &lt;a href=&#34;https://igouist.github.io/post/202007-oo-7-interface&#34;&gt;抽象和介面&lt;/a&gt; 的方式在模組之間做出隔離和控制的作法。最少知識原則則是利用 &lt;a href=&#34;https://igouist.github.io/post/202007-oo-3-encapsulation&#34;&gt;封裝&lt;/a&gt; 的概念來解除耦合，畢竟，關聯越少耦合也越少嘛。&lt;/p&gt;
&lt;p&gt;所以我們可以說：良好的封裝就是符合最少知識原則的封裝。複雜性隱藏到自己內部，對外只開放必要的功能，並且只使用到直接關聯的對象，確保不會造成意外的耦合，且讓關聯的模組之間更加靠攏。如此一來，就能夠更加提高內聚、降低耦合了。&lt;/p&gt;
&lt;p&gt;然而，為了好好地切分朋友和陌生人，也可能會變成需要&lt;strong&gt;建立更多的中間類別&lt;/strong&gt;，或是更多的依賴關係。&lt;/p&gt;
&lt;p&gt;例如人原本可以直接把電線接起來讓燈泡亮起來，但為了把電線使燈泡變亮這件事的複雜度封裝起來，我們就必須要有一個開關，再把電線放到開關後面去，變成了人按下開關，開關藉由電線點亮燈炮等等，整體來說會使系統內的類別變多。&lt;/p&gt;
&lt;p&gt;因此，在設計的時候也必須要考量到整個方法串的深度，可以用 &lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;單一職責&lt;/a&gt; 的角度下去衡量。請不要越封裝越細，類別越做越多，反而變成過度設計了。&lt;/p&gt;
&lt;p&gt;那麼，今天就記錄到這裡。由於最少知識原則的概念，大多在封裝篇和耦合篇的時候就已經偷渡完了，所以這邊就針對觀念簡單介紹，實務上處理類別間的耦合時，就可以稍微從最少知識原則的角度想一想，一定會有幫助的。那麼，我們下次見～&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列下一篇：&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/hatelove/2010/10/16/least-knowledge-principle&#34;&gt;[ASP.NET]91之ASP.NET由淺入深 不負責講座 Day19 - LoD/LKP 最少知識原則 - In 91&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@ckpattern35/ck-patt-%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F-11-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%89%87-demeter-law-931fefc4abda&#34;&gt;[CK Patt 設計模式#11] 迪米特法則(Demeter Law)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yuchitung.github.io/2019/06/24/least-knowledge-principle/&#34;&gt;最小知識原則 - Yuchi 的學習筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-3_law-of-demeterlod-%E7%8B%84%E7%B1%B3%E7%89%B9%E6%B3%95%E5%89%87/&#34;&gt;Object Oriented物件導向設計原則SOLID-3:Law of Demeter(LoD) 狄米特法則 - Sian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://c.biancheng.net/view/1331.html&#34;&gt;迪米特法則——面向對象設計原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/gaochundong/p/least_knowledge_principle.html&#34;&gt;最少知识原则（Least Knowledge Principle） - 熵碼匠藝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ithome.com.tw/voice/98670&#34;&gt;封裝與迪米特法則 - 林信良&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同系列文章&#34;&gt;同系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (14): 依賴反轉原則</title>
      <link>https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle/</link>
      <pubDate>Sun, 13 Dec 2020 21:53:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ywiHuis.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在聊依賴反轉之前，先讓我們聊聊什麼是依賴，所謂的依賴就是一種「受到某個東西影響、牽制」的狀態。&lt;/p&gt;
&lt;p&gt;例如說如果有個像我一樣的肥宅每天一定要來一片雞排才能療癒身心，那我就是依賴雞排；&lt;br/&gt;
同樣的，如果有個大叔不抽菸就會全身不舒服，就是對香菸有所依賴。&lt;/p&gt;
&lt;p&gt;當有「必須要藉由某個人事物來達到目的」的狀況時，就是依賴。&lt;/p&gt;
&lt;p&gt;而在程式設計裡面的概念也差不多，如果&lt;strong&gt;Ａ模組直接受到Ｂ模組的影響，我們就稱Ａ依賴了Ｂ&lt;/strong&gt;，最明顯的狀況就是Ａ模組需要藉由Ｂ模組的實例來完成某個功能的時候。&lt;/p&gt;
&lt;p&gt;例如「匯出報表」功能建立了一個「Excel 控制類別」的實例以建立檔案；&lt;br/&gt;
或是「會員查詢」功能建立了一個「DB 連線」的實例來進入資料庫取得會員資料&lt;/p&gt;
&lt;p&gt;遇見這種「必須要藉由某個模組的實例來完成想要的動作」的狀況時，就是依賴。&lt;/p&gt;
&lt;h2 id=&#34;依賴與耦合&#34;&gt;依賴與耦合&lt;/h2&gt;
&lt;p&gt;我們在之前的 &lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;耦合篇&lt;/a&gt; 提過，如果模組和另一個模組之間有關連，那這兩者之間就耦合。以此來看，依賴就是一種耦合的關係，那麼，依賴是健康還是不健康的耦合呢？&lt;/p&gt;
&lt;p&gt;現在讓我們用 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;多型篇&lt;/a&gt; 用過的「老闆徵工程師」的例子來舉例一下：現在有間小小公司，老闆請來了小明當工程師，並請他開工撰寫產品程式碼。&lt;/p&gt;
&lt;p&gt;當「撰寫產品程式」對「工程師」直接依賴的時候，狀況可能是這樣的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Product Work()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Ming programmer = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Ming();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; product = programmer.Programming();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; product;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;過一陣子，老闆發現小明寫出來的東西似乎不太行，於是把小明趕走，另外請了小華。這時候因為「工程師」這個實作類別不一樣了，我們就必須要改一次程式碼：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Product Work()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Hua programmer = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Hua();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; product = programmer.Programming();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; product;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;又過了好一陣子，老闆又另外請了小美來工作。於是又要再改一次，而且小美的工作方式甚至不叫做 &lt;code&gt;Programming&lt;/code&gt;，而是 &lt;code&gt;Coding&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Product Work()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Mei programmer = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Mei();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; product = programmer.Coding();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; product;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;現在有感覺到一點問題了嗎？如果一直換人，&lt;code&gt;Work&lt;/code&gt; 的程式碼豈不是每次都要修改？甚至根據依賴對象的不同，連使用方式都可能受到影響，很明顯這樣就是所謂不健康的耦合。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這邊還有個例子我很喜歡，在這篇 &lt;a href=&#34;https://notfalse.net/1/dip&#34;&gt;依賴倒置原則&lt;/a&gt; 的文章中，用吃東西來舉例：如果寫死了依賴漢堡，難道一輩子就只能吃漢堡了嗎？如果想改成吃義大利麵，就要修改程式碼；有一百種食物，難道就要改一百次嗎？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;試想，因為「DB 的連線方法」有了一些變更，使用到該方法的「會員查詢」就連帶要更動，甚至有關聯的地方都必須要變動，如此一來改動的範圍如森林大火般延燒。&lt;/p&gt;
&lt;p&gt;同時由於我們在開發功能的時候，都是讓大功能（高階模組）調用各個小功能（低階模組）來實現目標，越高層的就越整體、越抽象、越接近目標；而越低階就越細節、越接近實作，關注點越小。而我們的思維通常是由大範圍往下到小實作，從整體目標逐漸拆解成各個步驟。&lt;/p&gt;
&lt;p&gt;但是，當我們的高階模組直接依賴低階模組的時候，事情就會變得有點怪怪的。就像董事長必須清潔廁所導致沒空進行公司決策一樣，&lt;strong&gt;原本職責在於高層次、整體的模組，卻不得不因為這些低階模組的變動受到影響&lt;/strong&gt;。那麼隨著層次越高，底下依賴的模組越多，改動的頻率就會提高。&lt;/p&gt;
&lt;p&gt;既然改動範圍又大，改動頻率又高，耦合又不健康，就代表這樣的依賴是有問題的。然而，物件導向的精神就在於讓物件之間互相協作，消除多餘的重複。因此，依賴又是不可能消除的。&lt;/p&gt;
&lt;h2 id=&#34;依賴反轉原則-dependency-inversion-principle&#34;&gt;依賴反轉原則 (Dependency-Inversion Principle)&lt;/h2&gt;
&lt;p&gt;面對這樣的困境，依賴反轉原則告訴我們：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;高階模組不應該依賴於低階模組。兩者都應該依賴抽象。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是的，不應該直接去依賴，而是必須藉由抽象來隔開。不應該直接去受到實作的影響，而是只要關注在所需要的功能。&lt;/p&gt;
&lt;p&gt;這部分其實已經破梗完了，我們在 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;介面篇&lt;/a&gt; 已經說明過依賴反轉最基本的思維路線。我們並不是用低階模組的功能直接拼湊出高階模組，讓高階模組直接依賴低階模組然後受到影響；而是把關注點放在需要的功能上，用介面隔開實作，解開他們彼此之間的耦合，介面就是模組之間的抽象層。&lt;/p&gt;
&lt;p&gt;同時也要明白一件重要的事：&lt;strong&gt;並不是高階模組去依賴低階模組。而是高階模組提出它需要的功能，低階模組去實作出這些功能、達成高階模組的目標&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我們並不是因為有「DB 的連線方法」和「處理會員資料的方法」所以才說「我們有這兩個東西欸，那我們來組成會員查詢功能吧」；而是「我們想做一個會員查詢功能，所以我們需要連線到 DB，然後對這些資料做篩選和處理」&lt;/p&gt;
&lt;p&gt;就如同我們在介面的例子所提的一樣：「老闆為了製造產品（高階模組的目標），開出了工程師的應徵條件（介面），而小明前來應徵（低階模組的實作）」&lt;/p&gt;
&lt;p&gt;如此一來，依賴就「反轉」了。原本是 &lt;code&gt;高階模組 → 低階模組&lt;/code&gt; 的關係，變成了 &lt;code&gt;高階模組 → 介面 ← 低階模組&lt;/code&gt;。並不是高階去依賴低階，而是低階去依賴高階要求的功能。&lt;/p&gt;
&lt;p&gt;這也就是依賴反轉原則的第二點：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;抽象不應該依賴細節；細節應該依賴抽象。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;到這邊我們就推完 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;介面篇&lt;/a&gt; 的前提了，請大家再回顧一下介面篇的內容。也就是說，上面的例子改用抽象層隔離之後，就會和介面篇的例子相同，變成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Product Work()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    IProgrammer programmer = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Ming();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; product = programmer.Programming();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; product;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這邊就會遇到我們介面篇結束時所問的問題：我們使用功能之前，必須先建立該類別的實例，也就是 &lt;code&gt;new Ming()&lt;/code&gt;，那麼，我們不就還是直接依賴了實作嗎？&lt;/p&gt;
&lt;h2 id=&#34;控制反轉-inversion-of-control-ioc-br-依賴注入-dependency-injection&#34;&gt;控制反轉 (Inversion of Control, IoC) &amp;amp;&lt;br/&gt; 依賴注入 (Dependency Injection)&lt;/h2&gt;
&lt;p&gt;即使我們反轉了依賴關係，但總是要建立實例才能使用的呀。所以，只是將對具體的依賴更改為對抽象的依賴，仍然是不夠的，在要使用的瞬間就會遭遇到問題。面對這個問題，大大們提出了許多個解決的方法，今天就介紹一個比較常見的方向：&lt;strong&gt;控制反轉 (Inversion of Control, IoC)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;思路非常的簡單：既然如此，我們把實例的建立和實例的使用切分開來就好了，&lt;strong&gt;不再是由高階模組去建立並控制低階模組，而是我們讓一個控制反轉中心去建立低階模組，然後高階模組要使用的時候再把這個低階模組交給高階模組使用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如此一來，控制權也跟著反轉過來了，高階模組從&lt;strong&gt;主動&lt;/strong&gt;建立低階模組，變成&lt;strong&gt;被動&lt;/strong&gt;接收低階模組；也就是從原先的 &lt;code&gt;高階模組 —(建立)→ 低階模組&lt;/code&gt;，變成了 &lt;code&gt;高階模組 ←(傳遞低階模組)— 控制反轉中心&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;控制反轉的概念比較像是：當肚子餓的時候，如果自己煮菜的時候，必須自己備料、自己烹調、才能有東西吃。但如果去餐廳點餐，只要說出自己想要的餐點，店家就會負責備料，廚師就會烹調，最後就把需要的餐點送上桌來吃。&lt;/p&gt;
&lt;p&gt;也就是說，&lt;strong&gt;高階模組再也不需要關心如何建立，該建立哪個實體，只專注於使用功能，真正達到介面的精神。低階模組也只需要等待控制反轉中心分發，到了崗位就把份內事做好，專心在自己的職責身上即可&lt;/strong&gt;。如此一來就能解除兩者之間的耦合。&lt;/p&gt;
&lt;p&gt;但是，要怎麼把控制中心建立的低階模組，交給高階模組做使用呢？這時候的實作方式就是我們所謂的 &lt;strong&gt;依賴注入 (Dependency Injection)&lt;/strong&gt; 了。&lt;/p&gt;
&lt;p&gt;依賴注入說穿了很簡單，就是&lt;strong&gt;用各種姿勢把東西丟進去給類別使用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如說我們先前提過的 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;建構式&lt;/a&gt;，就是其中一種解決方法。用上面的例子，就會變成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ProductService&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; IProgrammer _programmer;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; ProductService(IProgrammer programmer)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;._programmer = programmer;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Product Work()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; product = &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;._programmer.Programming();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; product;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在這個例子中，我們利用建構式的方式，從外部傳入該介面的實體來使用。現在撰寫產品程式碼的工作再也不用為了換工程師而改變，也不用因為實作細節或是方法名稱而煩惱，只要照個介面合約使用就可以了。至於要傳遞哪個實體進來，這份工作要交給小明還是小美，就讓控制中心去決定，大家各司其職，落實單一職責。&lt;/p&gt;
&lt;p&gt;當然，注入的方式不只建構式注入，還有設值注入（也就是從外部改變目標的某個屬性值來達到注入）等等；提供 IOC 的方式也不只一種，例如 .net 的 Unity，甚至到了 .net Core 時代 IOC 還直接是內建的功能呢，由於口味眾多，此處暫且按下不表。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;補充：下個系列文補了 &lt;a href=&#34;https://igouist.github.io/post/2021/11/newbie-6-dependency-injection&#34;&gt;使用 依賴注入 (Dependency Injection) 來解除強耦合吧&lt;/a&gt;，有興趣的朋友可以接續看看&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;結語&#34;&gt;結語&lt;/h2&gt;
&lt;p&gt;那麼，我們最後再來複習一遍：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高階模組不應該依賴於低階模組，兩者都應該依賴抽象&lt;/strong&gt;。為了解除耦合，必須用介面這種抽象層進行隔離。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象不應該依賴細節。細節應該依賴抽象&lt;/strong&gt;。介面應該是高階模組提出的要求，然後才去使用實作了這些要求的低階模組。這些實作應該圍繞著這些要求，而不是讓要求去配合實作，更不要讓要求中包含實作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;為了解決介面實例化仍然會產生依賴的問題，就有了控制反轉&lt;/strong&gt;。把控制權交給第三方，藉此讓使用者能夠不用關心實例化的過程，而注重在使用並達成目標的職責上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而控制反轉的具體實現方法是依賴注入&lt;/strong&gt;，藉由從建構式傳遞、更改目標的屬性等方式，把低階模組交給高階模組使用者。當我們藉由依賴注入的方式實現控制反轉，就能夠讓物件的設計符合依賴反轉原則。&lt;/p&gt;
&lt;p&gt;這個部份的做法還是挺複雜的，&lt;del&gt;所以才拖稿這麼久&lt;/del&gt;，因此決定把原因的順序推過一遍，也算是幫自己重新了解一次。參考資料有蠻多篇我都相當喜歡，想更了解依賴反轉、控制反轉等等的朋友可以再自行閱讀。那麼，我們下次見～&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列下一篇：&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://notfalse.net/1/dip&#34;&gt;依賴倒置原則 (Dependency-Inversion Principle, DIP) - NotFalse 技術客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://notfalse.net/3/ioc-di&#34;&gt;控制反轉 (IoC) 與 依賴注入 (DI) - NotFalse 技術客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@f40507777/%E4%BE%9D%E8%B3%B4%E5%8F%8D%E8%BD%89%E5%8E%9F%E5%89%87-dependency-inversion-principle-dip-bc0ba2e3a388&#34;&gt;依賴反轉原則 Dependency Inversion Principle (DIP) - Finn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10191603&#34;&gt;從被動變主動—依賴反轉 - 伊恩 - iT邦幫忙&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dustinhsiao21.github.io/dp/solid-dependency-inversion-principle/&#34;&gt;SOLID 原則 - Dependency Inversion Principle(依賴反轉原則) - Dustin;s murmur&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-6_dependency-inversion-principledip-%E4%BE%9D%E8%B3%B4%E5%8F%8D%E8%BD%89%E5%8E%9F%E5%89%87/&#34;&gt;Object Oriented物件導向設計原則SOLID-6:Dependency Inversion Principle(DIP)依賴反轉原則 - Sian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sunnyday0932.github.io/2020/%E4%BE%9D%E8%B3%B4%E6%B3%A8%E5%85%A5-didependency-injection/&#34;&gt;依賴注入 DI(Dependency Injection) - Sian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/supershowwei/2018/07/30/144329&#34;&gt;[小菜一碟] 談談物件導向設計原則中 DIP（依賴反轉原則）中的 Dependency（依賴） - 軟體主廚的程式料理廚房&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jyt0532.com/2020/03/24/dip/&#34;&gt;深入淺出依賴反向原則 Dependency Inversion Principle - jyt0532&amp;rsquo;s Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/daniel/2018/01/17/140435&#34;&gt;IOC(控制反轉)，DI(依賴注入) 深入淺出~~ - 石頭的coding之路&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同系列文章&#34;&gt;同系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>7&#43; Taskbar Tweaker —— 簡單方便的 Windows 工作列調整工具</title>
      <link>https://igouist.github.io/post/2020/12/7_taskbar/</link>
      <pubDate>Sun, 06 Dec 2020 23:49:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/12/7_taskbar/</guid>
      <description>&lt;p&gt;故事是這樣的——&lt;/p&gt;
&lt;p&gt;Win10 工作列的合併設定有這些選項：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/yZypwQD.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;當選擇「一律、隱藏標籤」時，工作列上同樣的程式就會摺疊起來：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/8JvOmkJ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;而「永不」和「當工作列滿時」則會將工作列展開：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/BqA2ERo.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;好的，那麼像我個性這麼麻煩的人，如果覺得顯示名字很佔位置，可是又不想要摺疊之後按兩次才能打開我要的應用程式，偏偏又很愛開一整排 IDE 的話，有沒有什麼簡單的辦法&lt;strong&gt;不要讓圖示合併，但也不要顯示名字呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果有個小工具，可以讓這些工作列的設定更彈性就好了，會有嗎？&lt;/p&gt;
&lt;p&gt;有的！&lt;/p&gt;
&lt;p&gt;今天要記錄的是 &lt;strong&gt;7+ Taskbar Tweaker&lt;/strong&gt; 這個小東東，他的畫面是長這樣的&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/bSDYzFO.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以調整的部分挺多的，可以隨個人喜好進行調整，從滑鼠操作工作列一路到時間要不要顯示秒都有。&lt;/p&gt;
&lt;p&gt;例如我前面想要的需求，就可以把分組的部分改成「&lt;strong&gt;不分組&lt;/strong&gt;」&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/UePSYB9.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;這樣工作列的圖示就變成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/XJHECgm.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;就是這樣！&lt;/p&gt;
&lt;p&gt;另外如果對這些選項仍然不滿足的朋友，也可以右鍵開啟&lt;strong&gt;進階選項&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/TrJ7IhJ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;像我就有開啟大 icon，看了就是比較舒服&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/oTshGL4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;另外也能自訂一些滑鼠操作、鍵盤快速鍵等等，能微調的地方蠻多的，很適合有興趣的朋友可以自己研究看看。另外也要感謝巴哈的這篇 &lt;a href=&#34;https://forum.gamer.com.tw/C.php?bsn=60030&amp;amp;snA=525114&#34;&gt;徹底爆改&lt;/a&gt; 多挖了很多小玩具可以玩，哈。&lt;/p&gt;
&lt;p&gt;那麼今天就介紹到這裡，絕對不是玩小工具和逛耶誕城結果就廢掉沒寫文囧，抱歉啦催稿的碰油，我們下次見～&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>讀《離開公司，我過得還不錯》</title>
      <link>https://igouist.github.io/post/2020/11/i-am-doing-well-after-leaving-the-company/</link>
      <pubDate>Sun, 29 Nov 2020 23:54:06 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/11/i-am-doing-well-after-leaving-the-company/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/8QX3RPd.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;無論喜不喜歡自己的工作，都應該好好思考自己和工作的關係，畢竟每天花三分之一的時間做這件事，如果和它處得不好，人生也不可能會變好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這本書並不是那種精神勝利法，又或是超猛接案全攻略之類的書；反而給我的感覺比較像是作者藉著這本書，分享他這一路摸索的心得，和遭遇到的一些困難，看的時候有種像在和作者聊聊天的感覺。&lt;/p&gt;
&lt;p&gt;也因為這本書比較接近作者分享他選擇的道路、內容比較廣雜，遇到的部分都稍微說一些，但不是那種針對某個議題深入探討的書籍，所以比較適合想稍微了解自由工作的朋友閱讀。同時也必須了解到，自由工作者也只是眾多職業道路的其中一種，每個人的條件也不盡相同，因此抱持著好奇的心情閱讀，會更有收穫的感覺。&lt;/p&gt;
&lt;p&gt;從 &lt;a href=&#34;https://www.books.com.tw/products/0010810277&#34;&gt;博客來&lt;/a&gt; 的書籍簡介就可以看到，目錄真的把自由工作遇到的議題都碰了一些：從適不適合接案工作，到報稅、勞保、合約、工作場所都聊了一點。因為真的挺廣的，這邊我就只記錄一些我比較感興趣的話題。&lt;/p&gt;
&lt;h2 id=&#34;我們和工作之間的關係&#34;&gt;我們和工作之間的關係&lt;/h2&gt;
&lt;p&gt;本書最開始的時候作者敘述了他踏入自由工作的歷程：太過熱情工作、燃燒殆盡、失去熱情、休養了一年，最後重新思考人與工作之間的關係，才決定踏上接案的道路。&lt;/p&gt;
&lt;p&gt;就像我這篇文章決定引用作者前輩說過的話作為開場，我也相當認同：&lt;strong&gt;不管你做什麼，工作在大多數人的生命中都佔了不少的份量&lt;/strong&gt;。但我們真的有好好思考過我們和工作之間的關係嗎？有思考我們為什麼工作、想要什麼工作、適合什麼工作嗎？只要曾經思考過這些問題，就會明白我們和工作之間的關係，其實就是我們和生活之間的關係。而我們想要的工作，就是我們想要的生活。&lt;/p&gt;
&lt;p&gt;當作者的前言問說：「總是人去符合職位的要求，把我們原本奇怪的形狀塞進方方正正的外框，身處職場當然不可能完全舒服，但，有沒有可能換個角度，從自己原本奇怪的形狀延伸，慢慢長出各種不同的工作」這倒讓我好像看到了 &lt;a href=&#34;https://igouist.github.io/post/2020/06/darkhorse&#34;&gt;黑馬思維&lt;/a&gt; 的影子，黑馬思維也是要求我們要先了解自己的微動力，再根據自身去選擇策略。&lt;/p&gt;
&lt;p&gt;因此，當作者接著說明上班的心態和接案的心態：上班打混過了一天也是一天的薪水，但接案為了生存就會講究效率；但上班相對比較穩定，有安心感，接案則是有做有錢沒做沒錢，兩者之間對於效率和時間的意義相當不同。從這開始，其實也就區分了適合接案和適合上班的人們了。&lt;/p&gt;
&lt;p&gt;書中也有了一小段來接續這個話題，說明作者認為誰適合上班，誰又適合自由工作。上班相對於自由工作，有三個明顯的優勢：明確的社會位置、穩定的收入來源、勞基法保障的福利。因此，不確定想做什麼的朋友，或是喜歡穩定、安全的朋友就比較適合上班。&lt;/p&gt;
&lt;p&gt;反過來說，自由工作者必須了解自己在社會中的位置，用專業來取代職稱，在開始接案的時候，也得要先找一件有趣的事情開始做，其他任務才會找上門來。也因此最好有點存款，才能保留接案時的選擇權等等。所以比較適合能承受不穩定性，又或是有想持續追求的目標的人。&lt;/p&gt;
&lt;p&gt;要注意，這邊的承受不穩定性包含的心理和經濟能力等方面。例如作者的家人能夠經濟獨立，並且作者對工作的要求是能夠賺取生活所需的金錢讓他能夠自由做想做的事情即可，因此在衡量接案和上班之間的差異時，千萬別忘了要從自身的條件、想要的生活等方面開始估算。試著去想想兩者之間的條件，和自己比較傾向哪邊的生活。&lt;/p&gt;
&lt;p&gt;即使最後發現此路不可行，但就像書中說的：「&lt;strong&gt;光是從不同角度去思考工作和自己的關係，換個視野看看職場十字路口的風景，也都會有收穫。&lt;/strong&gt;」&lt;/p&gt;
&lt;h2 id=&#34;自由與不自由&#34;&gt;自由與不自由&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;自由意味著責任，正因為如此，多數人都懼怕自由。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;都說自由接案比較自由，但聽來聽去也不知道到底有多自由，曾經聽到唉呀那個接案的又出國玩啦，也曾聽到欸那個誰案子趕不完了好像三天沒睡了，總感覺這族群對我來說有點…太過動盪？所以「接案有多自由？」一直是我蠻有興趣的問題。&lt;/p&gt;
&lt;p&gt;作者在書中也列出了幾項接案工作者的自由和不自由，例如能夠隨心所欲安排時間、能夠自己選擇案子、可能自己調整工作內容等等。同時也會有偷懶就沒有收入，必須維持工作成果等壓力。&lt;/p&gt;
&lt;p&gt;但就像本節引用的這句「&lt;strong&gt;自由意味著責任&lt;/strong&gt;」，為了能夠隨心所欲安排時間，必須先學會時間規劃，必須要能夠遵守紀律；為了能夠自己選擇案子，必須要維持住經濟水準，也必須要磨練專案到擁有話語權；為了能夠自己調整工作內容，就必須好好思考過工作和生活的比例，必須自己找到目標。所有的自由相對都需要先有所付出，因此自由並不是比較簡單的道路，而是學會對自己負責，還有可能餓死。&lt;/p&gt;
&lt;p&gt;也因為這些責任，所以自由工作者必須具備一些能力，大多數作者都會在書中提到，例如：&lt;/p&gt;
&lt;p&gt;在財務管理方面，就不能像領薪水的上班族一樣，每個月五號十號無腦等錢入帳，必須主動按照專案去管理每一筆帳。&lt;/p&gt;
&lt;p&gt;而且&lt;strong&gt;通常是同時多個專案非同步地進行著&lt;/strong&gt;，例如Ａ專案做到一半Ｂ專案開始，同時手上還有Ｃ專案準備啟動會議等等，這些專案簽訂的合約、入賬的時機也都有可能不同。&lt;/p&gt;
&lt;p&gt;所以就必須學會掌握各個專案的進度和帳務狀況等等，所以自由接案者只能被迫好好學記帳，才能掌握住工作和款項的節奏，避免周轉不靈或是破產。&lt;/p&gt;
&lt;p&gt;同時，既然都有可能多個專案非同步地進行了，為了能夠自由地工作和生活，也就必須好好把工作狀況記錄下來，回顧和規畫整體的時間。&lt;/p&gt;
&lt;p&gt;就像公司前輩曾經說過的：&lt;strong&gt;能夠估算工時，也是工程師專業中的一環&lt;/strong&gt;。那麼保持對時間的敏感度，把主導權拉回自己身上，自然也是自由工作者的一項專業與責任吧。&lt;/p&gt;
&lt;p&gt;針對時間管理，作者認為應該從記錄開始，並提出了四個步驟：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每天記錄做了什麼&lt;/li&gt;
&lt;li&gt;每周歸納整體工作&lt;/li&gt;
&lt;li&gt;每月回顧時間使用狀況&lt;/li&gt;
&lt;li&gt;每年檢討新目標&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;說實在的，我看到這段不自主驚呼，這不是子彈筆記的精神嗎？因此這邊就不再贅言，直接丟幾篇對我影響比較大的時間管理文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.playpcesor.com/2015/07/calendar-project.html&#34;&gt;實作進攻型行事曆：學會留時間給自己的進度排程心法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/how-gipi-learn/iterate-your-week-schedule-81e1aa8843b2&#34;&gt;把週行事曆當專案管，實現每週自我迭代&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://readingoutpost.com/the-bullet-journal-method/&#34;&gt;看膩了繽紛的子彈筆記？手殘派科技人的6個月實踐心得&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然前面都計算了賺錢的效率，在選擇案子的時候，自然就會開始有所取捨。就如同書中所說的：什麼案子都接的話，跟在公司上班有什麼兩樣？&lt;/p&gt;
&lt;p&gt;因此，就會劃分出賺錢與不賺錢的案子、有興趣和沒興趣的案子，甚至感覺不太對勁的案子等等。&lt;/p&gt;
&lt;p&gt;在書中，作者的工作收入要求只要能維持生活即可，因此他會主動搭配賺錢的案子和比較有興趣的案子，讓自己邊維持生活又能有時間做有興趣的工作。&lt;/p&gt;
&lt;p&gt;關於案件的選擇和搭配這部份，畢竟比較吃個人經驗，我就沒什麼特別的心得。但書中有個建議仍然值得參考：&lt;strong&gt;請相信直覺&lt;/strong&gt;，當直覺有問題，那通常就真的有問題。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/2kTqFln.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;當你感覺到危，猶豫就會敗北。&lt;/p&gt;
&lt;p&gt;除了上面這三項以外，還有許多篇幅用來說明 工作場所、報價與合約等等，過於實際操作的部份，這邊就略過不提了。&lt;/p&gt;
&lt;h2 id=&#34;重新定義&#34;&gt;重新定義&lt;/h2&gt;
&lt;p&gt;書中最後的篇幅，作者用自己的看法重新定義了生活、職涯、退休、成功等等話題。&lt;/p&gt;
&lt;p&gt;其中有幾個部分我挺有興趣的，例如作者說：「在討論斜槓、自由工作時，有幾個前提條件得說清楚：只是兼差很多，卻沒有自己的熱情與專長，不能算斜槓；如果接一堆案子，卻沒有挑案子的自由、沒有安排時間的原則、說不出對工作和生活的想法，也稱不上是自由工作者。」&lt;/p&gt;
&lt;p&gt;無情的接案機器，似乎也跟爆肝上班族沒什麼兩樣，都一樣沒有自由。接著作者又問：能否不依賴公司，以個人名義在職場生存？&lt;/p&gt;
&lt;p&gt;從這些出發點思考，到「&lt;strong&gt;拿回人生的選擇權&lt;/strong&gt;」就是作者對自由工作者的「自由」下的定義。&lt;/p&gt;
&lt;p&gt;想要自由，也得先從思考生活和培養熱情、磨練專長開始。&lt;/p&gt;
&lt;p&gt;不過這就像是書中提到的：「自由工作者憑什麼生存？小說家尼爾蓋曼（Neil Richard Gaiman）說，&lt;strong&gt;才華洋溢、交件準時、人好相處，是三項重要能力&lt;/strong&gt;」並且，只要能符合其中兩項就足以好好生存了。&lt;/p&gt;
&lt;p&gt;但這些能力，和上面能夠自由的條件，不管放到自由工作者或是職場，我個人覺得都是適用的，因為這些就是個人的軟實力。所以，不論你選擇上班工作，或是自由接案，終究還是要走向自我成長。&lt;/p&gt;
&lt;p&gt;而成長的方向和道路何其多，又怎麼不讓人好好思考、好好摸索呢？&lt;/p&gt;
&lt;p&gt;最後謝謝這本書，算是讓我思考了一個新的方向。書中其實還介紹了蠻多作者的心得和自由工作的一堆眉眉角角，也推薦有興趣的朋友可以讀看看，當作了解自由工作的入門磚，多多少少也會有收穫的吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這本書，描述的就是我的嘗試方法、犯錯教訓，還有交換的代價。不過我摸索出來的道路，也只是解開工作謎團的其中一條路線而已，每個人都可以有自己的路線，而且比我的更寬廣自在才對。&lt;/p&gt;
&lt;p&gt;《離開公司，我過得還不錯：成為自由工作者的理想生活提案》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;延伸閱讀&#34;&gt;延伸閱讀&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.thenewslens.com/article/112375&#34;&gt;《離開公司，我過得還不錯》：能否不依賴公司，以個人名義在職場生存？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://imjanet.com/freelancer/&#34;&gt;閱讀心得｜離開公司，我過得還不錯 成為自由工作者的理想生活提案 劉揚銘 - JJ&amp;rsquo;S TRAVEL &amp;amp; LIFESTYLE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/unique-reader/%E9%9B%A2%E9%96%8B%E5%85%AC%E5%8F%B8-%E6%88%91%E9%81%8E%E5%BE%97%E9%82%84%E4%B8%8D%E9%8C%AF-b92a2bae0ac9&#34;&gt;離開公司，我過得還不錯！ - 優‧悅讀&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.books.com.tw/products/0010825335&#34;&gt;一人公司：為什麼小而美是未來企業發展的趨勢&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>菜雞抓蟲: 在 Amazon Linux AMI 安裝 .net Core 時卡在 Requires: openssl-libs</title>
      <link>https://igouist.github.io/post/2020/11/bugs-install-dotnet-core-on-amazon-ami-requires-openssl/</link>
      <pubDate>Sun, 22 Nov 2020 23:40:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/11/bugs-install-dotnet-core-on-amazon-ami-requires-openssl/</guid>
      <description>&lt;p&gt;最近遇到在 Amazon Linux AMI 要安裝 .net Core 3.1 環境的時候，會一直跳出&lt;br/&gt; &lt;code&gt;Requires: openssl-libs&lt;/code&gt; 而無法安裝的問題，儘管明明已經有 openssl 了，但還是解析失敗找不到依賴，過程一直碰壁，因此在這邊紀錄一下。&lt;/p&gt;
&lt;p&gt;過程中嘗試了安裝 openssl-libs（會找不到該套件）、下載 Dotnet 的 tar.gz ，再直接對執行檔下 Dotnet 指令起站台（雖然網站起得來，但執行者會是當下的登入身分，也就是 &amp;lsquo;&amp;rsquo;@連線進來的IP-伺服器位置，而非由本機執行。後續如果有連線資料庫等檢查權限的地方就很容易出錯）&lt;/p&gt;
&lt;p&gt;最後在 Dotnet Core 的 issue 翻到這篇 &lt;a href=&#34;https://github.com/dotnet/core/issues/930&#34;&gt;Cannot install .NET Core 2.0 on Amazon Linux AMI&lt;/a&gt; 才成功解決。&lt;/p&gt;
&lt;p&gt;首先先將 openssl-libs 的 SPEC 抓下來，然後給 RPM 建置一下。這兩句可以參考一下這篇 &lt;a href=&#34;https://medium.com/linux-%E9%96%8B%E7%99%BC%E5%85%A5%E9%96%80/rpm-%E6%89%93%E5%8C%85-%E7%94%B1%E4%B8%80%E7%AB%85%E4%B8%8D%E9%80%9A%E5%88%B0%E5%8B%95%E6%89%8B%E6%BF%AB%E7%94%A8-%E4%BA%8C-df9eea70bd7b&#34;&gt;RPM 打包︰由一竅不通到動手濫用 (二)&lt;/a&gt; 的說明。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;wget https://github.com/dotnet/core/files/2186067/openssl-libs-ami.spec.txt
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rpmbuild --bb openssl-libs-ami.spec.txt
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接著我們去把打包好的 openssl-libs 安裝起來，路徑可能會有不同，所以記得先用 find 找一下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo find / -iname RPMS
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo rpm -i /usr/src/rpm/RPMS/x86_64/openssl-libs-1.0.0-0.x86_64.rpm
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;到這邊應該就解決標題遇到的問題囉！讓我們回到安裝的正軌&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo yum install -y powershell
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo yum install dotnet-sdk-3.1.0
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最後就可以 &lt;code&gt;dotnet&lt;/code&gt; 試試囉！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (13): 介面隔離原則</title>
      <link>https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle/</link>
      <pubDate>Sun, 15 Nov 2020 12:00:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/itHN6VZ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;今天要記錄的是介面隔離原則，顧名思義是和介面高度相關的原則。因此在閱讀本篇之前，可能需要先對 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;介面&lt;/a&gt; 有一點了解呦。&lt;/p&gt;
&lt;p&gt;事情就從上一篇 &lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;里氏替換原則&lt;/a&gt; 的鳥類物流公司開始說起。老闆痛定思痛，決定先用&lt;strong&gt;介面&lt;/strong&gt;先規定好物流士們的應徵條件，例如裝貨、卸貨、飛行、必須有帥氣的喙等等。&lt;/p&gt;
&lt;p&gt;這道命令下來後，倉庫們的企鵝都慌了，來檢查的編譯器瘋狂跳出 Error:「您未實作 IBird 的 Fly() 方法！」這下怎麼辦呢，為了要保住飯碗，企鵝們就必須實作出飛行才行，可是企鵝真的就不會飛呀！&lt;/p&gt;
&lt;p&gt;這下子企鵝們只剩下兩個選擇：不實作飛行，但是就不能被當成物流士，最後就會被開除；或是……空實作。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Penguin&lt;/span&gt; : IBird
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Fly()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// Do nothing;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;企鵝們終於騙過了編譯器檢查員，然而當送貨的命令下來之後，企鵝們再一次卡在倉庫門口發呆，最終物流公司仍然踏上了虧損的老路，再度面臨倒閉危機…&lt;/p&gt;
&lt;h2 id=&#34;介面隔離原則interface-segregation-principle&#34;&gt;介面隔離原則（Interface Segregation Principle）&lt;/h2&gt;
&lt;p&gt;不知道大家對企鵝遇到的狀況有沒有經驗呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;當介面規定了太多要求，而我們實作的子類別只需要其中一部份，或是有些要求根本無法達成，就會發生這個困境：放棄實作介面，或是用空實作和錯誤處理去欺騙介面&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如資料庫存取的介面要求太多和當下資料庫過於一致的方法，結果替換資料庫的時候導致部份方法實作不出來；或是像 &lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-4_interface-segregation-principleisp-%E4%BB%8B%E9%9D%A2%E9%9A%94%E9%9B%A2%E5%8E%9F%E5%89%87/&#34;&gt;俺同事文章&lt;/a&gt; 中的例子，交通工具的介面要求能開關車門，結果電動機車無法實作。&lt;/p&gt;
&lt;p&gt;然而，如果我們選擇用空實作或是拋出錯誤的方式，去欺騙介面，等到需要呼叫該方法的時候，就會發生許多非預期的錯誤。甚至讓接手程式碼的人在什麼都不知道的情況之下就讓系統掛掉。聰明的朋友們一定發現了，這就是違反了 &lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;里氏替換原則&lt;/a&gt;！&lt;/p&gt;
&lt;p&gt;為了迴避到處都是空實作地雷的結局，大前輩們就提出了介面隔離原則：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;不應該強迫用戶依賴它們未使用的方法&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這邊的用戶也就是我們的子類別，它們等同是這個介面的使用者。當我們必須強迫使用者去實作一些他們不需要的方法時，就代表了一個事實：我們的介面太「胖」了！裡面的某些要求可能是非必要的，以至於造成了實作上的冗餘。&lt;/p&gt;
&lt;p&gt;也基於這條原則延伸出了一個方向：&lt;strong&gt;應該最小化類別與類別之間的介面&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;介面也要單一職責&#34;&gt;介面也要單一職責&lt;/h2&gt;
&lt;p&gt;但是，我們要怎麼知道是我們設計的介面太胖，還是子類別在偷懶呢？又要怎麼知道我們的介面設計是否已經「最小化」呢？&lt;/p&gt;
&lt;p&gt;那就是 &lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;單一職責原則&lt;/a&gt; 出場的時候了。一個合理的介面設計是能夠符合單一職責原則的，反過來說，我們可以用單一職責原則來檢視我們的介面設計是否良好。&lt;/p&gt;
&lt;p&gt;當我們設計介面的時候，或是像上面遇到必須空實作的時候，就可以思考一下：&lt;strong&gt;這個介面的職責是否單一？這個介面的意圖是什麼？這個介面是否只對一個角色負責、只有一個原因改變？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;當我們的介面符合單一職責、足夠 &lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;內聚&lt;/a&gt; 的時候，我們自然就能夠說這個介面已經足夠精簡了。&lt;/p&gt;
&lt;h2 id=&#34;用組合實現功能&#34;&gt;用組合實現功能&lt;/h2&gt;
&lt;p&gt;有些人可能就會有點疑惑了：「但是我就是需要這個功能呀，如果我不塞在介面，要放去哪呢？」&lt;/p&gt;
&lt;p&gt;很簡單，&lt;strong&gt;放去另一個該職責的介面就可以了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;和繼承需要注意的部分一樣，濫用介面也是濫用繼承，我們應該用&lt;strong&gt;組合&lt;/strong&gt;去實現功能而不是用繼承去綁死功能。一個資料串列能做的功能可能相當多，但我們並不需要一次就要求實現全部能做的事情，而是將這些工作分組，再從中組合出我們需要的部份。&lt;/p&gt;
&lt;p&gt;此處以 C# 來說，例如我們很常接觸的 &lt;code&gt;List&lt;/code&gt; 類別，並不是只實作了 &lt;code&gt;IList&lt;/code&gt;，而是實作了 &lt;code&gt;ICollection&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;IEnumerable&lt;/code&gt;, &lt;code&gt;IList&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;IReadOnlyCollection&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;IReadOnlyList&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;ICollection&lt;/code&gt;, &lt;code&gt;IList&lt;/code&gt; 這些介面，層層堆疊，相互嵌合。&lt;/p&gt;
&lt;p&gt;那我們就知道 List 由這些介面「組合」而成，也知道了我們 List 具有這些介面要求的能力，讓我們能在合適的時候使用這個類別。同時又保留了這些介面能搭配出另一種組合的彈性，例如 &lt;code&gt;Array&lt;/code&gt; 就是由 &lt;code&gt;ICollection&lt;/code&gt;, &lt;code&gt;IEnumerable&lt;/code&gt;, &lt;code&gt;IList&lt;/code&gt;, &lt;code&gt;IStructuralComparable&lt;/code&gt;, &lt;code&gt;IStructuralEquatable&lt;/code&gt;, &lt;code&gt;ICloneable&lt;/code&gt; 組合而成。&lt;/p&gt;
&lt;p&gt;就像可能有位大神，名片一拿出來就是一串「程式設計師／架構師／攝影師／貓奴」，&lt;strong&gt;我們的類別也要懂得斜槓&lt;/strong&gt;。如此一來類別就比較不容易被介面綁死，也能因應不同場合來決定身分，從「每次都被逼著買套餐可是又不喜歡小菜」變成「餐餐自由配」，組合就該如此自由！&lt;/p&gt;
&lt;p&gt;回到開頭的例子，把想要的行為全部定義在一個介面裡，然後用一個類別去實現它遇到不需要的動作就詐騙介面，是相當不 OK 的；而是應該&lt;strong&gt;把想要的行為用職責的角度去思考&lt;/strong&gt;，根據職責建立成一或多個介面。然後只&lt;strong&gt;挑選&lt;/strong&gt;並實作該類別需要的動作（介面），如此就可以讓介面不再臃腫，而是變得靈活。&lt;/p&gt;
&lt;p&gt;就像是武術秘笈中的招式，其實也是一連串的動作所組成；所謂的功能，其實也是一連串行為所組成的。既然行為組合成了功能，我們也要從組合的角度去思考如何建立類別。&lt;strong&gt;組合就像是積木一樣&lt;/strong&gt;，我們用積木堆疊來完成作品，同時每個積木又可以各自靈活運用。&lt;/p&gt;
&lt;p&gt;而積木也分成了好用的積木，和很難使用的積木，在程式中可以從夠不夠 SOILD 看出來。不好用的那些用起來會覺得卡卡的，測試也很難寫；好用的則會讓你面對變化的時候，就像拆裝樂高一樣順手方便。聰明的朋友可能聯想到了，這就是 &lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;開放封閉原則&lt;/a&gt; 中我們提過的模組化。&lt;/p&gt;
&lt;p&gt;通常來說積木的形狀越複雜、體積越大，就越難以靈活使用，介面也是如此，因此我們在設計介面的時候，要謹記&lt;strong&gt;介面隔離原則&lt;/strong&gt;，利用我們在單一職責原則、里氏替換原則學到的原則來檢驗我們的介面，如此就可以迴避相當多尷尬兩難的實作場面，也能讓介面的使用更加靈活。&lt;/p&gt;
&lt;p&gt;那麼，在結束之前，有興趣的朋友可以跟我一起想一想：介面隔離原則，只適用於設計類別架構時的介面嗎？其他的介面（Interface）呢？例如 &lt;a href=&#34;https://igouist.github.io/post/2021/05/newbie-2-webapi&#34;&gt;API&lt;/a&gt;，是不是也可以按照介面隔離原則的精神下去設計呢？&lt;/p&gt;
&lt;h2 id=&#34;後日談&#34;&gt;後日談&lt;/h2&gt;
&lt;p&gt;企鵝詐騙介面的事情終究還是暴露了。&lt;/p&gt;
&lt;p&gt;但是這群企鵝的夢想就是成為物流士，老闆也狠不下心把牠們趕走。&lt;/p&gt;
&lt;p&gt;「也許……」&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%B0%8F%E9%BB%84%E9%B8%AD%E8%B0%83%E8%AF%95%E6%B3%95&#34;&gt;鴨子顧問&lt;/a&gt;說：「我們可以有別的方法。只要使用&lt;strong&gt;介面隔離原則&lt;/strong&gt;。」&lt;/p&gt;
&lt;p&gt;老闆：『介面隔離？怎麼做呢？』&lt;/p&gt;
&lt;p&gt;「我們可以把送貨放到 IDelivery，然後讓他們用不同的介面來實作移動方式，例如 IFly、ISwim、IRun 等等。用&lt;strong&gt;組合&lt;/strong&gt;的方式來完成不同種類的物流士類別，這樣就可以有很多種送貨方式了」&lt;/p&gt;
&lt;p&gt;『原來如此，不只是空運 —— 我們要征服陸海空嗎！』&lt;/p&gt;
&lt;p&gt;改變作法的鳥禽物流公司搖身一變成了動物物流公司，同時廣徵天下動物，除了企鵝也能從南極發貨中心快速運貨以外，公司還招到了明星成員獵豹物流士，從此蒸蒸日上、強勢打入各大物流市場，最後進軍宇宙。可喜可賀，可喜可賀。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列下一篇：&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@f40507777/%E4%BB%8B%E9%9D%A2%E9%9A%94%E9%9B%A2%E5%8E%9F%E5%89%87-interface-segregation-principle-isp-6854c5b3b42c&#34;&gt;介面隔離原則 Interface Segregation Principle (ISP) - Finn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10192464&#34;&gt;SOLID 之 介面隔離原則（Interface segregation principle）- Miles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/hatelove/2010/10/17/interface-segregation-principle&#34;&gt;91 之 ASP.NET 由淺入深 不負責講座 Day20 - ISP 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://daydaynews.cc/zh-tw/technology/346506.html&#34;&gt;設計模式之美十六：介面隔離原則有哪三種應用？介面該如何理解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yncbearz.github.io/2020/06/03/Interface-Segregation-Principle/&#34;&gt;介面隔離原則 - YNCBearz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-4_interface-segregation-principleisp-%E4%BB%8B%E9%9D%A2%E9%9A%94%E9%9B%A2%E5%8E%9F%E5%89%87/&#34;&gt;Object Oriented物件導向設計原則SOLID-4:Interface Segregation Principle(ISP) 介面隔離原則 - Sian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tenlong.com.tw/products/9789864342099&#34;&gt;《無瑕的程式碼：物件導向原則、設計模式與C#實踐》&lt;/a&gt; Ch.12 ISP：介面隔離原則&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同系列文章&#34;&gt;同系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Dark Reader —— 暗黑模式愛好者的 Chrome 必備套件</title>
      <link>https://igouist.github.io/post/2020/11/dark-reader/</link>
      <pubDate>Sun, 08 Nov 2020 23:39:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/11/dark-reader/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/G4OjUzE.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不能信任那些 Terminal 或編輯器用白底的人。&lt;/br&gt;
—— &lt;a href=&#34;https://github.com/CodeTengu/JokeKappa/blob/master/jokekappa/jokes/codetengu_weekly.json&#34;&gt;JokeKappa&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這禮拜推薦了個常用的 chrome 套件給同樣喜歡黑色背景的同事，這邊也推薦給大家。&lt;/p&gt;
&lt;p&gt;&lt;s&gt;絕對不是因為隻狼更新了不小心砍太爽，結果來不及寫介面隔離只能介紹套件水一下，Heiya～&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;今天要介紹的就是這款 &lt;a href=&#34;https://chrome.google.com/webstore/detail/dark-reader/eimadpbcbfnmbkopoojfekhnkhdbieeh&#34;&gt;Dark Reader&lt;/a&gt;，這是我用 chrome 時首選的暗黑模式擴充套件，在俺寫文的這時候已經超過了三百萬次的下載次數，現在就讓我來記錄一下這款擴充套件的一些特色唄。&lt;/p&gt;
&lt;p&gt;照慣例先上個預覽圖：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/OOEraiY.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;當我們安裝完成之後，就可以從 Chrome 右上角的擴充套件區看到 DarkReader 的 icon。點開就可以看到它的選單：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/rveo4TK.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;由上而下分別就是最常用的主要調整，左上角可以選擇是否套用，右上則是套件開啟關閉和快捷鍵。接著是一些對比度、亮度等等的調整，可以隨著個人喜好條找到舒適的程度。&lt;/p&gt;
&lt;p&gt;其中我覺得最中意的就是最下面的「&lt;strong&gt;僅適用於ＯＯＯ&lt;/strong&gt;」的功能，這代表我們可以將上面的設定&lt;strong&gt;僅僅針對某個特定網站作變更&lt;/strong&gt;，而不會遇到在Ａ網站辛辛苦苦調整後覺得順眼了，結果到了Ｂ網站同樣的配置卻相當刺眼的狀況。&lt;/p&gt;
&lt;p&gt;如此一來，對於某幾個常用的網站，我們完全可以自主微調再套用，甚至針對一些不太適合轉黑色的網站也能夠選擇關閉，這個彈性對我來說是相當實用的功能，幾乎是我最後愛用這款暗黑模式套件的主因。&lt;/p&gt;
&lt;p&gt;這些紀錄是否要開啟黑色模式的網站，就會記錄在第二個「網站列表」的頁籤。雖然可以手動增加，但我個人是不常用到，在首頁設定即可。&lt;/p&gt;
&lt;p&gt;而在第三個「更多」的頁籤，就有一些有趣的設定可以調整了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/2IMcXW4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;首先是文字描邊的部分。由於黑暗主題下的白色字會 &lt;a href=&#34;https://www.u-walker.com/news/2464.html&#34;&gt;讓人覺得字的筆劃較粗&lt;/a&gt;，因此大多時候字體就會經過調整。但如果覺得太超過了太細怎麼辦呢？這邊可以調整&lt;strong&gt;文字描邊&lt;/strong&gt;，讓字看起來不要看不見，也不要過眩過粗。&lt;/p&gt;
&lt;p&gt;再往下則是有四種模式可以設定，預設是動態模式，這邊直接上圖給各位感受一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;過濾
&lt;img src=&#34;https://i.imgur.com/6I58vhi.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;過濾+
&lt;img src=&#34;https://i.imgur.com/FvCr7iQ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;-靜態
&lt;img src=&#34;https://i.imgur.com/NISE8xa.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;-動態
&lt;img src=&#34;https://i.imgur.com/sQ6YreP.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中靜態會有一個編輯畫面，可以自己加入 CSS 達到完全客製。&lt;/p&gt;
&lt;p&gt;而動態則是就交給 Dark Reader 幫你算，像我這種懶人仔就是一路動態到底；像我這種會喜歡 &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme&#34;&gt;One Dark Pro&lt;/a&gt; 主題，這類非純黑、漸層質感配色的人，動態的結果也比較符合我的口味
。&lt;/p&gt;
&lt;p&gt;當然，動態產生的 CSS 也是能修改的，點選下面的開發者工具就可以看到完整的 CSS 囉。像本部落格也是基於 &lt;a href=&#34;https://github.com/flysnow-org/maupassant-hugo&#34;&gt;maupassant&lt;/a&gt; 這款好看的白色主題，再加上 Dark Reader 處理後產生的暗黑模式當底來逐步修改出來的。這方面真的要感謝製作主題和套件的大大們呢。&lt;/p&gt;
&lt;p&gt;今天的介紹就到這裡囉，推薦喜歡暗黑模式又想懶人用套件的朋友可以試試這款套件，真的相當好用！那麼，我們下次見～&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (12): 里氏替換原則</title>
      <link>https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle/</link>
      <pubDate>Sun, 01 Nov 2020 11:31:44 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ZAuxFRy.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;里氏替換原則-liskov-substitution-principle&#34;&gt;里氏替換原則 (Liskov Substitution Principle)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;子類別必須能夠替換父類別&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;里氏原則還包含了一個概念：子類別替換父類別後，&lt;strong&gt;不需要改變，也不會發生任何錯誤或異常&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;從定義就可以看出來，這項原則是來替我們處理繼承問題的。因此，在開始本篇之前，可能需要先對 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;繼承&lt;/a&gt; 以及 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;多型&lt;/a&gt; 有基本的認識。如果可以的話，也請先看過 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;介面&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;那麼，就讓我們從很久很久以前開始說起…&lt;/p&gt;
&lt;h2 id=&#34;我的子類別進入叛逆期了怎麼辦&#34;&gt;我的子類別進入叛逆期了，怎麼辦？&lt;/h2&gt;
&lt;p&gt;很久很久以前，有一間公司受到 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%BB%A5%E9%B8%9F%E7%B1%BB%E4%B8%BA%E8%BD%BD%E4%BD%93%E7%9A%84%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE&#34;&gt;鴿子封包&lt;/a&gt; 所啟發，打算發展鳥類運輸技術，強勢打入無人機市場，用生物智慧掀起對人工智慧的革命。既然&lt;strong&gt;鳥類都會飛行&lt;/strong&gt;，理所當然可以藉由飛行來進行空運，甚至還可以偷偷擊墜那些無人機對手，野心勃勃的老闆立馬徵了一批鳥類物流士，打出「凡是鳥類都可應徵」的旗號，各式各樣的猛禽響應而來，一時之間掀起整個物流業的風暴！&lt;/p&gt;
&lt;p&gt;但是好景不常，公司營運之後發貨狀況不佳，頻繁發生丟包問題，甚至有些貨根本就出不了倉庫，虧損越來越大，心急如焚的老闆下令徹查，這才發現—&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;企鵝是鳥，企鵝不會飛&lt;/strong&gt;。一堆企鵝在倉庫門口發呆。&lt;/p&gt;
&lt;p&gt;但是一切已經來不及，虧損已經造成，這家鳥禽物流公司最後也慢慢消失在塵埃之中……&lt;/p&gt;
&lt;p&gt;這個故事告訴我們：如果子類別（企鵝）沒有達到我們對父類別（鳥）的期待，就很容易在不知不覺中出事！&lt;/p&gt;
&lt;p&gt;我們已經預期了「鳥＝會飛行」這個前提，但繼承的企鵝卻無法實作飛行，如此就會讓我們被誤導、在使用時&lt;strong&gt;誤入陷阱&lt;/strong&gt;。這種子類繼承時搞叛逆，和父類別行為相違所發生的問題，難以預期也難以察覺，絕對是我輩不能容忍的。因此，里氏替換原則就出現了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;註：感謝這篇 &lt;a href=&#34;https://medium.com/@f40507777/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8F%9B%E5%8E%9F%E5%89%87-liskov-substitution-principle-adc1650ada53&#34;&gt;里氏替換原則 Liskov Substitution Principle (LSP) - Finn&lt;/a&gt; 的附圖，我之後就想不出比企鵝更貼切的例子了囧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;所以我們該如何遵守里氏替換原則&#34;&gt;所以，我們該如何遵守里氏替換原則？&lt;/h2&gt;
&lt;p&gt;我們再提一次：子類別必須要能替換掉父類別，而&lt;strong&gt;不需要改變&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我們在 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;多型篇&lt;/a&gt; 的時候提過「用子類別實作出各式各樣不同的方法，藉此讓父類別的方法藉此達到延伸和多樣化的效果」如此我們的物件彼此之間才能保持彈性，擁有可替換可擴充的特性，進而達到 &lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;開放封閉原則&lt;/a&gt; 所要求的：&lt;strong&gt;對修改封閉（不需要修改使用到父類別的地方），對擴展開放（而是只需要用子類別進行擴充，就能完成變動）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然而，這個擴展不該是天馬行空隨便亂擴的，必須要有原則。&lt;/p&gt;
&lt;p&gt;最首要的就是：至少&lt;strong&gt;父類別能做到的事情，子類別也要能做到&lt;/strong&gt;，不能說今天換成子類別就整組壞光光。畢竟，如果原本的東西變少了或壞掉了，那就不叫延伸了，對吧？&lt;/p&gt;
&lt;p&gt;也就是說，一個好的擴展方式，應該能滿足這些條件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要求不應該比父類別多&lt;/li&gt;
&lt;li&gt;回饋不應該比父類別少&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如說：爸爸每天都去市場賣香蕉，一支二十，數十年間颳風下雨從未改變。某一天爸爸生病，不想打破這個傳統，就請兒子去代班。這時：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;熟客們知道一支是二十元，他們順路來買香蕉的時候也只會準備二十元。&lt;br/&gt;
所以，兒子不能隨便亂漲價到五十元，因為客人也拿不出來，而且臨時漲價還會被留負評&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;熟客們知道給了錢就可以拿到香蕉，他們給了錢之後就會等著老闆把香蕉給他們。&lt;br/&gt;
所以，兒子不能今天收了人家二十元，然後只給半支香蕉，客人會很傻眼，攤子會很危險&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些熟客，其實就是我們工程師。&lt;strong&gt;我們預期了這個函式或類別需要準備的輸入參數，也預期了應該要有的輸出結果。如果某一天替換了子類別，卻不是這麼一回事，就會發生很多意料外的錯誤&lt;/strong&gt;。對買香蕉這件事而言：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;給足夠的錢就是所謂的「前置條件」或「先驗條件」&lt;/li&gt;
&lt;li&gt;預期拿到香蕉就是「後置條件」或「後驗條件」，&lt;/li&gt;
&lt;li&gt;每天都會去市場賣香蕉就是「不變條件」&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此當我們想要符合里氏替換原則時候，其實就可以試著遵守這幾條規則：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先驗條件不可以強化&lt;/strong&gt;：&lt;br/&gt;
父類別要求的是矩形，子類別就不能要求得更嚴，只准人家給正方形&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;後驗條件不可以弱化&lt;/strong&gt;：&lt;br/&gt;
父類別產出的是正方形，子類別不能說沒關係啦，就給人家隨便一個矩形&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不變條件必須保持不變&lt;/strong&gt;：&lt;br/&gt;
父類別是一個產生矩形的方法，子類別不能背骨，跑去產生圓形&lt;/p&gt;
&lt;p&gt;只要確保了&lt;strong&gt;輸入和輸出都是一致的&lt;/strong&gt;，就可以減少很多神奇妙妙問題。這個也就是所謂的&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%A5%91%E7%BA%A6%E5%BC%8F%E8%AE%BE%E8%AE%A1&#34;&gt;契約式設計 (Design By Contract)&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;稍微想一想你可以不要隨便繼承&#34;&gt;稍微想一想，你可以不要（隨便）繼承&lt;/h2&gt;
&lt;p&gt;有沒有發現，這個契約式的描述，和我們提過的 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;介面&lt;/a&gt; 概念是不是很像呢？可以稍微想一想：&lt;strong&gt;介面和繼承&lt;/strong&gt;間的關係，以及&lt;strong&gt;介面與里氏替換原則&lt;/strong&gt;的關係。&lt;/p&gt;
&lt;p&gt;首先，為什麼我們要使用繼承呢？如果只是為了減少重複程式碼，那實在是，呃，相當不建議。&lt;/p&gt;
&lt;p&gt;這邊需要了解一個觀念：&lt;strong&gt;我們不應該因為單純的「IS-A」就濫用繼承，那樣是危險的&lt;/strong&gt;。企鵝「是」鳥類、正方形「是」矩形，在想法上似乎是沒有問題的，但是貿然繼承就會遇到「企鵝不會飛」、「正方形四邊等長」等問題，讓實作上有種綁手綁腳的感覺。&lt;/p&gt;
&lt;p&gt;真正的繼承應該是基於行為的：&lt;strong&gt;這個子類別能不能做到父類別期望的行為&lt;/strong&gt;？這才是里氏替換原則的核心。&lt;/p&gt;
&lt;p&gt;不要用繼承去掠奪父類的程式碼，而是把目光放在行為，試著去思考父類別期望的行為是什麼、哪些是不可變的；期望的前置條件、後置條件，也就是輸入和輸出又代表什麼。&lt;/p&gt;
&lt;p&gt;當我們需要繼承時，就稍微想一想，把&lt;strong&gt;觀看物件的角度集中在它的功能上，去試著了解父類別所期望的繼承方式，和使用者期望的預期結果&lt;/strong&gt;。如此一來，我們自然就會朝向遵守契約式設計精神的&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;介面&lt;/a&gt;來取代繼承，又或是釐清功能之間的&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;職責&lt;/a&gt;，利用組合各個功能的子模組的方式來完成我們要的行為。&lt;/p&gt;
&lt;p&gt;放下繼承的包袱，了解繼承的原則，才能真正達到多型的精神，這就是里氏替換原則替我們指引出的方向。&lt;/p&gt;
&lt;p&gt;既然我們需要用到介面，那介面又有什麼要注意的地方呢？這就要到我們的介面隔離原則再聊了。欲知後續如何，且待下回分曉。&lt;/p&gt;
&lt;p&gt;那麼，我們下次見～&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文主要參考至這幾篇，建議想對里氏替換原則更了解的朋友可以閱讀一下呦：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://wadehuanglearning.blogspot.com/2019/12/blog-post_31.html&#34;&gt;物件導向設計原則：里氏替換原則，定義、解析 - WadeHuang的學習迷航記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/%E7%A8%8B%E5%BC%8F%E6%84%9B%E5%A5%BD%E8%80%85/%E4%BD%BF%E4%BA%BA%E7%98%8B%E7%8B%82%E7%9A%84-solid-%E5%8E%9F%E5%89%87-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8F%9B%E5%8E%9F%E5%89%87-liskov-substitution-principle-e66659344aed&#34;&gt;使人瘋狂的 SOLID 原則：里氏替換原則 (Liskov Substitution Principle) - 程式愛好者&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列下一篇：&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@f40507777/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8F%9B%E5%8E%9F%E5%89%87-liskov-substitution-principle-adc1650ada53&#34;&gt;里氏替換原則 Liskov Substitution Principle (LSP) - Finn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/%E7%A8%8B%E5%BC%8F%E6%84%9B%E5%A5%BD%E8%80%85/%E4%BD%BF%E4%BA%BA%E7%98%8B%E7%8B%82%E7%9A%84-solid-%E5%8E%9F%E5%89%87-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8F%9B%E5%8E%9F%E5%89%87-liskov-substitution-principle-e66659344aed&#34;&gt;使人瘋狂的 SOLID 原則：里氏替換原則 (Liskov Substitution Principle) - 程式愛好者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://teddy-chen-tw.blogspot.com/2012/01/4.html&#34;&gt;亂談軟體設計（4）：Liskov Substitution Principle - 搞笑談軟工&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wadehuanglearning.blogspot.com/2019/12/blog-post_31.html&#34;&gt;物件導向設計原則：里氏替換原則，定義、解析 - WadeHuang的學習迷航記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-5_liskov-substitution-principlelsp-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8F%9B%E5%8E%9F%E5%89%87/&#34;&gt;Object Oriented物件導向設計原則SOLID-5:Liskov Substitution Principle(LSP) 里氏替換原則 - Sian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%A5%91%E7%BA%A6%E5%BC%8F%E8%AE%BE%E8%AE%A1&#34;&gt;契約式設計 - 維基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tenlong.com.tw/products/9789864342099&#34;&gt;《無瑕的程式碼：物件導向原則、設計模式與C#實踐》&lt;/a&gt; Ch.10 LSP －－Liskov替換原則&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同系列文章&#34;&gt;同系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (11): 開放封閉原則</title>
      <link>https://igouist.github.io/post/2020/10/oo-11-open-closed-principle/</link>
      <pubDate>Sun, 25 Oct 2020 11:58:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/10/oo-11-open-closed-principle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/6pQOti2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;開放封閉原則-open-close-principle&#34;&gt;開放封閉原則 (Open-Close Principle)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;軟體實體（類別、模組、函式等等）應該對擴展開放，而對修改封閉&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我們了解什麼是「對擴展開放」和「對修改封閉」之前，先讓我們談談：什麼是擴展，什麼又是修改呢？&lt;/p&gt;
&lt;p&gt;用白話一點的方式來形容，修改就是把東西拆開來改，像是手術；而擴展就是對東西額外加裝模組，像是添購設備。我們用飛行來舉例，像是鳥類直接用翅膀飛行，如果有需要修改飛行方法的話就得對鳥直接進行手術；但如果今天是一個裝備了噴射背包的人，我們只需要把噴射背包換成噴射鞋子、甚至噴射翅膀就可以了，不需要去修改人這個本體。&lt;/p&gt;
&lt;p&gt;這邊可以發現開放封閉原則是針對「改變的時候」去做一個行動的建議，例如需求追加和變更等等。&lt;strong&gt;凡是變化都有成本&lt;/strong&gt;，例如變動的難易度、變動造成的影響範圍等等都會影響到成本，若是程式碼冗長、內部邏輯複雜，類別之間互相耦合、影響範圍很廣，導致綁手綁腳或壞東壞西等等狀況，使得修改很困難，成本就會變高，進而使得開發效率變低。&lt;/p&gt;
&lt;p&gt;然而，軟體並不是製造完畢就完工的東西，而是隨需求而生、隨需求而變的動態作品，因此程式碼的修改或重構相當頻繁。就像我們在 &lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;內聚耦合篇&lt;/a&gt; 提過的：軟體面對改變的能力，就像基因適應環境並生存下去的能力。因此，程式必須具有彈性，也就是需要盡可能降低修改的成本。&lt;/p&gt;
&lt;p&gt;那麼讓我們回到前面：動手術跟換道具，哪個的成本比較高呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;面對需求，對程式碼的改動是透過增加新程式碼進行的，而不是更改現有的程式碼&lt;/strong&gt;　　
&lt;br/&gt;（《大話設計模式》）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，我們希望能夠用擴充的方式去完成變化，而不是用針對內部進行修改的方式來做；希望藉由良好的設計，能迴避上面那串修改困難導致成本高昂的問題。&lt;/p&gt;
&lt;p&gt;而這個思路，其實你我都已經很習以為常了，就是&lt;strong&gt;模組化&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;模組化&#34;&gt;模組化&lt;/h2&gt;
&lt;p&gt;組裝電腦的時候，就是針對主機板加裝各種模組；寫程式的時候，我們也很習慣引入套件來使用；甚至使用 Visual Studio 或是 Chrome 這類軟體的時候，我們也都會使用擴充套件來加上我們需要的功能。甚至洛克人也是，我們打倒 BOSS 之後就能替洛克人加裝各種模組，讓他能夠具備各個 BOSS 的功能。噢當然我們不會把整台洛克人拆開然後改造成另一台，不然拆來拆去多麻煩。&lt;/p&gt;
&lt;p&gt;我們的周遭四處可見模組化，用模組來擴充本體的想法自古以來比比皆然。&lt;/p&gt;
&lt;p&gt;這邊就可以發現到：主機板上面事先會留好許多讓你接顯示卡或記憶體等等的插槽、Chrome 這類軟體會開放 API 和權限等功能給擴充套件來使用。當我們想要利用擴展的方式來擴充本體的能力時，我們需要留下一個供對接的地方，也就是&lt;strong&gt;擴充點&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;擴充點可以說是留給後人的貼心禮物（跟另一種留給後人的炸死人禮物並不相同）但是，我們要怎麼知道哪些地方可以擴充、可能擴充呢？我們可以先區分&lt;strong&gt;主要邏輯&lt;/strong&gt;和&lt;strong&gt;附加邏輯&lt;/strong&gt;，像是洛克人跟技能，你和噴射背包，又或者是「查詢客戶」的主邏輯和各種不同「查詢客戶的條件」等等的組合。&lt;/p&gt;
&lt;p&gt;因為如果不加以區分，我們就沒辦法把附加邏輯做成模組，也就找不到主要邏輯和附加邏輯之間的擴充點，如此一來就勢必要針對混成一坨的邏輯做修改和業務處理，接著就會落入我們在上一篇 &lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;單一職責原則&lt;/a&gt; 提過的各種悲慘下場：修改一個地方影響一狗票功能、修改前必須痛苦地閱讀大量不相關的程式碼…等等。&lt;/p&gt;
&lt;p&gt;這些問題，也正是&lt;strong&gt;單一職責原則&lt;/strong&gt;所要解決的。此處可以直接參考上一篇也引用過的 &lt;a href=&#34;https://wadehuanglearning.blogspot.com/2019/12/blog-post.html&#34;&gt;再談物件導向設計原則: 單一職責原則，定義、解析與實踐&lt;/a&gt; 這篇，裡面的學生列表例子就蠻直接好懂的。&lt;/p&gt;
&lt;p&gt;另外也必須推薦一下這位大大的 &lt;a href=&#34;https://wadehuanglearning.blogspot.com/2019/12/blog-post_11.html&#34;&gt;物件導向設計原則：開放封閉原則，定義、解析與實踐&lt;/a&gt; ，對業務邏輯和附加邏輯的說明也相當明確，從為什麼要隔離兩者，到如何實踐都有說明，值得一看。&lt;/p&gt;
&lt;p&gt;而我們辨認出主要邏輯跟附加邏輯之後，該怎麼實行開放封閉原則呢？&lt;/p&gt;
&lt;h2 id=&#34;實行&#34;&gt;實行&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;答案就是抽象。（《無瑕的程式碼：敏捷完整篇》）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這邊舉幾個方向：我們可以&lt;strong&gt;在主要邏輯和附加邏輯之間，加入抽象層來解耦合&lt;/strong&gt;，也就是我們 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;介面&lt;/a&gt; 大哥該出場的時候了。當我們的類別不再堅持依賴某個物件，例如說我就是要噴射背包，然後把背包黏死在背後；而是接受我只需要能飛的東西，不論傳遞進來的是噴射背包還是噴射鞋子，如此一來就夠用介面表達出需求，使得功能&lt;strong&gt;可以被任何符合需求的方式擴展&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;另外還有，使用外部注入來處理附加邏輯。除了不將附加邏輯寫在類別中，降低修改的機會以外，和介面的邏輯一致：你給什麼工具我就用什麼工具。當我們的附加邏輯是從外部丟給類別，使得類別預先留好擴充點，並且能由外部決定擴充方式，要擴展也就相當容易了。順便一提，我進公司學習以來，注入跟介面通常都是一起出現的 Combo 技。&lt;/p&gt;
&lt;p&gt;當我們在設置我們的擴充點（上個世紀稱作「放置鉤子」）時，有時會預測失敗，變成&lt;strong&gt;不必要的複雜性&lt;/strong&gt;。也很容易走火入魔，就變成&lt;strong&gt;過度設計&lt;/strong&gt;。因此，我們最終會等到足夠確信將會變化時，才進行重構的動作。&lt;/p&gt;
&lt;p&gt;在無瑕的程式碼中，建議可以接受「&lt;strong&gt;被愚弄一次&lt;/strong&gt;」，先假設不會變化，而當真的變化到來時，就將該變化相關的部份重構抽象起來，得了一次病，從此就免疫，還可以少走冤枉路。又或許，也可以嘗試看看 &lt;a href=&#34;https://shawnlin0201.github.io/Methodology/Methodology-004-Rule-Of-Three-principle/&#34;&gt;三次原則&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2024.09 補充：&lt;br/&gt;看見 Huanlin 大大寫了這篇 &lt;a href=&#34;https://www.huanlintalk.com/2024/09/avoid-premature-abstraction.html&#34;&gt;避免過早的抽象設計&lt;/a&gt;，覺得和「被愚弄一次」的精神相似。最近也在體會過早抽象帶來的痛苦，決定把這篇補充回來，給正在認識 OCP 的朋朋們參考。&lt;/p&gt;
&lt;p&gt;OCP 能幫助我們思考並寫出乾淨彈性的程式碼，但切記不要走火入魔，否則反而會帶來更多維護的成本。謹記三次重構原則，保一世平安，阿彌陀佛。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;結語&#34;&gt;結語&lt;/h2&gt;
&lt;p&gt;最後，開放封閉原則的範圍實在是太大了。事實上，其他設計原則，例如單一職責、依賴反轉等等，都是為了達到開放封閉這個終極的目標而產生的。但是，我們不可能預測到所有變化，也沒有任何做法能夠適用於所有狀況，因此要達到完全的封閉是不可能的。然而，這是我們應當嘗試精進的目標，只要謹記開放封閉原則，就能不斷改善架構，也就離良好的設計更進一步了。&lt;/p&gt;
&lt;p&gt;而對我而言，開放封閉的好處在於&lt;strong&gt;強迫像我這樣的工程師去思考：哪些地方是附加邏輯，哪些地方可以留作擴充，又該怎麼做才能方便擴充&lt;/strong&gt;，這個過程和嘗試對我輩菜鳥才是真正最有價值的地方吧。&lt;/p&gt;
&lt;p&gt;最後感謝一下 Ray 大大的路過指點。我當時問了不知道怎麼形容開放封閉原則，大大就說了個例子：咱們人哪，學新東西可是比改個性來得簡單多了。也基於這個例子讓我想到了手術和洛克人，還有變動的難易度、本性（核心邏輯）和新技能（附加邏輯）的差別可以這樣咻咻地串起來，這邊就謝過啦。順便也貼下大大的 &lt;a href=&#34;https://raychiutw.github.io/&#34;&gt;Blog&lt;/a&gt;，加減蹭一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列下一篇：&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jyt0532.com/2020/03/19/ocp/&#34;&gt;深入淺出開放封閉原則 Open-Closed Principle - jyt0532&amp;rsquo;s Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wadehuanglearning.blogspot.com/2019/12/blog-post_11.html&#34;&gt;物件導向設計原則：開放封閉原則，定義、解析與實踐 - WadeHuang的學習迷航記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/%E6%89%8B%E5%AF%AB%E7%AD%86%E8%A8%98/%E7%AC%AC-10-%E7%AB%A0-%E9%A1%9E%E5%88%A5-clean-code-1c7898d11cd7&#34;&gt;第 10 章 類別 | Clean Code 敏捷軟體開發技巧守則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://shawnlin0201.github.io/Methodology/Methodology-004-Rule-Of-Three-principle/&#34;&gt;程式設計心法 三次原則（Rule Of Three principle）- 璇之又璇的網路世界&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-2_open-close-principleocp-%E9%96%8B%E6%94%BE%E5%B0%81%E9%96%89%E5%8E%9F%E5%89%87/&#34;&gt;Object Oriented物件導向設計原則SOLID-2:Open-Close Principle(OCP) 開放封閉原則 - Sian&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同系列文章&#34;&gt;同系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>菜雞的 Markdown 筆記</title>
      <link>https://igouist.github.io/post/2020/10/markdown/</link>
      <pubDate>Sun, 18 Oct 2020 22:00:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/10/markdown/</guid>
      <description>&lt;p&gt;Markdown 是一種寫作用語言，特色是只要用簡單的符號就可以替文章進行排版，例如 &lt;code&gt;#&lt;/code&gt; 就代表了標題，因此能相當簡潔迅速地應用 Markdown 語法來撰寫出文件，目前已經被廣泛使用在各個撰寫文章或是文檔的場景中。&lt;/p&gt;
&lt;p&gt;例如 Github 用來說明專案的 Readme.md，從副檔名 md 就已經告訴你這是一篇 Markdown；又像是這個部落格的文章，也都是使用 markdown 來寫的。除此之外，像是 Facebook 和 Line 都開始支援簡單的 Markdown 語法了 —— 因為它實在是太方便好用了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用Markdown格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成 —— markdown.tw&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然用簡單的符號就能完成這些簡潔的排版，我們自然就能把專注的重心挪回到撰寫文章本身，這也就是 Markdown 最大的魅力：&lt;strong&gt;專注於內容&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;也因為 Markdown 的特色就是非常的簡潔乾淨，文檔本身的可讀性就相當的高，撰寫起來也很直覺容易。就如同其說明文件所說的：「Markdown 的目標就是實現『&lt;strong&gt;易讀易寫&lt;/strong&gt;』」&lt;/p&gt;
&lt;p&gt;這篇就來稍微紀錄一下 Markdown 的常用語法和好用的編輯環境吧！&lt;/p&gt;
&lt;h2 id=&#34;目錄&#34;&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%9B%AE%E9%8C%84&#34;&gt;目錄&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AA%9E%E6%B3%95&#34;&gt;語法&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A8%99%E9%A1%8C&#34;&gt;標題&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%86%E9%9A%94%E7%B7%9A&#34;&gt;分隔線&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%96%9C%E9%AB%94&#34;&gt;斜體&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%B2%97%E9%AB%94&#34;&gt;粗體&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%97%E8%A1%A8&#34;&gt;列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A0%B8%E5%8F%96%E6%96%B9%E5%A1%8A&#34;&gt;核取方塊&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BC%95%E7%94%A8&#34;&gt;引用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%80%A3%E7%B5%90&#34;&gt;連結&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9C%96%E7%89%87&#34;&gt;圖片&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A1%A8%E6%A0%BC&#34;&gt;表格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%A8%8B%E5%BC%8F%E7%A2%BC%E5%8D%80%E5%A1%8A&#34;&gt;程式碼區塊&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%B6%E4%BB%96&#34;&gt;其他&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A5%E5%85%B7&#34;&gt;工具&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#hackmd&#34;&gt;Hackmd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#typora&#34;&gt;Typora&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#visual-studio-code&#34;&gt;Visual Studio Code&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%B8%BD%E7%B5%90&#34;&gt;總結&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99&#34;&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;語法&#34;&gt;語法&lt;/h2&gt;
&lt;h3 id=&#34;標題&#34;&gt;標題&lt;/h3&gt;
&lt;p&gt;Markdown 中要加入標題，只需要在開頭加上 &lt;code&gt;#&lt;/code&gt; 就可以了。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 標題一 H1
## 標題二 H2
### 標題三 H3
#### 標題四 H4
##### 標題五 H5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/W20kTy7.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;或是使用底線標示的方式也可以告訴 Markdown 這是標題，例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;標題一 H1
========

標題二 H2
--------
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/q715Wbr.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;分隔線&#34;&gt;分隔線&lt;/h3&gt;
&lt;p&gt;如果是想區分段落，不想要輸入標題，也可以直接用分隔線 &lt;code&gt;---&lt;/code&gt;，但記得要空一行，不然會被誤認為標題，例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;我是紅海

---

我是紅海
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/cxLiHqU.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;斜體&#34;&gt;斜體&lt;/h3&gt;
&lt;p&gt;當我們需要斜體的時候，可以用 &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;_&lt;/code&gt; 來將文字包起來，例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;我是 *斜體* 啦！會有一點 _斜斜的_
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/PPq8IzB.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;粗體&#34;&gt;粗體&lt;/h3&gt;
&lt;p&gt;當如果需要強調某個語句或段落，則可以用 &lt;code&gt;**&lt;/code&gt; 或是 &lt;code&gt;__&lt;/code&gt; 來將文字包起來，例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;我是 **粗體** 啦！這一段 __很重要__ 哦！
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/IZXInCx.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;列表&#34;&gt;列表&lt;/h3&gt;
&lt;p&gt;列表分為有序和無序，其中有序的使用數字加上點來標示，例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1. 我是第一項
    1. 我是第一項的第一小項
    2. 我是第一項的第二小項
2. 我是第二項
3. 我是第三項
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/MZRCdPV.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;而無序清單則可以用 &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; 來標示，例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;- 蘋果
- 柳橙
- 香蕉
    - 香蕉？
    - 香蕉！
- 水蜜桃
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/O9kA2yG.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;核取方塊&#34;&gt;核取方塊&lt;/h3&gt;
&lt;p&gt;當我們需要建立待辦事項這類需要勾選的列表時，就可以考慮用核取方塊 &lt;code&gt;[ ]&lt;/code&gt; 和 &lt;code&gt;[x]&lt;/code&gt;：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;- [ ] 買蘋果
- [ ] 買柳橙
- [x] 買香蕉
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Ita9Wko.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;引用&#34;&gt;引用&lt;/h3&gt;
&lt;p&gt;需要引用某個片段或特別標示的時候，可以用 &lt;code&gt;&amp;gt;&lt;/code&gt;，例如：&lt;code&gt;&amp;gt; 我是一句名言&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;紙上得來終覺淺，絕知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大多數平台也會支援巢狀的用法，例如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;子非魚，安知魚之樂？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;子非我，安知我不知魚之樂？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/AdMF7DC.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;連結&#34;&gt;連結&lt;/h3&gt;
&lt;p&gt;需要加入連結的時候，可以使用 &lt;code&gt;[連結文字](網址)&lt;/code&gt;，例如當我要插入 Markdown.tw 的說明時就可以：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;請參見 [Markdown 語法說明](https://markdown.tw/)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/e8D1yFX.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;圖片&#34;&gt;圖片&lt;/h3&gt;
&lt;p&gt;當連結是圖片的時候，只需要在最前面加入 &lt;code&gt;!&lt;/code&gt; 變成 &lt;code&gt;![](圖片網址)&lt;/code&gt; 就可以囉，例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;![](https://avatars2.githubusercontent.com/u/16403463?s=460&amp;amp;u=fccdf65b21cb2dc5c544c3b473f135f00c574030&amp;amp;v=4)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就會跑出我家的貓（插入圖片也太難擷取成示意圖了吧，各位意會就好）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://avatars2.githubusercontent.com/u/16403463?s=460&amp;amp;u=fccdf65b21cb2dc5c544c3b473f135f00c574030&amp;amp;v=4&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;表格&#34;&gt;表格&lt;/h3&gt;
&lt;p&gt;表格應該是我在 Markdown 中覺得不太親切的東西了…&lt;/p&gt;
&lt;p&gt;其實就是要你直接畫一個表格出來（排版請見諒，已盡力）：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;| 水果名稱 | 好吃程度 | 昂貴程度 | 爆炸程度 |
| --- | --- | --- | --- |
| 蘋果 | 高 | 高 | 高 |
| 香蕉 | 中 | 低 | 無 |
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/yDwiiqK.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;也可以設定置中或靠右，例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;| 靠左 | 置中 | 靠右 |
| :--- | :---: | ---: |
| 芭樂 | 奇異果 | 蓮霧 |
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/EXSKe9T.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;程式碼區塊&#34;&gt;程式碼區塊&lt;/h3&gt;
&lt;p&gt;程式碼區塊使用反引號 &lt;code&gt;`&lt;/code&gt;，就是鍵盤左上角那個。如果只用一對把文字包起來就會是單行，例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;你可以使用 `Hello()` 這個語法來打招呼
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/HSlF7UZ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;而如果用三個反引號為一組，就可以產生程式碼區塊，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/fl5MDQs.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/MdtrbVx.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;有些平台會支援程式碼上色，這時候只要在第一組反引號後面加上程式語言就可以上色，例如
：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/BfrNXyR.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Main(&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;[] args)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Console.WriteLine(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello World!&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外有些平台也支援行號顯示，像 Hackmd 只需要在反組號的程式語言後加上等號就會顯示行號，例如 &lt;code&gt;csharp=&lt;/code&gt;，而我現在用的部落格主題，則是要到 config 統一配置才會顯示。&lt;/p&gt;
&lt;p&gt;由於 Markdown 力求簡潔，所以這些比較延伸的語法，通常需要看一下使用的編輯器是怎麼支援的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Xi48nAm.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;其他&#34;&gt;其他&lt;/h3&gt;
&lt;p&gt;另外隨著平台的支援，可能還有提供其他語法。例如用一或是兩個 &lt;code&gt;~&lt;/code&gt; 將文字包起來就常用於表達刪除號。提供寫作的平台多少都會有說明，開工前可以先翻翻看，畢竟語法糖不嫌多嘛。&lt;/p&gt;
&lt;h2 id=&#34;工具&#34;&gt;工具&lt;/h2&gt;
&lt;p&gt;接著讓我們介紹一些撰寫 Markdown 時的方便工具，以下這些是我比較常接觸的 Markdown 編輯環境，如果有什麼也挺不錯的還請告訴我一聲呦&lt;/p&gt;
&lt;h3 id=&#34;hackmd&#34;&gt;Hackmd&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/goVhwKW.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://hackmd.io/&#34;&gt;Hackmd&lt;/a&gt; 一定是必須推薦的！它是我目前做為主力的 Markdown 編輯器，它能夠：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供了方便的線上編輯環境，能用雙欄同時編輯和檢視&lt;/li&gt;
&lt;li&gt;多人協作&lt;/li&gt;
&lt;li&gt;貼上圖片自動上傳到 imgur&lt;/li&gt;
&lt;li&gt;可以嵌入 Youtube 影片等等&lt;/li&gt;
&lt;li&gt;將 md 檔直接儲存到 Github 或 Dropbox 等等空間&lt;/li&gt;
&lt;li&gt;可以使用&lt;a href=&#34;https://hackmd.io/c/tutorials-tw/%2Fs%2FMathJax-and-UML-tw&#34;&gt;語法&lt;/a&gt;直接產生 LaTeX、UML、流程圖甚至五線譜&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外還能夠將筆記分享給其他人，或是直接公開到網路上，甚至將筆記整理起來整理成&lt;a href=&#34;https://hackmd.io/s/how-to-create-book-tw&#34;&gt;書本&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;支援的用法相當多，打開瀏覽器就能用，可以說是使用 Mackdown 寫作的工具首選！甚至不少人直接當成團隊文檔庫或部落格在使用。有興趣的朋友，就從它的&lt;a href=&#34;https://hackmd.io/c/tutorials-tw/%2Fs%2Ftutorials-tw&#34;&gt;使用教學&lt;/a&gt;開始試試吧！&lt;/p&gt;
&lt;h3 id=&#34;typora&#34;&gt;Typora&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/CNC48VZ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;對我來說最方便的 Markdown 寫作環境是 Hackmd 的話，那最美的 Markdown 寫作環境就是 Typora 了。直接前往 &lt;a href=&#34;https://typora.io/&#34;&gt;Typora 的網站&lt;/a&gt; 就可以感受到它的那種極簡風格。&lt;/p&gt;
&lt;p&gt;另外 Typora 也支持使用自訂主題，只要從設定中打開主題資料夾，把 CSS 丟進去就好了，因此可以上社群（例如熟悉的 One Dark）甚至自製主題來讓編輯器更好看。&lt;/p&gt;
&lt;p&gt;Typora 也支援將文檔製作成 PDF 的功能，並且這個 PDF 是吃得到主題的 CSS 的！像我自己的履歷表就是用 Typora 寫完之後，調整 CSS 直接壓成 PDF 的，這邊也推薦給大家。&lt;/p&gt;
&lt;p&gt;改得順眼之後只能用舒服優雅來形容，寫起來都賞心悅目了，推薦熟悉 Markdown 語法之後可以試試。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/SChJiOf.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;但記得要先去偏好設定改成一體化視窗，並且去主題資料夾稍微修改一下字型讓中文舒服一點，像附圖就是使用了&lt;a href=&#34;https://github.com/be5invis/Sarasa-Gothic&#34;&gt;更紗黑體&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;整體來說，如果你要去咖啡廳之類的寫文章，那就真的可以帶 Typora 回去改個自己喜歡的主題，真的舒服。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;更新: Typera 也有主題下載頁囉！可以從 &lt;code&gt;設定 → 偏好設定&lt;/code&gt; 前往&lt;/p&gt;
&lt;p&gt;或是直接到 &lt;a href=&#34;https://theme.typora.io/&#34;&gt;https://theme.typora.io/&lt;/a&gt; 下載主題&lt;/p&gt;
&lt;p&gt;這邊也推薦一組很棒的主題：&lt;a href=&#34;https://github.com/liangjingkanji/DrakeTyporaTheme&#34;&gt;DrakeTyporaTheme&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;補充: 想要跟 HackMD 一樣能夠直接貼上圖片上傳的朋友，也可以參考這兩篇：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pjchender.blogspot.com/2020/08/app-typora-imgur-for-mac.html&#34;&gt;Typora 自動上傳圖片到 imgur (for Mac)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/130878433&#34;&gt;Windows 下采用 Typora + PicGo 搭建 Markdown 图床&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;visual-studio-code&#34;&gt;Visual Studio Code&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/EDccuCQ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;那真是太諷刺了紹安&lt;/del&gt;，繞了一圈最後最常用的還是 Visual Studio Code 直接開寫，畢竟 Hugo 寫部落格的時候也是在本機寫好推上去，過一陣子就懶得開東開西，只想直接開工。所以還是直接用 VSCode 最快了。&lt;/p&gt;
&lt;p&gt;安裝一下 Markdown 的套件之後就能直接開工了，我個人是安裝 &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one&#34;&gt;Markdown All in One&lt;/a&gt;，該有的都有了。&lt;/p&gt;
&lt;p&gt;不過上面的 Hackmd 也有推出 VScode 用的 &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=HackMD.vscode-hackmd&#34;&gt;Hackmd&lt;/a&gt; 套件包，像上面提到的繪製流程圖、數學式等功能也包含在內，有這類需求的朋友也可以使用看看。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;補充: 想要跟 HackMD 一樣能夠直接貼上圖片上傳的朋友，也可以試試 vscode-imgur 這套插件呦&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;總結&#34;&gt;總結&lt;/h2&gt;
&lt;p&gt;這篇記錄了一些常用的 Markdown 語法，並且推薦了三款 Markdown 編輯器，有興趣的朋友可以嘗試用 Markdown 打打文章或是規範文檔，相信一定能感受到 Markdown 的魅力。那麼，我們下周見～&lt;/p&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://markdown.tw/&#34;&gt;Markdown&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wcc723.github.io/development/2019/11/23/ten-mins-learn-markdown/&#34;&gt;十分鐘快速掌握 Markdown&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10203758&#34;&gt;Markdown - 易編易讀，優雅的寫文吧！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=vlFm3EVVj6Y&#34;&gt;筆記＆寫作神器 MarkDown 真希望我學生時期就懂！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pjchender.blogspot.com/2020/08/app-typora-imgur-for-mac.html&#34;&gt;Typora 自動上傳圖片到 imgur (for Mac) - PJCHENder 那些沒告訴你的小細節&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>聊一下外接螢幕</title>
      <link>https://igouist.github.io/post/2020/10/external-screen/</link>
      <pubDate>Sun, 11 Oct 2020 23:50:17 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/10/external-screen/</guid>
      <description>&lt;p&gt;這週入手了新玩具，在這邊記錄下～&lt;/p&gt;
&lt;p&gt;&lt;s&gt;我們家大神大大跟我說部落格就當推特發就對了，唉呀我也是深表認同吶&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/5BHHs9a.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;像我這種被實驗室和公司寵壞的人，已經習慣了雙螢幕的好。結果不管是在放不下兩台螢幕的家裡書桌，還是帶著筆電出門，尤其是一邊寫東西一邊查資料，需要來來回回切換視窗時，總是會想「唉呀真想把這丟到另一個螢幕啊！」&lt;/p&gt;
&lt;p&gt;因此！幾經掙扎之後，還是入手了外接螢幕！&lt;/p&gt;
&lt;p&gt;開場先說心得，雖然尚未有外出機會，但目前的使用相當滿意。這邊就說說個人體會的好壞：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2021/1/30 補充：外出也相當方便，只是桌面的空間就需要大一點&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;外接螢幕的讚&#34;&gt;外接螢幕的讚&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;有雙螢幕很爽&lt;/li&gt;
&lt;li&gt;可以攜帶出門，到圖書館之類的地方也能有雙螢幕很爽&lt;/li&gt;
&lt;li&gt;雙螢幕在一邊 Coding 一邊 &lt;s&gt;抄Stackoverflow&lt;/s&gt; 查資料，或是像部落格一邊編輯一邊看結果的時候很爽&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其實整個說起來就是帶著筆電也能雙螢幕的那種爽感，一旦用過雙螢幕，感受到不用一直切換視窗的流暢感之後，就真的回不去啦。&lt;/p&gt;
&lt;h3 id=&#34;外接螢幕的沒那麼讚&#34;&gt;外接螢幕的沒那麼讚&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;加上保護套之後幾乎都要一公斤左右，不太能忽視&lt;/li&gt;
&lt;li&gt;出門在外還要接一堆線有時候不太美觀&lt;/li&gt;
&lt;li&gt;背包裏面又是筆電又是螢幕又是手機錢包的，身家財產哪！包包離開視線就會心神不寧&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;誰適合用外接螢幕&#34;&gt;誰適合用外接螢幕&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;有出外工作習慣，例如跑去咖啡廳帥一天的朋友們&lt;/li&gt;
&lt;li&gt;像我一樣桌電筆電交替使用的朋友們&lt;/li&gt;
&lt;li&gt;只是想要出門用大螢幕打 Switch 的朋友們&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大概先這樣，推特也有字數限制呢。等有外出機會還是有什麼心得再來補充一下，先去享受新玩具了
這週也是今年最後一個連假了，各位開工愉快，咱們下周見&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/QDW7Xm9.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;補充一下：我個人入手的型號是 MSI Optix MAG161V，算是相當輕便好看。線材接的位置也挺不錯的，螢幕看著也挺舒服。&lt;/p&gt;
&lt;p&gt;Google 一下也有挺多&lt;a href=&#34;https://www.kocpc.com.tw/archives/315455&#34;&gt;開箱文&lt;/a&gt;和介紹影片的，有興趣可以看看。我這真拍不出像樣的開箱文，太難了，我嘗試過了…。這邊就推薦一下外接螢幕這東西，有興趣的朋友再自己做功課吧～&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (10): 單一職責原則</title>
      <link>https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle/</link>
      <pubDate>Fri, 02 Oct 2020 11:03:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/VyyeaYz.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我們在前面的 &lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;內聚和耦合&lt;/a&gt; 有提到過，內聚並不是無腦把相關的程式碼都封在一起就好了，也有分成健康的和不健康的。但我們要怎麼知道這個類別是否足夠健康呢？單一職責原則就是很好的檢驗方式，這篇就讓我們來紀錄一下。&lt;/p&gt;
&lt;h2 id=&#34;單一職責原則-single-responsibility-principle&#34;&gt;單一職責原則 (Single Responsibility Principle)&lt;/h2&gt;
&lt;p&gt;「單一職責」原則顧名思義，就是一個類別應該&lt;strong&gt;只負責一個職責&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但是這樣太過籠統了，「職責」相當容易產生誤會，容易變成各說各話。&lt;s&gt;畢竟咱們工程師最愛戰定義了嘛。&lt;/s&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;「你這類別不優，它有兩個職責！登入跟登出！」&lt;/p&gt;
&lt;p&gt;『沒有啦，我這個類別就是負責帳戶管理的啊』&lt;/p&gt;
&lt;p&gt;「&lt;a href=&#34;https://dailyview.tw/Daily/2019/11/07&#34;&gt;OSSO&lt;/a&gt;。乾脆你全部放一起，然後說是負責網站管理算了，呵」&lt;/p&gt;
&lt;p&gt;『……你存心來找碴的是不是？』&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;為了避免像這樣產生職場糾紛，我們需要先定義一下什麼是「職責」。經過前輩們的努力（解釋）之後，單一職責的定義就成了：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;就一個類別而言，應該只有一個引起它變化的原因&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外，我也看過「一個類別應該只對一個角色負責」的說法，這兩者的核心概念是一樣的。&lt;/p&gt;
&lt;p&gt;這邊讓我們簡單舉個例子。如果在訂單管理的類別中有一個新增訂單的方法，在收到訂單之後，會依序處理訂單、並取出會員的聯絡資訊，再依靠聯絡資訊寄送通知信件給會員。但它的實作全靠自己來，如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;新增訂單()
{
   // 收到訂單
   /*
     一些訂單的商業邏輯
   */

   // 寫入訂單
   /*
     一些和資料庫連線寫入資料的處理
   */

   // 取得聯絡資訊
   /*
     一些連到資料表或服務拿會員資料的處理
   */

   // 寄送通知
   /*
     一些寄送信件的處理，如寄送者和寄送方式等等
   */
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這樣一路就是流水帳打完收工，這樣的一個函式參雜了一堆不相干的邏輯，可能動輒數百行，每一段都處理各種不同的工作，一看就很明顯違反單一職責原則。&lt;/p&gt;
&lt;p&gt;當訂單處理的商業邏輯、查詢會員資料的邏輯或是通知會員的方式有變更的時候，這個函式都會受到影響，也就是說這個函式同時對多個不同對象負責。這樣的類別或函式就是&lt;strong&gt;不穩定的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;遇到這種情況，我們可以將其&lt;strong&gt;拆分&lt;/strong&gt;。讓上帝的歸上帝，讓凱薩的歸凱薩。&lt;/p&gt;
&lt;p&gt;例如說會員的處理一律封裝回會員管理類別，我們再藉由會員管理類別去調用其方法取回資料；寄送信件也封裝到通知管理類別，不用去管用什麼方法通知的，我們只需要去要求其通知即可。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有些朋友可能會有疑問，這樣不就會和會員處理類別、通知管理類別之類的其他類別有了&lt;strong&gt;耦合&lt;/strong&gt;關係嗎？有這樣的疑問是很合理的，這也就是為什麼我們會需要&lt;strong&gt;介面&lt;/strong&gt;來讓類別之間不要直接彼此依賴，這部份我們在 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;介面&lt;/a&gt; 有詳細介紹。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;新增訂單(訂單)
{
    處理訂單商業邏輯(訂單)

    訂單資料存取服務.儲存訂單() // 可能由資料存取層或連線管理等該職責的地方去實現

    通知服務.寄送訂單通知(訂單.訂購人編號)
}

處理訂單商業邏輯(訂單)
{
   // 專注在處理商業邏輯，不用管其他事
}

// 其他的職責拆分出去給負責該工作的類別
通知服務 { 寄送訂單通知(編號); }
訂單資料存取服務 { 儲存訂單(); }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我們&lt;strong&gt;把工作交給負責該職責的類別去做，自己只需要關注在自己正在處理的職責即可&lt;/strong&gt;。聰明的朋友可能已經注意到了，這就是&lt;strong&gt;封裝&lt;/strong&gt;的體現。封裝得夠舒服，我們就能舒服地處理自己的事情就好，這就是分工合作的偉大呀。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(2022-01-23) 補充：&lt;/p&gt;
&lt;p&gt;前面提到的「職責」的部分，雖然我們前面提過了是「引起變化的原因」，但可能還是太過模糊，&lt;s&gt;畢竟咱們工程師真的最愛戰定義了嘛。&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;今天在群組裡有前輩分享了講解單一職責原則的影片：&lt;a href=&#34;https://youtu.be/e0UOuQ_lCUY?t=1073&#34;&gt;Fred 聊聊 SOLID 設計原則&lt;/a&gt;，其中單一職責的部份，將前述的「引起變化」從&lt;strong&gt;業務需求變更&lt;/strong&gt;的方式切入&lt;/p&gt;
&lt;p&gt;影片中用實例來說明什麼時候該切分職責和其重點，例如 &lt;strong&gt;「業務耦合造成的問題就是職責不明確」、「不要讓類別去碰它不該做的事情等等」&lt;/strong&gt; ，我個人覺得非常不錯，推薦給想更了解單一職責原則或 SOLID 的朋友&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;雖然文章中的例子相對簡單。但有一個部份我個人覺得要特別注意：單一職責當然也可以用在函式上。甚至資料表或任何需要管理、分類抽象事物的東西上。&lt;/p&gt;
&lt;p&gt;有些朋友可能跟我前陣子一樣，覺得函式就是用來消除重複的程式碼，直到我看了 &lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10206839&#34;&gt;可不可以不要寫糙 code&lt;/a&gt; 和一句「難道只有重複才需要做成 Function 嗎？」才明白：函式真正的工作其實是封裝邏輯。&lt;/p&gt;
&lt;p&gt;既然是封裝邏輯這種抽象的東西，必然也會有其職責，自然也得好好注意單一職責囉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;走向單一職責&#34;&gt;走向單一職責&lt;/h2&gt;
&lt;p&gt;我們可以從上面的差別重新思考，遵守與不遵守單一職責原則會有哪些顯著的差異。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;當我們並未遵守單一職責原則時&lt;/strong&gt;，同個類別裡面充斥著不同工作的處理邏輯。也就是不健康的內聚：完全不夠聚，就只是盤散沙。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;容易產生&lt;strong&gt;意外的重複&lt;/strong&gt;。每個類別每個方法都自己去查詢會員資料，當查詢會員資料的方式或規則有變更的時候，影響範圍就會非常大，同樣的事情有一大堆地方要改，還得要先全部找出來，想到就頭痛。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同時我們在修改時也&lt;strong&gt;無法界定邊界&lt;/strong&gt;，無法確定這次修改影響到的範圍，我們並不知道這些放在一起的東西，或是同一段做的所有事之間&lt;strong&gt;是否會相互影響&lt;/strong&gt;，這將導致每次修改的時候都在挑戰我們自己的心臟負荷量，讓維護變成試膽大會，類別變成危樓改建。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;承上，我們為了要確保修改沒有問題，我們必須&lt;strong&gt;大量閱讀不相關的程式碼&lt;/strong&gt;，無形中造成開發負擔，降低開發效率。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你曾經有閱讀別人的程式碼，卻始終看不懂這東西到底在幹嘛，每分鐘髒話數筆直上升的經驗。答應我，&lt;strong&gt;我們不要讓別人經歷相同的悲劇&lt;/strong&gt;，我們要斬斷仇恨的鎖鏈。我們，今天就開始走向單一職責。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;當我們終於選擇單一職責&lt;/strong&gt;，我們的類別才能真的擁有健康的高內聚。以上的這些問題，也都變成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每個類別都專注在自己職責上，需要這個功能的其他類別就能來使用。大大提高了程式碼的&lt;strong&gt;重複使用&lt;/strong&gt;程度，同時也&lt;strong&gt;降低了程式碼的重複性&lt;/strong&gt;。並且因為類別內都是朝同樣職責前進的成員，彼此關聯性相當高，因此也&lt;strong&gt;提高了內聚&lt;/strong&gt;。這兩點讓我們能迴避掉「要改的地方太多了，就改天吧」的悲傷結局。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同時，當我們要修改時，只需要找到負責的類別修改。因為已經把不屬於職責的工作交給其他類別了，達到了封裝和隔離，所以我們就能輕鬆看出修改的區域和邏輯，並較少地被不相干的東西影響、馬上掌握修改的目標和影響範圍，使得架構和類別&lt;strong&gt;更容易管理&lt;/strong&gt;。也就是說，單一職責可以達到&lt;strong&gt;降低耦合&lt;/strong&gt;的效果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;展現你的意圖&#34;&gt;展現你的意圖&lt;/h2&gt;
&lt;p&gt;單一職責讓我想到前陣子看的&lt;a href=&#34;https://igouist.github.io/post/2020/09/start-with-why&#34;&gt;《先問為什麼》&lt;/a&gt;中的芹菜測試：當你在超市結帳時，手上拿著巧克力、豆漿、餅乾跟芹菜，沒有人看得出來你到底要幹嘛。&lt;/p&gt;
&lt;p&gt;寫程式也是如此，&lt;strong&gt;如果你的類別或方法裡什麼都要，彼此間又甚無關連，那就沒人看得懂這到底是幹嘛的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果團隊的其他人不能瞭解這個類別的職責，那後續協助修改的時候就會沒辦法把相同工作的程式碼歸類在一起，甚至難以修改，做起事綁手綁腳，新增個方法都會陷入混亂。整個架構就會開始腐敗。這也就是為什麼我們需要保持程式碼的可讀性，並且盡力實踐單一職責。&lt;/p&gt;
&lt;p&gt;如同我在先問為什麼文中所引用的「你的一言一行，都要能證明你的信念」。在這裡，你的類別、方法，甚至是程式碼中的每一區塊，都必須要能夠&lt;strong&gt;展現你的意圖&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因此，單一職責不只能用來檢驗類別。從一整個服務，到單一個函式，都可以用它的意圖來問問自己。這一段是否只有一個職責？&lt;strong&gt;是否只有一個原因造成改變？職責是否清晰？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;當然，從模組到函式每一層級的抽象概念是不一樣的，模組有模組關注的點，函式有函式關注的點，其規模有所差異，請不要用函式的職責大小去要求整個類別，我個人覺得這中間的差異還是挺吃經驗的，但不去嘗試思考，就沒得經驗可說嘛。這邊還是鼓勵大家多多利用單一職責去檢驗任何片段的程式碼。&lt;/p&gt;
&lt;p&gt;當我們利用單一職責原則去檢驗，或是思考方向的時候，如果&lt;strong&gt;列得出兩項以上的變更原因，且這些原因彼此關聯很薄弱的時候，就是警訊&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;反過來說，即使有兩個原因引起變化，但這些原因之間的關聯很強，例如總是一起變化，那其實就不必分離，或是可以暫緩分離，避免&lt;strong&gt;過度設計&lt;/strong&gt;所引起的&lt;strong&gt;不必要的複雜性&lt;/strong&gt;。（白話文來說就是走火入魔）&lt;/p&gt;
&lt;p&gt;如果能做到撰寫功能當下，或是重構的時候不斷自我檢驗，那寫出來的程式碼品質相信也能展現出一定的水準了吧！共勉之。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文整理時主要參考了這兩篇，寫得相當不錯，想更瞭解的朋友可以參考一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://wadehuanglearning.blogspot.com/2019/12/blog-post.html&#34;&gt;再談物件導向設計原則: 單一職責原則，定義、解析與實踐 - WadeHuang的學習迷航記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jyt0532.com/2020/03/18/srp/&#34;&gt;深入淺出單一職責原則 Single Responsibility Principle - jyt0532’s Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;看到這篇覺得很不錯，從另一個角度切入單一職責，回來補充給各位朋友：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ruddyblog.wordpress.com/2022/11/25/%e5%b7%a5%e7%a8%8b%e5%b8%ab%e7%9a%84%e7%b0%a1%e5%96%ae%e8%a7%80%e5%bf%b5/&#34;&gt;工程師的簡單觀念 – Ruddy Lee 分享空間 (wordpress.com)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列下一篇：&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://wadehuanglearning.blogspot.com/2019/12/blog-post.html&#34;&gt;再談物件導向設計原則: 單一職責原則，定義、解析與實踐 - WadeHuang的學習迷航記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10191955&#34;&gt;SOLID 之 單一職責原則（Single responsibility principle）- Miles - iT邦幫忙&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jyt0532.com/2020/03/18/srp/&#34;&gt;深入淺出單一職責原則 Single Responsibility Principle - jyt0532&amp;rsquo;s Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://youtu.be/e0UOuQ_lCUY?t=1073&#34;&gt;Fred 聊聊 SOLID 設計原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-1_single-responsibility-principlesrp-%E5%96%AE%E4%B8%80%E8%81%B7%E8%B2%AC/&#34;&gt;Object Oriented 物件導向設計原則 SOLID-1:Single Responsibility Principle(SRP) 單一職責 - Sian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@n26074273/solid-i-%E5%96%AE%E4%B8%80%E8%81%B7%E8%B2%AC%E5%8E%9F%E5%89%87-single-responsibility-principle-11e30ece0778&#34;&gt;SOLID-I 單一職責原則(Single Responsibility Principle) - 黃子源 - Medium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tenlong.com.tw/products/9789866761799&#34;&gt;《大話設計模式》&lt;/a&gt; Ch3. 拍攝UFO －－單一職責原則&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tenlong.com.tw/products/9789864342945&#34;&gt;《無瑕的程式碼：整潔的軟體設計與架構篇》&lt;/a&gt; Ch.7 SRP －－單一職責原則&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tenlong.com.tw/products/9789864342099&#34;&gt;《無瑕的程式碼：物件導向原則、設計模式與C#實踐》&lt;/a&gt; Ch.8 SRP －－單一職責原則&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同系列文章&#34;&gt;同系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>C#: 元組 (Tuple)</title>
      <link>https://igouist.github.io/post/2020/09/csharp-trulp/</link>
      <pubDate>Sun, 27 Sep 2020 23:56:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/09/csharp-trulp/</guid>
      <description>&lt;p&gt;因為隔壁介紹原則的部分有點卡住了，所以這週來紀錄一下挺常用到的方便東西：&lt;strong&gt;Tuple&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;這篇的 Tuple 指的是 C# 7.0 後提供的 &lt;strong&gt;ValueTuple&lt;/strong&gt; 和相關語法，舊版得用 &lt;code&gt;Tuple.Create&lt;/code&gt; 建立，成員的名稱也只能使用 Item1, Item2&amp;hellip;，實用性並不是很高。但新 Tuple 出現後，方便程度大大提升，這邊就稍作紀錄一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;註：此處使用的 &lt;code&gt;Dump&lt;/code&gt; 是 Linqpad 提供的輸出方法，把它當成 Print 就行了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; student = (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;王小明&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;student.Item1.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// 1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;student.Item2.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// 王小明&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;student.Dump();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到 Tuple 的建立相當簡單，只需要用小括號 &lt;code&gt;()&lt;/code&gt; 括選起來即可。建立後的內容就會像這樣：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/H0wJglN.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;但這樣使用就和之前一樣，取出來時只能拿 Item1, Item2，放個幾天根本就不記得 Item1 裡面是啥東西了。這時我們就可以&lt;strong&gt;替成員們取名字&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ID, &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; Name) student = (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;王小明&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;student.ID.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// 1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;student.Name.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// 王小明&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如此使用的時候就和一般操作物件的習慣沒有差別，也增加了可讀性。&lt;/p&gt;
&lt;p&gt;到這裡可能感覺只是個方便的變數打包小工具，但其真正順手的地方就在於作為&lt;strong&gt;回傳值&lt;/strong&gt;的時候。&lt;/p&gt;
&lt;p&gt;過去要一次回傳多個值，除了使用 Ref 等方式以外，就只能乖乖做一個類別來裝，但有時候傳的東西又相當簡單，實在不太願意就此建立一個類別，又或是事情已經無法挽回，專案虛胖了一堆&lt;strong&gt;米蟲類別&lt;/strong&gt;。有了 Tuple 之後，面對這種情況就可以&lt;strong&gt;直接使用 Tuple 解決&lt;/strong&gt;，並且替成員們命名之後，既簡便又好讀！&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 回傳型別使用 Tuple&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; IsSuccess, &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; Message) DoSomeThing()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 做了一堆事情&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;操作成功&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; result = DoSomeThing();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	result.IsSuccess.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	result.Message.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// 操作成功&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而當我們作為回傳值使用時，也可以直接原地解封：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 回傳型別使用 Tuple&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; IsSuccess, &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; Message) DoSomeThing()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 做了一堆事情&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;操作成功&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 直接拆開賦值給多個變數&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; (isSuccess, message) = DoSomeThing();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	isSuccess.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	message.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// 操作成功&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;作為一個簡易臨時型別挺方便的，但要注意不要用過頭了。兩三個成員還算方便，如果有七八個甚至十來個成員，請還是乖乖做成類別吧！&lt;/p&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.huanlintalk.com/2017/04/c-7-tuple-syntax.html&#34;&gt;C# 7 新增的 Tuple 語法 - Huanlin 學習筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/supershowwei/2018/10/01/135755&#34;&gt;[料理佳餚] 用 ValueTuple 解放雞肋類別 - 軟體主廚的程式料理廚房&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (9): SOLID</title>
      <link>https://igouist.github.io/post/2020/09/oo-9-solid/</link>
      <pubDate>Sun, 20 Sep 2020 13:51:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/09/oo-9-solid/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/U7iWMT9.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;終於進入了原則篇，接下來的幾篇我們會介紹幾個物件導向的原則（基本上就是指 SOLID 原則）。因此這篇就讓我 &lt;s&gt;水一下&lt;/s&gt; 當成後半段的目錄，方便之後可以把相關的部分整理進來。&lt;/p&gt;
&lt;h2 id=&#34;為什麼我們需要這些原則&#34;&gt;為什麼我們需要這些原則？&lt;/h2&gt;
&lt;p&gt;我們在前面的章節已經說明了一些物件導向的特性，例如繼承和多型等等。然而我們並沒有討論到怎麼運用、或是怎樣設計才能算是更好的、更優雅的、更符合物件導向精神的；我們並沒有提到一個評估的標準，或是指引一個更好的方向。&lt;/p&gt;
&lt;p&gt;然而，混亂的使用物件導向對整個專案的毀滅性甚至比乾脆不使用物件導向還高。&lt;/p&gt;
&lt;p&gt;這些特性使用起來很簡單，大多數語言只需要一個符號或標示就能完成繼承，把一堆東西全部塞在一起就可以說我在封裝。但怎麼使用得好，又該什麼時候使用呢？這就是難的地方吧。&lt;/p&gt;
&lt;p&gt;例如說濫用繼承，或是封裝時完全不隱藏複雜度一路 Puuuuublic 到底，又或者是類別之間過於相互依賴，全部耦合成一團等等。如果隨便地使用物件導向的各項特性，就會讓整個架構變得僵化、脆弱、危險、充滿臭味。&lt;/p&gt;
&lt;p&gt;更可怕的是，這個發臭的過程是每一次設計、每一次修改都會有所影響，所謂「持續發生，腐敗成真」，&lt;strong&gt;隨著物件導向的亂用、誤用、無腦用，軟體就會逐漸腐化&lt;/strong&gt;。一組腐化的軟體可能會有以下特徵：大量的依賴使得修改變得困難、修改後看似不相干的各個地方發生問題、或是修改時沒辦法依循原本的設計、到處出現不必要的複雜性和不必要的重複，模組也變得難以理解等等。&lt;/p&gt;
&lt;p&gt;阻止程式碼的腐化、追求更好的架構和設計、寫出更好的代碼，當然是我輩所追求的目標。儘管面對的可能是不同的問題和不同的環境，那些優質、穩固、具有&lt;strong&gt;反脆弱&lt;/strong&gt;特質的程式碼也必然會有些共通之處。例如說：需要具有&lt;strong&gt;面對改變&lt;/strong&gt;的能力、具有&lt;strong&gt;方便管理&lt;/strong&gt;的能力、具有&lt;strong&gt;隱藏複雜性&lt;/strong&gt;的能力。&lt;/p&gt;
&lt;p&gt;因此，大前輩們整理並提出了一些可以致力的方向，也就是所謂的「&lt;strong&gt;原則&lt;/strong&gt;」。如同心法、教義一般，只要實作的同時將其牢記在心，就能讓我們作為一些行動的準則和依據。&lt;/p&gt;
&lt;p&gt;所謂練拳不練功，到老一場空。我們可不能看了招式就無腦用，先讓我們看一下這些 SOLID 原則的目標是什麼。&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&#34;https://www.books.com.tw/products/0010786994&#34;&gt;Clean Architecture&lt;/a&gt; 裡是這樣說明的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這些原則的目標是建立中層級的軟體結構，這樣的結構包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能容忍變化&lt;/li&gt;
&lt;li&gt;容易理解&lt;/li&gt;
&lt;li&gt;在許多軟體系統中能夠使用的元件的基礎&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;「中層級」是指這些原則是程式設計師在模組層級工作時應用的原則。它們應用在程式碼層級之上，並且有助於定義模組和元件內使用的軟體結構類型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我們應用這些原則的場景，應該是在所謂的「中層級」發生。也就是並非小到一行程式碼，也並非是一整個專案，而是其中的各個「&lt;strong&gt;模組&lt;/strong&gt;」。不論是類別、介面又或是其他名稱的任何東西，凡是具有函式或資料的中層級，我們就可以運用這些原則來處理。&lt;/p&gt;
&lt;p&gt;而我們之所以要用這些原則，就是為了達到 &lt;strong&gt;能容忍變化&lt;/strong&gt;、&lt;strong&gt;容易理解&lt;/strong&gt;、&lt;strong&gt;能讓模組和元件使用&lt;/strong&gt; 這些目標。&lt;/p&gt;
&lt;p&gt;這些目標可以當作一個良好的程式碼模組該有的特徵。你的類別必須能容忍變化，必須具備可擴展性和可修改性，畢竟&lt;strong&gt;軟體的需求大多時候都是擴展跟修改&lt;/strong&gt;。更進一步說，功能和彈性之間甚至應該先選擇彈性，畢竟為了功能犧牲彈性的話，一但面對變化，整個程式就碎了；但優先選擇彈性的話，至少你還有機會能把它修改得更符合功能，所以對這些原則而言，能容忍變化是相當重要的。甚至，&lt;strong&gt;整個 SOLID 就是面對變化的作戰策略&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而容易理解就更重要了。Clean Code 裡有提過，&lt;strong&gt;閱讀程式碼和實際開工打字的時間大約是佔 10 : 1&lt;/strong&gt;，因此是否容易理解，是否乾淨好懂就是相當重要的一環。看得快，就寫得快；寫得越快，心越慢。&lt;/p&gt;
&lt;p&gt;如同我們在首篇所說，物件導向就是在替我們把概念抽象化，而這抽象過程所使用的這些特性，就是為了減少複雜性、提高可理解度而存在的。因此，一組優良的程式碼，容易理解是絕對必要的。&lt;/p&gt;
&lt;p&gt;另外關於為什麼我們需要這些原則，我個人推薦可以先閱讀這幾篇，對我個人來說很有收穫：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://wadehuanglearning.blogspot.com/2019/10/solid.html&#34;&gt;淺談物件導向 SOLID 原則對工程師的好處與如何影響能力 - WadeHuang的學習迷航記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wadehuanglearning.blogspot.com/2019/10/solid-why-solid.html&#34;&gt;再談 SOLID 原則，Why SOLID? - WadeHuang的學習迷航記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://teddy-chen-tw.blogspot.com/2014/04/solid.html&#34;&gt;SOLID：五則皆變 - 搞笑談軟工&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;說那麼多所以到底有哪些原則&#34;&gt;說那麼多，所以到底有哪些原則？&lt;/h2&gt;
&lt;p&gt;現在我們已經了解到，因為軟體會逐漸腐化，所以我們要找出原則；這些原則的目標，就在於設計出可變化可理解的優質模組。現在，是時候公布我們 SOLID 五大天王的名諱了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;單一職責原則 &lt;strong&gt;S&lt;/strong&gt;ingle Responsibility Principle (SRP)&lt;/li&gt;
&lt;li&gt;開放封閉原則 &lt;strong&gt;O&lt;/strong&gt;pen-Closed Principle (OCP)&lt;/li&gt;
&lt;li&gt;里氏替換原則 &lt;strong&gt;L&lt;/strong&gt;iskov Substitution Principle (LSP)&lt;/li&gt;
&lt;li&gt;介面隔離原則 &lt;strong&gt;I&lt;/strong&gt;nterface Segregation Principle (ISP)&lt;/li&gt;
&lt;li&gt;依賴反轉原則 &lt;strong&gt;D&lt;/strong&gt;ependency Inversion Principle (DIP)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;註：大多時候 L 的位置也會多一個 Law of Demeter 迪米特法則（= Least Knowledge Principle 最少知識原則），畢竟也挺重要的，而且四大天王都有五個人了，五大原則有六個也是剛剛好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而它們的首字合起來就是 &lt;strong&gt;&lt;code&gt;SOLID&lt;/code&gt;&lt;/strong&gt;，表達出那種穩固的、可靠的感覺！順便一提，順序沒有任何關係，會排成 SOLID 純粹只是作者朋友當時覺得這樣比較好記。&lt;/p&gt;
&lt;p&gt;那麼從&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;下一篇&lt;/a&gt;開始，我們就按照 SOLID 的順序，從單一職責開始介紹。我們下次見～&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列下一篇：&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://wadehuanglearning.blogspot.com/2019/10/solid.html&#34;&gt;淺談物件導向 SOLID 原則對工程師的好處與如何影響能力 - WadeHuang的學習迷航記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wadehuanglearning.blogspot.com/2019/10/solid-why-solid.html&#34;&gt;再談 SOLID 原則，Why SOLID? - WadeHuang的學習迷航記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://teddy-chen-tw.blogspot.com/2014/04/solid.html&#34;&gt;SOLID：五則皆變 - 搞笑談軟工&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@ChunYeung/%E4%BD%BF%E4%BA%BA%E7%98%8B%E7%8B%82%E7%9A%84-solid-%E5%8E%9F%E5%89%87-%E7%9B%AE%E9%8C%84-b33fdfc983ca&#34;&gt;使人瘋狂的 SOLID 原則：目錄 - YC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@f40507777/%E6%88%91%E8%A9%B2%E5%AD%B8%E6%9C%83solid%E5%97%8E-4e73887c9156&#34;&gt;我該學會SOLID嗎? - Finn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ycc.idv.tw/introduction-object-oriented-programming_3.html&#34;&gt;物件導向武功秘笈（3）：內功篇 — 物件導向指導原則SOLID - YC Chen&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://youtu.be/e0UOuQ_lCUY&#34;&gt;Fred 聊聊 SOLID 設計原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/%E6%89%8B%E5%AF%AB%E7%AD%86%E8%A8%98/clean-code-b45a89ea8c66&#34;&gt;第 1 章 無瑕的程式碼 | Clean Code - 手寫筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.books.com.tw/products/0010786994&#34;&gt;《無瑕的程式碼：整潔的軟體設計與架構篇》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同系列文章&#34;&gt;同系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (8): 內聚、耦合</title>
      <link>https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling/</link>
      <pubDate>Sun, 13 Sep 2020 23:56:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/cgxW9yZ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;做為前後段落的分水嶺，這篇文章我將紀錄一下 &lt;strong&gt;「內聚」(Cohesion)&lt;/strong&gt; 和 &lt;strong&gt;「耦合」(Coupling)&lt;/strong&gt;，這兩者是評估一個類別或元件的重要概念。&lt;/p&gt;
&lt;p&gt;在實務上，為了提升擴展性，降低維護成本等因素，我們對於單個類別或元件，會有著 &lt;strong&gt;「低耦合」&lt;/strong&gt; 及 &lt;strong&gt;「高內聚」&lt;/strong&gt; 的期待。例如我們在 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt; 中，我們就有提到封裝的好壞相當重要，其中也包含了「提高類別內的內聚性，降低對外的耦合性」。那麼，到底什麼是內聚，什麼又是耦合呢？&lt;/p&gt;
&lt;h2 id=&#34;內聚&#34;&gt;內聚&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;「把需要的程式和資料都包裝在同一個模組內，使得該模組能夠做為一個單獨的個體執行」&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;白話一點說，就是就是把用到的東西都打包到一處，該有的自己都有了，所以即使單獨一個人也能完成工作的能力、可以自己 Carry 整場不用看豬隊友臉色的能力。越能自己單幹，越不需要依賴其他類別的時候，內聚力也就越高。&lt;/p&gt;
&lt;p&gt;也就是說：如果你的類別什麼都要依賴其他類別，像小嬰兒一樣需要呵護照顧，那內聚力就很低。反之，如果像野外求生大師，啥都靠自己，那內聚力就超高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;內聚代表的是該模組的獨立性，當這個模組可以獨力完成工作，就代表我們能夠重複使用它，且不需要擔心影響到其他模組。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;並且也基於這點，我們不用擔心變動這個模組時需要先處理其他的模組，因為這個工作所需的都包含在模組內了，這樣就可以&lt;strong&gt;單獨修改&lt;/strong&gt;該模組，減少維護成本。&lt;/p&gt;
&lt;p&gt;例如你的筆已經包含了所有寫字工具的條件，具有墨水跟筆芯等等，可以只使用筆就完成寫字這個工作。那麼我們就可以隨身帶著，在任何需要的時候重複使用它，而不用擔心我們會不會漏了什麼必要零件沒有帶出門。同時，如果我們需要換筆芯或墨水，我們也知道要更換的部份就在筆裡面，不需要去找鉛筆盒中別的地方。&lt;/p&gt;
&lt;p&gt;而我們在物件導向的世界中，是將不同的邏輯和功能，封裝成不同的物件，藉由這些物件的互動來構築我們抽象化的世界和想法。為了隱藏這些物件內部的複雜性，同時又保持物件的整體性，讓物件能真的符合我們概念中的「一個」物件，那麼&lt;strong&gt;追求高內聚就是必然的&lt;/strong&gt;。內聚，是物件的一種美德。&lt;/p&gt;
&lt;p&gt;然而，&lt;strong&gt;盲目地追求高內聚是很危險的&lt;/strong&gt;。只要你希望，當然可以寫出一個超級內聚的類別，但這代表什麼呢？&lt;/p&gt;
&lt;p&gt;為了提高內聚，把所有相關的東西都一股腦塞進同一個類別，越塞越多越塞越多，沒那麼相關的東西也硬塞在一起。從模組變成義大利麵，再從義大利麵變成大補帖，最後終於變成&lt;a href=&#34;https://en.wikipedia.org/wiki/God_object&#34;&gt;神&lt;/a&gt;。這樣實際上根本就不內聚，類別裡面就是一堆散沙，&lt;strong&gt;功能一大堆動輒數千行，改個 Bug 先看三千行程式碼&lt;/strong&gt;，維護者莫不痛哭流涕…&lt;/p&gt;
&lt;p&gt;又或是為了避免上面的狀況，限制了功能範圍。但卻又為了能獨立作業，為了不依賴別人，硬是把別的地方已經有的功能複製一份過來，用到的東西都複製複製複製進來，人人都有一份。最後遇到修改時，&lt;strong&gt;要改這又要改那，等著改的地方遍地開花&lt;/strong&gt;，維護成本暴增，維護者再度痛哭流涕…&lt;/p&gt;
&lt;p&gt;到這邊應該能瞭解到&lt;strong&gt;完全內聚是不可能也不應該的&lt;/strong&gt;，過於執著就會走火入魔。那麼怎樣的內聚算是剛剛好呢？或是說，一個良好的高內聚？這就牽涉到這段程式碼的&lt;strong&gt;意圖&lt;/strong&gt;了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;良好的內聚應該只關注在一件事情上，並適時地將不屬於自身職責的工作交給別人&lt;/strong&gt;，達到所謂「&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10203659&#34;&gt;該內聚而內聚，該耦合而耦合&lt;/a&gt;」。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所謂「只關注一件事情」、「不屬於自身職責」云云，我們在之後的 &lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;單一職責原則&lt;/a&gt; 會更進一步地說明。且先按下不表。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;為了減少重複程式碼，和降低維護的困難，不管怎樣互動都是不可避免的。那既然我們的物件多多少少都得依賴別人，就不能不提到耦合了。&lt;/p&gt;
&lt;h2 id=&#34;耦合&#34;&gt;耦合&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;「如果模組和另一個模組有關聯，那這兩者之間就耦合」&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;耦合的定義就是這麼寬廣。不管是接收另一個物件傳入的值，或者是共用同個全域變數，更何況我中有你你中有我，都是耦合。&lt;/p&gt;
&lt;p&gt;當兩者之間的關聯越緊密，越無法分離，其耦合度就越高。例如說&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;繼承&lt;/a&gt;關係就是強耦合的代表。&lt;/p&gt;
&lt;p&gt;當我們的目標放在減少重複的程式碼時，就會有多個模組共用同一段程式碼的情形發生，也會造成這些模組和這段重複使用的程式碼彼此耦合。&lt;/p&gt;
&lt;p&gt;那當我們為了其中一個使用者修改了這段程式碼，就會連帶影響其他用到的地方。變成&lt;strong&gt;改了這裡壞那裡，修了那裡壞這裡&lt;/strong&gt;的詭異情況。這也就是我們追求降低耦合的最大原因。&lt;/p&gt;
&lt;p&gt;彼此關聯就會彼此牽連，因此我們要讓彼此之間保持一個&lt;strong&gt;舒適的距離&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;注意，是舒適的距離，而不是不相往來，從這點來看，&lt;strong&gt;健康的內聚就是健康的耦合&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;內聚與耦合&#34;&gt;內聚與耦合&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;內聚是模組的獨立性，耦合則是模組的關聯性&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;「低內聚高耦合」的組合，牽一髮動全身，改個一行程式碼動輒就是大規模傷害，我們甚至不能切分模組，完全和物件的精神背道而馳，這是萬不能接受的。&lt;/p&gt;
&lt;p&gt;「高內聚低耦合」則是大家所追求的目標。為了讓每個物件各自獨立又能彼此互動，從物件導向中&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;封裝&lt;/a&gt;的角度出發，這個方向絕對是正確的。&lt;/p&gt;
&lt;p&gt;但所謂過猶不及，若是太過火變成「超高內聚無耦合」，又會變成可怕的 All in one 融合怪物或是 Ctrl C VVVVV 的複製大軍……&lt;/p&gt;
&lt;p&gt;不健康的內聚和不健康的耦合都是問題，內聚和耦合這兩者就像天秤的兩端，我們的目標就是找到那個合適的平衡點，也就是&lt;strong&gt;健康的高內聚低耦合&lt;/strong&gt;才是我們所追求的。&lt;/p&gt;
&lt;p&gt;同時也可以注意到內聚和耦合會發生的問題，例如修改時影響其他物件導致壞一整片，又或是修改時太多地方要改成本過高，總是圍繞在擴展和維護，基本上就是&lt;strong&gt;面對改變時會發生的問題&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;就像基因的優劣在於適應環境並生存下去的能力，程式碼也是如此。為了協助我們追求健康的高內聚低耦合目標，也&lt;strong&gt;為了讓我們面對改變（遭遇災難）時有個方針，因此才有了一些原則&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;就像我們前面敘述內聚時一直迴避的這些問題：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;怎樣才是適合的內聚？怎樣才是健康的耦合？&lt;/li&gt;
&lt;li&gt;如果說過高的內聚會塞太多功能或複製重複功能而變成怪物，過低的內聚則會四處拈花惹草，那我們要怎麼知道這個類別或元件的功能範圍剛剛好？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些問題的參考準則，就在於我們之後要介紹的「&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;單一職責原則&lt;/a&gt;」！&lt;/p&gt;
&lt;h2 id=&#34;小結&#34;&gt;小結&lt;/h2&gt;
&lt;p&gt;過了兩個月再度接續這個系列，一回來就是一篇碎碎念充當預告片，總之就先交代一下內聚和耦合的概念。&lt;/p&gt;
&lt;p&gt;但要真的達到健康的內聚和健康的耦合，不造神、不亂依賴、物件裡面高內聚、物件彼此低耦合，就必須要有一些原則。&lt;/p&gt;
&lt;p&gt;所以&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;下回&lt;/a&gt;開始就要進入物件導向五大原則的段落了，那麼，我們下次見！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;註：內聚跟耦合算是相當重要又基礎的觀念，我個人也還在摸索，只聞其聲不見其影。想要更了解這兩個概念的朋友，可以將參考資料的文章都看過一遍，我個人覺得頗有幫助，尤其是&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10203659&#34;&gt;實務上的高內聚與低耦合&lt;/a&gt;、&lt;a href=&#34;http://teddy-chen-tw.blogspot.com/2011/12/1.html&#34;&gt;搞笑談軟工&lt;/a&gt;兩篇，值得特別推薦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列下一篇：&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10203659&#34;&gt;實務上的高內聚與低耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://teddy-chen-tw.blogspot.com/2011/12/1.html&#34;&gt;亂談軟體設計（1）：Cohesion and Coupling - 搞笑談軟工&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10191761&#34;&gt;斷開鎖鏈! 低耦合、高內聚&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10206839&#34;&gt;如何寫高品質 function (內聚性篇)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-5_%E5%85%A7%E8%81%9Acohesion%E8%80%A6%E5%90%88coupling/&#34;&gt;Object Oriented物件導向-5:內聚(Cohesion)、耦合(Coupling) - Sian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://youtu.be/e0UOuQ_lCUY&#34;&gt;Fred 聊聊 SOLID 設計原則&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同系列文章&#34;&gt;同系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>讀《先問為什麼》</title>
      <link>https://igouist.github.io/post/2020/09/start-with-why/</link>
      <pubDate>Sun, 06 Sep 2020 10:02:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/09/start-with-why/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/mC6ySzk.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你樂於接納新事物，希望成功能持久，也相信自己的成功需要別人的幫助&lt;/p&gt;
&lt;p&gt;我向你提出一個挑戰 ——&lt;/p&gt;
&lt;p&gt;從今天起，做任何事情之前，請先問自己「為什麼」。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這本書的中文副標很好地點出了本書的重點：顛覆慣性思考的&lt;strong&gt;黃金圈理論&lt;/strong&gt;，啟動你的&lt;strong&gt;感召領導力&lt;/strong&gt;。大多篇幅用在舉例以及逐步說明何謂感召，以及黃金圈。&lt;/p&gt;
&lt;p&gt;本書的想法和一些例子，尤其是書中最重要的黃金圈理論，在作者上 TED 的影片「&lt;a href=&#34;https://www.ted.com/talks/simon_sinek_how_great_leaders_inspire_action?language=zh-tw&#34;&gt;偉大的領袖如何鼓動行為&lt;/a&gt;」都有說明，有興趣的朋友可以直接看演講影片，足夠掌握到黃金圈理論的核心。&lt;/p&gt;
&lt;iframe src=&#34;https://embed.ted.com/talks/lang/zh-tw/simon_sinek_how_great_leaders_inspire_action&#34; width=&#34;100%&#34; height=&#34;480&#34; frameborder=&#34;0&#34; scrolling=&#34;no&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;（偉大的領袖如何鼓動行為 - TED）&lt;/p&gt;
&lt;p&gt;作者認為影響人類行為的方法有兩種：&lt;strong&gt;操弄&lt;/strong&gt;以及&lt;strong&gt;感召&lt;/strong&gt;，其中操弄是指使用手段或策略去影響他人，例如說談判、利誘、情緒勒索、削價競爭等等，所謂「人有所好，以好誘之無不取；人有所懼，以懼迫之無不納」就是操弄。&lt;/p&gt;
&lt;p&gt;同時操弄也是我們日常最常接觸到的方法，可說是無所不在，並且很容易達到目標，短期見效。但如果將目光放到建立長期關係，則操弄就不一定是個好方法：它能帶來短期的利益，但並不能帶來忠誠度和信任，過度依賴操控就像在懸崖邊跳舞，一失足就難以挽回。&lt;/p&gt;
&lt;p&gt;而感召，則是用激勵人心的方式去影響他人、促使別人展開行動。為了說明這些領導者如何能做到感召他人，作者提出了黃金圈理論。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/WM8Js7d.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;從最外圈到最內圈分別為：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;做什麼&lt;/strong&gt;：負責什麼工作、提供什麼商品等等。每個人都能說得出來。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;怎麼做&lt;/strong&gt;：流程、方法、技術。知道怎麼把事情做好，比做什麼更加抽象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;為什麼&lt;/strong&gt;：目的、使命、信念。真正的核心，但很少人能清楚說明。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我們能很清楚說出我們正在做什麼，有些時候也能說得出來該怎麼做，但很少人會提及為什麼要這樣做。這是因為大多數人傾向從較為清楚的點開始，而將模糊的事往後延，所以行為模式就會是從黃金圈由外往內。從具體的行為到模糊的原因。&lt;/p&gt;
&lt;p&gt;然而，能激勵熱情的做法卻不一樣，他們是由內往外的，他們會先問為什麼。作者針對這兩種的差異，給了一組電腦公司的銷售方式做為例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我們很會做電腦&lt;/li&gt;
&lt;li&gt;我們的電腦有最美的設計，不但使用簡單，也容易上手&lt;/li&gt;
&lt;li&gt;想要買一台嗎？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這就是先從最外圈做什麼開始的訴求，但這樣實在沒有什麼吸引力。然而，大多數的企業和廣告都採用這種方式行銷，先從「我們做的商品，這項商品和其他商品的不同處」開始，然而這並不能達到感召。接著，作者提出了蘋果的溝通模式來對比：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我們做的每件事，都是為了挑戰、改變現況，因為我們相信「不同凡想」的力量&lt;/li&gt;
&lt;li&gt;我們挑戰現況的方法，就是讓我們的產品有最美的設計，而且簡單好用&lt;/li&gt;
&lt;li&gt;剛好，我們做的就是最棒的電腦&lt;/li&gt;
&lt;li&gt;想要買一台嗎？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只是調整一下訴求的順序，並說明為什麼而已，感覺就會截然不同。&lt;/p&gt;
&lt;p&gt;這之間的差別在於，所謂設計、簡單、好用，只是你的理念具體化的表現。所有公司都能夠聘請厲害的設計師和工程師，所有公司也都各有優劣之分，多數人和企業認為有形的功能和價值會是致勝關鍵，不可否認產品和策略對於優勢息息相關，然而在這些背後，你為什麼而做，你所做的是否能夠表達出你的理念，這就會是關鍵的差別。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;吸引人們的，不是你做什麼，而是你為什麼做。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用優劣得失衡量而來的顧客，終究會因為優劣得失離開；但用理念吸引來的顧客，將會和你並肩作戰。這也就是開場時，作者將操弄和感召作為對比的原因，在這裡直接延伸成忠誠度，若只用手段和策略去鞏固顧客，這樣的關係危險且無法持久。但當你的目標和理念能和顧客產生共鳴時，顧客甚至能夠包容你產品的缺點，而以你產品的優點為傲。這是只講究手段、策略、怎麼做的人難以理解的。&lt;/p&gt;
&lt;p&gt;只執著在怎麼做的人，會用差異化的方式來試圖脫穎而出，也就是說服顧客自己和其他競爭者與眾不同。然而，大多數的產品對顧客來說都是所差無幾的，例如生活用品、衛生紙、牛奶，對顧客來說牛奶就是牛奶。並且，當我們只用怎麼做和做什麼兩個著眼點去進行這件事時，很容易陷入惡性循環。例如說削價競爭，用低價當做訴求，不斷削價的結果可想而知。&lt;/p&gt;
&lt;p&gt;真正最有效的差異，就在於你為什麼而做。&lt;/p&gt;
&lt;p&gt;「一台擁有5GB容量的MP3播放器」和「（為了）放一千首歌在你的口袋裡」中間的差別是顯而易見的。&lt;/p&gt;
&lt;p&gt;當然，知道了為什麼之後，還是得知道怎麼做。總不能都說要放一千首歌在你的口袋，然後連個撥放器都造不出來吧，因此知道為什麼的人，還是需要那些知道怎麼做的人。不是說想到好棒的點子就趕快找認識的工程師朋友去咖啡廳泡茶，而是先知道為什麼的好處在於，你能夠區分出選擇有哪些。&lt;/p&gt;
&lt;p&gt;當你的信念是為了改變世界，你就不會考慮削價競爭。當你的訴求是「讓每個人躺上我們的沙發都像個國王！」你就不會考慮用抽換劣質棉花的方式來降低成本。&lt;strong&gt;先知道為什麼之後，有助於讓你的怎麼做變得清晰&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而當你的黃金圈趨向一致、平衡的時候，你的為什麼足夠清晰、具有號召力，怎麼做和做什麼都能展現出你的信念的時候，自然就能吸引到那些和你志同道合的人們，創造忠誠度和歸屬感。所以，與其要求所謂「忠誠」、「誠信」這些結果（如果還必須特地要求這些，那應該也是相當危險了），不如把自己的「為什麼」表達出來，有紀律地根據「為什麼」去貫徹「怎麼做」，讓黃金圈完善，那麼自然就能達到這些效果。&lt;/p&gt;
&lt;p&gt;就像我們在&lt;a href=&#34;https://igouist.github.io/post/2020/06/darkhorse&#34;&gt;前一篇《黑馬思維》的心得&lt;/a&gt;所說，先知道微動力之後，就能據此選擇適合的策略，所以選擇並不難，符合自己就好。如果你能先找出為什麼，那麼你該怎麼做的選擇就會縮小到符合為什麼的範圍，如此一來也就簡單多了。再拿我喜歡的卡牌遊戲舉例，當所有人的牌組都一致時，&lt;strong&gt;對於核心概念的理解程度就會呈現在策略方針的差別，進而決定最後的高度&lt;/strong&gt;。因此，想要做出明智的選擇，就先從問為什麼開始。&lt;/p&gt;
&lt;p&gt;為了表達「為什麼」與「怎麼做」之間的關係，作者提出了&lt;strong&gt;芹菜測試&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假設你去參加一個晚宴，忽然有朋友跑來告訴你，「你知道你的組織需要什麼嗎？M&amp;amp;M巧克力。不用M&amp;amp;M，根本就是有錢不去賺。」&lt;/p&gt;
&lt;p&gt;這時，另一個朋友又跑過來，說：「你知道自己該做什麼嗎？豆漿。研究顯示，現在每個人都在買豆漿。你應該賣豆漿才對。」&lt;/p&gt;
&lt;p&gt;當你站在雞尾酒桌旁邊的時候，另一位朋友又給你一個建議。「Oreo餅乾，」他說。「我們靠Oreo餅乾賺進了好幾百萬美元。你絕對要做Oreo餅乾。」&lt;/p&gt;
&lt;p&gt;這時又來了一個人，告訴你：「芹菜！你一定得做芹菜這門生意。」&lt;/p&gt;
&lt;p&gt;所有這些有成就的朋友給了你那麼多重要建議。有些人和你身處同一產業，有些人比你成功，有些人也給別人相同的建議，結果讓人受益匪淺。這時，你該怎麼辦？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;當你跑去超市把上面提到的東西一股腦都買了，在排隊付錢時，所有人看著你手上的東西，根本不知道你相信什麼。你做的事情應該體現你的目標，但你手上什麼都有。&lt;/p&gt;
&lt;p&gt;但如果在你去超市之前，先確認好自己的為什麼。假設你的目標是為了健康，那你就只會拿著豆漿跟芹菜。而從結果來說，你在超市花的時間和金錢也比較少，每個人也都能感覺得到你的理念。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你的一言一行，都要能證明你的信念。為什麼的本質就是信念。怎麼做，則是你實踐信念的行為，而做什麼則是這些行為的結果。《先問，為什麼》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作者在書中小心叮嚀不要走歪，所謂的走歪就是為什麼和怎麼做兩者漸行漸遠，手段開始不符理念，策略遠離目標的時候。由於怎麼做的操弄和策略通常是立即有效的，而為什麼的感召則是緩慢的、可能會停滯的。一旦鐵粉量飽和了、理念號召的做法陷入停滯時，多數人會不斷嘗試採取各種手段以求突破現況，這中間難免會為了立即的甜頭而走上了岔路。&lt;/p&gt;
&lt;p&gt;為了抓住所謂市場機會或是尋求突破等等，而使得「為什麼」和「怎麼做」脫鉤的時候，很可能造成原本的忠誠度下降，進而引發其他問題。長久以來就會變得危險，如同不斷追尋成長的殭屍，但&lt;a href=&#34;https://www.books.com.tw/products/0010825335&#34;&gt;世界上沒有所謂的『持續成長』&lt;/a&gt;，失去信念後盲目亂竄只是變成我們開頭舉例的那些公司的其中一員罷了。&lt;/p&gt;
&lt;p&gt;因此時刻檢驗自己的「為什麼」，自己的「怎麼做」和「做什麼」有沒有符合「為什麼」是相當重要的。&lt;/p&gt;
&lt;p&gt;換句話說，就是&lt;strong&gt;莫忘初衷&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;釐清自己的做什麼並非最困難的部分。真正難的是相信自己的直覺、堅持自己的願景、使命或信念。保持平衡與真誠才是最困難的部分。《先問，為什麼》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最後，這本書的副標和內容似乎都展現出是一本管理學書籍的感覺，例如企業、忠誠度、領導力等等。但作者也說了：每個組織或團體，都是由一個人或一小群人來的。就像我們前一篇黑馬思維的心得提過的，你要把你個人當一個品牌來經營。這些道理應用在個人的生活和行為也是相當符合的。&lt;/p&gt;
&lt;p&gt;如同作者所說的：&lt;strong&gt;我們永遠只能從我們自己開始&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最後就放一下作者書中提到的工人故事，在 &lt;a href=&#34;http://www.evanlin.com/reading-why-first/&#34;&gt;[好書分享] 先問，為什麼？&lt;/a&gt; 看到之後就蠻喜歡的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有一位哲學家到一個建築工地分別問三個正在砌築的工人說：「你在幹什麼？」&lt;/p&gt;
&lt;p&gt;第一個工人頭也不抬地說：「我在砌磚。」&lt;/p&gt;
&lt;p&gt;第二個工人抬了抬頭說：「我在砌一堵牆。」&lt;/p&gt;
&lt;p&gt;第三個工人熱情洋溢、滿懷憧憬地說：「我在建一座教堂！」&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;願各位都能找到心中的教堂，找到自己為何而戰，找到「為什麼」，共勉之。&lt;/p&gt;
&lt;h2 id=&#34;延伸閱讀及參考資料&#34;&gt;延伸閱讀及參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.evanlin.com/reading-why-first/&#34;&gt;[好書分享] 先問，為什麼？顛覆慣性思考的黃金圈理論，啟動你的感召領導力 - KKDAI.GITHUB.IO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.guccidgi.com/2020/02/start-with-why/&#34;&gt;先問為什麼 如何徹底改變了我所有的行為? - 追日Gucci&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.inside.com.tw/article/13179-start-with-why&#34;&gt;【硬塞書摘】感召領導力：你要得到更多客戶，還是創造鐵粉？ - 張柏崧&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;遺珠之憾&#34;&gt;遺珠之憾&lt;/h2&gt;
&lt;p&gt;作者在書中將黃金圈的三層，和大腦的結構對應起來，並將為什麼類比為我們的緣腦，掌控情感、信任、決策等等，同時將做什麼類比為我們的新皮質，掌控理性和分析。並且認為我們常有無法理性分析的直覺，並且常常證明是對的，作者將其和為什麼的信念連結在一起。對直覺和理性之間的互動有興趣的朋友，可以試著讀讀看&lt;a href=&#34;https://www.books.com.tw/products/0010780181&#34;&gt;《快思慢想》&lt;/a&gt;，或是看過網路上大大整理的&lt;a href=&#34;https://www.books.com.tw/products/0010780181&#34;&gt;系統一和系統二關係圖&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另外，書中還有一些段落並沒有節錄出來，例如用黃金圈和市場溝通，如何引爆趨勢（可以參見&lt;a href=&#34;https://wiki.mbalib.com/zh-tw/%E7%BD%97%E6%9D%B0%E6%96%AF%E7%9A%84%E5%88%9B%E6%96%B0%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B&#34;&gt;創新擴散理論&lt;/a&gt;和&lt;a href=&#34;https://wiki.mbalib.com/zh-tw/%E7%97%85%E6%AF%92%E5%BC%8F%E8%90%A5%E9%94%80&#34;&gt;病毒行銷&lt;/a&gt;），以及關於「為什麼」的一些不錯的例子（西南航空、沃爾瑪、福特）等等。如果有興趣的話，還是推薦可以入手一本來看看，這邊就附上 &lt;a href=&#34;https://www.books.com.tw/products/0010926506&#34;&gt;博客來&lt;/a&gt; 和 &lt;a href=&#34;https://www.kobo.com/tw/zh/ebook/1iky1ahewzexetqpe6mraw&#34;&gt;Kobo&lt;/a&gt; 連結。有興趣的朋友可以考慮入手看看呦！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C#: 時區轉換、民國西元、國曆農曆、中文月份週期</title>
      <link>https://igouist.github.io/post/2020/08/csharp-timezone/</link>
      <pubDate>Sun, 30 Aug 2020 11:58:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/08/csharp-timezone/</guid>
      <description>&lt;p&gt;聊到將時間從 UTC 轉到台灣時間，居然還是聽到朋友表示使用 +8 小時的做法，驚為天人。這種做法可能會造成後續的問題，例如時區並不會跟著變動，或是遇到日光節約等特殊狀況就容易出事。和西元民國轉換直接 -1911 一樣不穩定。&lt;/p&gt;
&lt;p&gt;這篇就用來記錄一下之前看過比較優雅的時區轉換方式，順便將先前存著的時間處理相關資料整理一下，方便之後需要時可以馬上回來查詢。&lt;/p&gt;
&lt;h2 id=&#34;timezoneinfo-時區資訊&#34;&gt;TimeZoneInfo: 時區資訊&lt;/h2&gt;
&lt;p&gt;轉換方式主要參考自 &lt;a href=&#34;https://dotblogs.com.tw/supershowwei/2016/10/17/141620&#34;&gt;[食譜好菜] DateTime 具有文化特性的格式化及時區的轉換&lt;/a&gt; 及 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/standard/datetime/converting-between-time-zones&#34;&gt;在各時區間轉換時間&lt;/a&gt;，感謝前人的指引。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;關於文化特性，也可以參考本站的 &lt;a href=&#34;https://igouist.github.io/post/2021/10/csharp-datatime-tostring-cultureinfo&#34;&gt;菜雞抓蟲: DateTime.ToString() 之我們不一樣 &amp;amp; CultureInfo 文化特性小筆記&lt;/a&gt; 呦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 假設現在是要從標準時區 +00:00 轉換到台灣時區，故這邊使用 UtcNow 先取標準世界協調時間&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; nowDateTime = DateTime.UtcNow;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;nowDateTime.ToString(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;yyyy/MM/dd H:mm:ss zzz&amp;#34;&lt;/span&gt;).Dump();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 2020/08/30 15:56:05 +00:00&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ==================================================&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 傳統的 直接對時間做計算的方式…&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; addedDateTime = nowDateTime.AddHours(&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;addedDateTime.ToString(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;yyyy/MM/dd H:mm:ss zzz&amp;#34;&lt;/span&gt;).Dump();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 2020/08/30 23:56:05 +00:00&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 可以看到儘管時間變動了，時區仍然還在 +00:00&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ==================================================&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 使用 TimeZoneInfo 先取得台北時區&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; timeZone = TimeZoneInfo.FindSystemTimeZoneById(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Taipei Standard Time&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 再使用 TimeZoneInfo 來變更時間&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; convertedDateTime = TimeZoneInfo.ConvertTime(nowDateTime, timeZone);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;convertedDateTime.ToString(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;yyyy/MM/dd H:mm:ss zzz&amp;#34;&lt;/span&gt;).Dump();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 2020/08/30 23:56:05 +08:00&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 可以看到除了時間變更以外，時區也切換到 +08:00 了！&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面取得台北時區的步驟，可以參照 &lt;a href=&#34;https://docs.microsoft.com/en-us/previous-versions/windows/embedded/gg154758(v=winembedded.80)&#34;&gt;Time Zone IDs&lt;/a&gt; 來查詢想要的時區。這樣的時區切換方式，不僅副作用少，不會因為時區沒轉雷到後續接手的人，也省卻了擔心日光節約等等問題，這種事就交給微軟去煩惱吧！&lt;/p&gt;
&lt;p&gt;另外這邊也逐步放一些時區處理相關的參考資料：&lt;/p&gt;
&lt;h2 id=&#34;taiwancalendar-西元年轉民國年-br-taiwanlunisolarcalendar-國曆轉農曆&#34;&gt;TaiwanCalendar: 西元年轉民國年 &lt;br/&gt; TaiwanLunisolarCalendar: 國曆轉農曆&lt;/h2&gt;
&lt;p&gt;可以參考這篇 &lt;a href=&#34;https://kevintsengtw.blogspot.com/2014/06/c.html&#34;&gt;基本題 - C# 西元年轉換取得民國年格式字串 - mrkt 的程式學習筆記&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;內文示範了使用 &lt;code&gt;System.Globalization.TaiwanCalendar&lt;/code&gt; 和 &lt;code&gt;System.Globalization.TaiwanLunisolarCalendar&lt;/code&gt; 來進行安全轉換的作法。&lt;/p&gt;
&lt;p&gt;基本上來說就是指定文化特性中的時間格式（曆法）為農曆，至少依靠微軟爸爸，比自己加減 1911 來得安全多了囧。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; time = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; DateTime(&lt;span style=&#34;color:#ae81ff&#34;&gt;2021&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 直接從 TaiwanCalendar 取民國年，自組字串時常用&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; taiwanCalendar = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; TaiwanCalendar();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;taiwanCalendar.GetYear(time).Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// 110&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 將文化特性的曆法改成民國年&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; info = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; CultureInfo(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;zh-TW&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;info.DateTimeFormat.Calendar = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; TaiwanCalendar();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 西元年轉民國年(字串)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;time.ToString(info).Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// 110/12/1 00:00:00&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 民國年(字串)轉西元年&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; timeString = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;110/12/1&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;DateTime.Parse(timeString, info).Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// 2021/12/01 00:00:00&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;datetimeformatinfo-月週時間的格式&#34;&gt;DateTimeFormatInfo: 月、週、時間的格式&lt;/h2&gt;
&lt;p&gt;不用再傻傻地手刻陣列「星期一」、「星期二」、「星期三」…之類的了，只要用 &lt;code&gt;DateTimeFormatInfo.CurrentInfo&lt;/code&gt; 的就好啦：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; MonthCh = DateTimeFormatInfo.CurrentInfo.MonthNames;   &lt;span style=&#34;color:#75715e&#34;&gt;// 中文月份名稱列表&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; MonthEn = DateTimeFormatInfo.InvariantInfo.MonthNames; &lt;span style=&#34;color:#75715e&#34;&gt;// 英文月份名稱列表&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/se7XLZy.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;除了月份以外，&lt;code&gt;DateTimeFormatInfo.CurrentInfo&lt;/code&gt; 也包含了當地的其他欄位與格式。&lt;/p&gt;
&lt;p&gt;例如 &lt;code&gt;AbbreviatedDayNames&lt;/code&gt; 能拿到 週一、週二、週三…；&lt;code&gt;DayNames&lt;/code&gt; 則會拿到 星期一、星期二、星期三…&lt;/p&gt;
&lt;p&gt;時間格式的話，&lt;code&gt;FullDateTimePattern&lt;/code&gt; 就會拿到 &lt;code&gt;yyyy&#39;年&#39;M&#39;月&#39;d&#39;日&#39; tt hh:mm:ss&lt;/code&gt; 等等&lt;/p&gt;
&lt;p&gt;內容還有許多欄位，有興趣的可以用 LinqPad 來 Dump 看看，或是直接翻閱 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/api/system.globalization.datetimeformatinfo?view=netcore-3.1&#34;&gt;DateTimeFormatInfo&lt;/a&gt; 囉！&lt;/p&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kevintsengtw.blogspot.com/2014/06/c.html&#34;&gt;基本題 - C# 西元年轉換取得民國年格式字串 - mrkt 的程式學習筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/supershowwei/2016/10/17/141620&#34;&gt;[食譜好菜] DateTime 具有文化特性的格式化及時區的轉換&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/supershowwei/2019/04/15/095324&#34;&gt;[桌邊服務] DateTime 本身有沒有包含時區的資訊？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/ricochen/2016/02/12/114642&#34;&gt;[C#]UTC時區轉換 - RiCo技術農場&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.miniasp.com/post/2010/04/30/Concept-DateTime-TimeZone&#34;&gt;釐清觀念：.NET 日期結構(DateTime) 與 時區轉換&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.darkthread.net/blog/compare-datetime-with-diff-timezone&#34;&gt;笨問題 - UTC 與本地時區 DateTime 比較&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/standard/base-types/custom-date-and-time-format-strings?redirectedfrom=MSDN&#34;&gt;自訂日期與時間格式字串 - Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/standard/datetime/converting-between-time-zones&#34;&gt;在各時區間轉換時間 - Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://siyuantw.blogspot.com/2015/07/c.html&#34;&gt;Siyuan的程式開發筆記: C#民國年西元年轉換 (siyuantw.blogspot.com)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Powershell 美化作戰 —— 字型、執行原則和 oh-my-posh</title>
      <link>https://igouist.github.io/post/2020/08/powershell-beauty/</link>
      <pubDate>Sat, 15 Aug 2020 18:00:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/08/powershell-beauty/</guid>
      <description>&lt;p&gt;最近在兩天內經歷了記憶體死去、系統毀損、機殼碎裂等等，終於電腦重灌。一堆設定都要重弄，正好也是個機會，這篇順手記一下常用好幫手 Powershell 的美化步驟。&lt;/p&gt;
&lt;p&gt;先放一張施工後的圖鎮樓：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/417skJs.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以在開始圖示上用右鍵打開選單，之後點選 Powershell；或是 Win + X 打開選單，然後按 I 或 A （後者會以系統管理員身分開啟）就能開啟了。&lt;/p&gt;
&lt;p&gt;如果選單打開還是 CMD 而不是 Powershell 的，可以先去切換成 Powershell，真的是比較好用啦（&lt;a href=&#34;https://www.microsoft.com/zh-tw/p/windows-terminal/9n0dx20hk701?activetab=pivot:overviewtab&#34;&gt;Windows Terminal&lt;/a&gt; 笑而不語）&lt;/p&gt;
&lt;p&gt;剛打開的畫面是這樣的：
&lt;img src=&#34;https://i.imgur.com/JE6BTSU.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;抱歉，光細明體我就不太行了。所以接下來就從字型這些內建設定開始！&lt;/p&gt;
&lt;h2 id=&#34;基本設定&#34;&gt;基本設定&lt;/h2&gt;
&lt;p&gt;在上方的標題列按下右鍵，選擇內容&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/MkWyIv7.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;首先就讓我們修改&lt;strong&gt;字型&lt;/strong&gt;，我這邊還是採用習慣的 &lt;a href=&#34;https://github.com/be5invis/Sarasa-Gothic&#34;&gt;更紗黑體&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另外還有一些推薦的字體，可以參閱前陣子整理的 &lt;a href=&#34;https://igouist.github.io/post/2020/03/visualstudio&#34;&gt;Visual studio 環境設定 —— 字型、套件、快捷鍵&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;補充：還有擴充了 &lt;a href=&#34;https://www.nerdfonts.com/cheat-sheet&#34;&gt;Nerd Fonts&lt;/a&gt; 的等距更紗黑體：&lt;a href=&#34;https://github.com/jonz94/Sarasa-Gothic-Nerd-Fonts&#34;&gt;Sarasa-Gothic-Nerd-Fonts&lt;/a&gt; 可以選擇，Nerd Fonts 能提供許多精美的 icon 讓我們後續改主題的時候大大加分！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/93httvP.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;除了字型以外，我個人還推薦可以修改一個設定，保證質感 UPUP，那就是&lt;strong&gt;透明度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/OGR98I8.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我個人習慣採用 80~85% 左右的透明度，搭配黑色背景。在桌面使用的時候看起來就像這樣：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/XBFVEmU.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以拉回去和一開始的預設狀況做比較，透明感＝質感。&lt;/p&gt;
&lt;p&gt;另外，背景透明還有意想不到的好處，那就是——&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/4Yh5SvJ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;打指令偷看可以不用切換視窗！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基於以上兩點，推薦可以調整透明度，找個適合自己的區間。但要注意，如果太透明的話會讓字跟背景糊在一起，很容易眼花，自己斟酌一下。&lt;/p&gt;
&lt;p&gt;以上就做完了基本設定，沒意外要做兩次（一般身分和系統管理員）&lt;/p&gt;
&lt;h2 id=&#34;安裝-posh-git&#34;&gt;安裝 posh-git&lt;/h2&gt;
&lt;p&gt;然而我們並不打算在此停止！因緣際會之下，我拜讀了這篇 &lt;a href=&#34;https://blog.poychang.net/setting-powershell-theme-with-oh-my-posh/&#34;&gt;使用 oh-my-posh 美化 PowerShell 樣式&lt;/a&gt;，頓時驚為天人，跟預設的（請自己再拉回去比對第一張圖）實在是相當有差距，於是當時就直接安裝下來了。&lt;/p&gt;
&lt;p&gt;畢竟這是第二次安裝了，接下來的區段就記錄一下安裝 &lt;a href=&#34;https://github.com/JanDeDobbeleer/oh-my-posh&#34;&gt;oh-my-posh&lt;/a&gt; 主題的流程。&lt;strong&gt;oh-my-posh&lt;/strong&gt; 是受到 Linux 上 &lt;a href=&#34;https://github.com/ohmyzsh/ohmyzsh&#34;&gt;oh-my-zsh&lt;/a&gt; 的&lt;strong&gt;啟發&lt;/strong&gt;誕生的，總之就是個挺讚讚的主題載入工具。&lt;/p&gt;
&lt;p&gt;而且安裝相當方便，只需要從 Microsoft Store 或直接打 &lt;code&gt;Install-Module&lt;/code&gt; 指令，就能從 &lt;a href=&#34;https://www.powershellgallery.com/&#34;&gt;PowerShell Gallery&lt;/a&gt; 把模組安裝下來囉！&lt;/p&gt;
&lt;p&gt;在安裝 oh-my-posh 之前，由於顯示的內容包含 Git ，因此我們還要先下載另一個套件 &lt;code&gt;posh-git&lt;/code&gt;。讓我們用&lt;strong&gt;系統管理員&lt;/strong&gt;身份開啟 Powershell，並輸入以下指令來進行安裝：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Install-Module posh-git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;到這一步，會有幾種狀況：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提示安裝 NuGet：安裝就行了&lt;/li&gt;
&lt;li&gt;提示不安全儲存庫：安啦，選是就對了&lt;/li&gt;
&lt;li&gt;跳出錯誤，顯示「因為這個系統上已停用指令碼執行」云云，則接著看下一段落&lt;/li&gt;
&lt;li&gt;什麼事都沒發生，很順利地裝好了，請跳過下一段落&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;執行原則&#34;&gt;執行原則&lt;/h2&gt;
&lt;p&gt;如果跳出「因為這個系統上已停用指令碼執行…」的情況，代表遇到&lt;strong&gt;執行原則&lt;/strong&gt;的部份。因為安全性考量，預設是不能執行 Powershell 腳本的，連帶也不能使用 Install-Module 這類方法。&lt;/p&gt;
&lt;p&gt;關於執行原則，可以參閱這篇 &lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10028377&#34;&gt;Windows PowerShell 基本操作 - 執行 Windows PowerShell 腳本&lt;/a&gt; 的說明。該系列也挺實用的，值得一看，這邊我們就節錄一段來說明執行原則的種類：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Restricted&lt;/strong&gt; ：&lt;strong&gt;關閉腳本檔的執行功能&lt;/strong&gt;，這是&lt;strong&gt;預設&lt;/strong&gt;的設定值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AllSigned&lt;/strong&gt; ：只允許執行&lt;strong&gt;受信任發行者&lt;/strong&gt;簽署過的腳本檔。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RemoteSigned&lt;/strong&gt; ：在&lt;strong&gt;本機電腦所撰寫的腳本檔，不需要簽署就可執行&lt;/strong&gt;；但是從網際網路（例如：email、MSN Messenger）下載的腳本檔就必須經過受信任發行者的簽署才能執行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Unrestricted&lt;/strong&gt; ：&lt;strong&gt;任何腳本檔皆可被執行&lt;/strong&gt;，但是於執行網際網路下載的腳本檔時，會先出現警告的提示視窗。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果要確認目前的執行原則，可以使用 &lt;code&gt;Get-ExecutionPolicy&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;這個分類也是為了保護使用者，不要亂執行一些來路不行了奇怪腳本，整個電腦打包起來送人。不過我們身為 &lt;del&gt;白目&lt;/del&gt; 工程師，難免會有要裝套件和自己寫腳本的時候，這邊就直接調整為 Unrestricted 全面開啟吧！&lt;/p&gt;
&lt;p&gt;調整執行原則的語法如下（必須在系統管理員身分時才有效果呦）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Set-ExecutionPolicy Unrestricted
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;調整完就可以繼續下載囉！&lt;/p&gt;
&lt;p&gt;像我重灌的狀況，提示會如下圖，如果已經安裝過 Nuget 提供者，提示應該會更少。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/UoGkW7o.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;安裝-oh-my-posh&#34;&gt;安裝 oh-my-posh&lt;/h2&gt;
&lt;p&gt;接著讓我們安裝 oh-my-posh：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Install-Module oh-my-posh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/LQuE2hD.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;安裝完畢後就可以來試試看囉！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;更新：Oh-my-posh 也可以從 Microsoft 搜尋並安裝囉！&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/3WoVsvL.jpg&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;設定主題&#34;&gt;設定主題&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;更新：由於 Oh-my-posh 設定主題的語法已經改變，因此移除 2020 時的內容，改為 2023 重灌電腦時找到的指令。&lt;/p&gt;
&lt;p&gt;因為 Oh-my-posh 還蠻頻繁更新的，建議後續的操作可以開著 &lt;a href=&#34;https://ohmyposh.dev/docs/installation/customize&#34;&gt;Oh My Posh&lt;/a&gt; 的官方文檔來排查一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;要更改主題的話，我們會需要使用 &lt;code&gt;oh-my-posh init pwsh&lt;/code&gt; 這個指令，並且將該主題的 Json 檔案傳遞給 &lt;code&gt;--config&lt;/code&gt;&lt;/strong&gt;，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;oh-my-posh init pwsh --config &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$env&lt;span style=&#34;color:#e6db74&#34;&gt;:POSH_THEMES_PATH/powerlevel10k_rainbow.omp.json&amp;#34;&lt;/span&gt; | Invoke-Expression
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我們丟了一個 powerlevel10k_rainbow 這個主題的 Json 檔案路徑給 oh-my-posh，然後呼叫 &lt;code&gt;Invoke-Expression&lt;/code&gt; 執行它，這時候主題就會變啦～&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;補充：這邊用到一組環境變數 &lt;code&gt;$env:POSH_THEMES_PATH&lt;/code&gt; 實際上是一個資料夾路徑，Oh-my-posh 安裝的主題都會放在這個資料夾裡：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/lWBHJc3.jpg&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果你有自己下載的主題，可以也丟到 &lt;code&gt;POSH_THEMES_PATH&lt;/code&gt; 的位置，或是直接更改 &lt;code&gt;--config&lt;/code&gt; 的路徑就可以了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每個主題的樣式都不大一樣，可以翻一下 Oh-my-posh 的 &lt;a href=&#34;https://ohmyposh.dev/docs/themes&#34;&gt;Themes&lt;/a&gt; 頁面挑個喜歡的。&lt;/p&gt;
&lt;h2 id=&#34;撰寫腳本&#34;&gt;撰寫腳本&lt;/h2&gt;
&lt;p&gt;聰明的你一定發現了，每次重開都要重輸入一次 &lt;code&gt;init&lt;/code&gt; 實在是很麻煩。因此我們接著要設定讓它能一打開就載入主題。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;當 Powershell 開啟時，預設會去讀取使用者的設定檔（Profile）&lt;/strong&gt;，我們就是要把這些指定加到設定檔裡，讓 Powershell 一打開就能美美的。&lt;/p&gt;
&lt;p&gt;在 Powershell 裡輸入 &lt;code&gt;$PROFILE&lt;/code&gt; 就能取得當前的設定檔位置，通常來說會在 &lt;code&gt;我的文件\WindowsPowerShell&lt;/code&gt; 底下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/kRKV112.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;補充：Powershell 啟動時會依序檢查四個位置來載入設定檔，分別為&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有使用者及所有 Shell: &lt;code&gt;$PSHOME\profile.ps1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;所有使用者的 Powershell: &lt;code&gt;$PSHOME\Microsoft.PowerShell_profile.ps1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;目前登入者的所有 Shell: &lt;code&gt;$Home\My Documents\WindowsPowerShell\profile.ps1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;目前使用者的 Powershell: &lt;code&gt;$Home\My Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中的變數&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$PSHOME&lt;/code&gt; 是指 Powershell 的安裝目錄，通常在 system32 的 WindowsPowerShell 底下&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$Home&lt;/code&gt; 則是使用者的主目錄，也就是大家熟悉的 users/{你的名稱}&lt;/li&gt;
&lt;li&gt;而前面提到的 &lt;code&gt;$PROFILE&lt;/code&gt; 就是指「目前使用者的 Powershell」這組&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;對設定檔有興趣的朋友可以參照保哥的文章及官方文檔：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.miniasp.com/post/2013/01/02/How-to-auto-load-ps1-script-using-Windows-PowerShell-Profiles&#34;&gt;如何在 Powershell 開啟時自動引入常用的 ps1 指令檔腳本 | The Will Will Web&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/powershell/module/microsoft.powershell.core/about/about_profiles?view=powershell-7.2&#34;&gt;關於設定檔 - PowerShell | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;接著我們就前往此處去修改 Powershell 的腳本，如果發現並沒有這個檔案，那還請自己建立一個，檔名和路徑請和 &lt;code&gt;$PROFILE&lt;/code&gt; 一致，像我就取 &lt;code&gt;Microsoft.PowerShell_profile.ps1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/eJ8A5iY.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;之後開啟檔案，貼上我們引入套件和設定主題的指令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ps1&#34; data-lang=&#34;ps1&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;oh-my-posh init pwsh --config &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$env:POSH_THEMES_PATH&lt;span style=&#34;color:#e6db74&#34;&gt;/powerlevel10k_rainbow.omp.json&amp;#34;&lt;/span&gt; | Invoke-Expression
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;再次補充：oh-my-posh 改版之後一些語法有改變，如果有在 &lt;code&gt;Set-Theme&lt;/code&gt; 這步的時候遇到「無法辨識…」問題的朋友，可以嘗試改成用 &lt;code&gt;Set-PoshPrompt -Theme Paradox&lt;/code&gt; 試試看。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接著讓我們重開 Powershell&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/1kYjQSO.jpg&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看見它已經順利載入主題囉！&lt;/p&gt;
&lt;p&gt;因為我覺得切主題前跑那些 Powershell 提示之類的有點醜，所以我會回去 Profile 補一行 Clear：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ps1&#34; data-lang=&#34;ps1&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;oh-my-posh init pwsh --config &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$env:POSH_THEMES_PATH&lt;span style=&#34;color:#e6db74&#34;&gt;/powerlevel10k_rainbow.omp.json&amp;#34;&lt;/span&gt; | Invoke-Expression
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;clear
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;也可以在這裡寫一些 function 來使用，像我個人之前做 &lt;a href=&#34;https://igouist.github.io/post/2020/03/bandon-1-selenium&#34;&gt;我要訂便當&lt;/a&gt; 因為懶得每次都 cd 到腳本所在的位置還要 Pyhton 執行，所以就直接包成 &lt;code&gt;Get-Bandon&lt;/code&gt; 的方法直接叫，真的舒服，推薦嘗試&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果有想要自己試試新增主題，或是想像我一樣做小修改的，可以到 &lt;code&gt;$env:POSH_THEMES_PATH&lt;/code&gt; 這個路徑的資料夾，找到 &lt;code&gt;.omp.json&lt;/code&gt; 檔案來動手&lt;/p&gt;
&lt;p&gt;例如說把 &lt;code&gt;powerlevel10k_rainbow.omp.json&lt;/code&gt; 開啟後，就可以看見組出那一串資訊的過程，也就可以隨意更改囉。我就特愛把一些 icon 都改成 &lt;code&gt;°д°&lt;/code&gt;，感覺活潑多了（？）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;補充：該路徑會根據安裝 &lt;code&gt;oh-my-posh&lt;/code&gt; 的位置而變動，基本上開 Powershell 直接從環境變數的路徑下去找比較快。真的找不到的話也可以下載別人的主題改一改，再修改 `&amp;ndash;config`` 的路徑指到自己改好的 json 就好囉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;順便提一下，載入使用者設定對用到 Powershell 的地方都有效喲！&lt;/p&gt;
&lt;p&gt;例如 Visual Studio Code 的 Powershell&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/fqtRmwR.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;或是 Visual Studio 的開發人員用 Powershell&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ulEehB0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;都是會吃到個人使用者的設定的。&lt;/p&gt;
&lt;p&gt;那麼今天就到這裡，最後再把完成品跟預設狀況比對一次吧～&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/JE6BTSU.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/99DaSVP.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;2023 回來更新文章，順便附個現況：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/JOVI7hg.jpg&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;同場加映：&lt;/p&gt;
&lt;p&gt;跟朋友志得意滿地說明了 Powershell 美化作戰後，對方只說了淡淡的一句&lt;/p&gt;
&lt;p&gt;「哦，我都直接 &lt;a href=&#34;https://cmder.app/&#34;&gt;Cmder&lt;/a&gt;」&lt;/p&gt;
&lt;p&gt;那又是另一個故事了……&lt;/p&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.poychang.net/setting-powershell-theme-with-oh-my-posh/&#34;&gt;使用 oh-my-posh 美化 PowerShell 樣式 - POY CHANG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ppundsh.github.io/posts/ad6e/&#34;&gt;PowerShell 美化：oh my posh - Flymia 凡事用心之事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pcion123.github.io/2020/03/08/powershell-improve/&#34;&gt;美化PowerShell - oh-my-posh - Pcion&amp;rsquo;s note&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10028377&#34;&gt;Windows PowerShell 基本操作 - 執行 Windows PowerShell 腳本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://officeguide.cc/powershell-set-execution-policy-remote-signed/&#34;&gt;PowerShell 更改執行原則，解決無法執行 ps1 指令稿問題&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>C#: 字串插值 (String interpolation) 的格式化</title>
      <link>https://igouist.github.io/post/2020/08/csharp-string-interpolation/</link>
      <pubDate>Sun, 09 Aug 2020 20:35:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/08/csharp-string-interpolation/</guid>
      <description>&lt;p&gt;自從 C# 有了 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/csharp/language-reference/tokens/interpolated&#34;&gt;字串插值&lt;/a&gt; 這東西之後，我就一直是愛用者。畢竟比起 &lt;code&gt;string.format&lt;/code&gt; 這東西可是看起來優雅多了。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;哈囉，{userName} 您的點數將於 {cutoffTime} 到期。&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;簡潔又明瞭，一眼就能理解字串內容。實在是挺方便，後來發現這東西還有一些延伸用法，這邊就稍加紀錄一下：&lt;/p&gt;
&lt;p&gt;字串插值中能夠做&lt;strong&gt;簡易計算&lt;/strong&gt;，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;您輸入的數值為：{a}、{b}。他們相加為：{a + b}&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;同時，在字串插值時可以針對內容作格式化，只需要用 &lt;code&gt;:&lt;/code&gt; 來區隔，妥善運用可以省下一堆 &lt;code&gt;ToString()&lt;/code&gt; 的空間。&lt;/p&gt;
&lt;p&gt;例如當我們要將&lt;strong&gt;時間&lt;/strong&gt;格式化的時候，就可以：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; date = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; DateTime(&lt;span style=&#34;color:#ae81ff&#34;&gt;2020&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;您的商品已於 {date:yyyy/MM/dd} 抵達。&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 您的商品已於 2020/08/09 抵達。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外，&lt;strong&gt;數值&lt;/strong&gt;當然也可以格式化，不過數值的應用比較複雜，主要是用來定下小數點、百分比等符號的位置。
可以參見 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/standard/base-types/custom-numeric-format-strings&#34;&gt;自訂數值格式字串 - Microsoft Docs&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; cost = &lt;span style=&#34;color:#ae81ff&#34;&gt;2100&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message1 = &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;您的商品一共是 {cost:#,###} 元&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 用 # 可以替數字預留位置&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 您的商品一共是 2,100 元&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message2 = &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;您的商品一共是 {cost:#,###.00} 元&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 也可以用 0 來預留位置，若該數字有值就會顯示該數字，沒有就會自動補 0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 您的商品一共是 2,100.00 元&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而格式化也支援&lt;strong&gt;列舉&lt;/strong&gt;，在同時顯示列舉的意義和值的時候會很有幫助：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// public enum Color { Red = 1, Blue = 2, Green = 3 };&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; color = Color.Blue;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;編號 {color:D} 是 {color:G}&amp;#34;&lt;/span&gt;.Dump();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 編號 2 是 Blue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;承上部分，由於 &lt;code&gt;:&lt;/code&gt; 在字串插值裡已經有特殊意義了，因此想在字串插值中使用&lt;strong&gt;三元運算子&lt;/strong&gt;，必須先用 &lt;code&gt;( )&lt;/code&gt; 括起來，如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;您的包裹 {(isArrival ? &amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;已&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; : &amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;尚未&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;)} 抵達門市&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;對字串插值有興趣的朋友，也可用&lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/csharp/tutorials/exploration/interpolated-strings&#34;&gt;微軟官方的教學課程&lt;/a&gt;來試試呦。&lt;/p&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/eyelash/2019/07/06/205834&#34;&gt;【C# 6.0】字串插補（更容易插入變數） - EY＊研究院&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/csharp/language-reference/tokens/interpolated&#34;&gt;字串插值 - Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/csharp/tutorials/string-interpolation&#34;&gt;C# 中的字串插補 - Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/standard/base-types/custom-numeric-format-strings&#34;&gt;自訂數值格式字串 - Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/standard/base-types/enumeration-format-strings&#34;&gt;列舉格式字串 - Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/standard/base-types/formatting-types&#34;&gt;.NET 中的格式類型 - Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>C#: 使用 System.Environment 取得環境資訊、特殊資料夾路徑</title>
      <link>https://igouist.github.io/post/2020/08/system-environment/</link>
      <pubDate>Sun, 02 Aug 2020 13:31:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/08/system-environment/</guid>
      <description>&lt;p&gt;有時候我們會需要取得一些系統資訊，例如說取得設備和當前使用者等資料來寫 Log，或是取得特殊資料夾路徑、讀取環境變數等等。這些時候就可以使用 &lt;code&gt;System.Environment&lt;/code&gt; ，這邊就稍微紀錄一下用法。&lt;/p&gt;
&lt;p&gt;先列出幾個常用的&lt;strong&gt;環境資訊&lt;/strong&gt;，詳細可查詢的內容可以到 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/api/system.environment?view=netcore-3.1&#34;&gt;Environment Class&lt;/a&gt; 查詢：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/8L67T46.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;資料夾路徑&lt;/strong&gt;則需要用 &lt;code&gt;Environment.GetFolderPath&lt;/code&gt; 搭配 &lt;code&gt;Environment.SpecialFolder&lt;/code&gt; 列舉使用，該列舉包含資料夾可以到 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/api/system.environment.specialfolder?view=netcore-3.1&#34;&gt;Environment.SpecialFolder Enum&lt;/a&gt; 查詢。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/aOQ30KB.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;除此之外還有一些實用的方法，例如用 &lt;code&gt;GetEnvironmentVariable&lt;/code&gt; 取得&lt;strong&gt;環境變數&lt;/strong&gt;，如此就可以將部分資訊交由環境變數來決定：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/pRj4yEA.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;而最常用的應該就是 NewLine 了，畢竟不同環境的&lt;strong&gt;換行符號&lt;/strong&gt;可能會不同，養成用 NewLine 的習慣總是好的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/jvjNnJK.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://jjnnykimo.pixnet.net/blog/post/21585496&#34;&gt;C# 取得系統特殊目錄及環境變數 - 狼翔天地&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://apmtechtony.blogspot.com/2017/09/c-environmentspecialfolder.html&#34;&gt;C# 取得系統特殊目錄及環境變數 Environment.SpecialFolder 與 Environment.GetEnvironmentVariable 差別&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>C#: 程式碼風格備忘</title>
      <link>https://igouist.github.io/post/2020/07/code-style/</link>
      <pubDate>Sat, 25 Jul 2020 00:16:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/code-style/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;前言：本篇是整理公司規範和網路文章後，方便我自己在各個場所也能回來查閱使用的，故仍會不定時修改（畢竟我這人挺三心二意的）。另外本篇有重新調整過行距，發現有點跑版的朋友可以先 Ctrl+F5 一下，感謝閱讀。&lt;/p&gt;
&lt;p&gt;如果你想知道的是如何寫出更優雅、更乾淨、品質更高的程式碼，那並不是該看這篇我個人的備忘錄，我會建議可以閱讀&lt;a href=&#34;https://www.tenlong.com.tw/products/9789862017050?list_name=e-106&#34;&gt;《無暇的程式碼》&lt;/a&gt;。或是可以參考這幾篇，我覺得都寫得很好：&lt;a href=&#34;https://ithelp.ithome.com.tw/users/20107637/ironman/1927&#34;&gt;可不可以不要寫糙 code&lt;/a&gt;、&lt;a href=&#34;https://ithelp.ithome.com.tw/users/20107637/ironman/1927&#34;&gt;Clean Code 無瑕的程式碼閱讀筆記&lt;/a&gt;、&lt;a href=&#34;https://ithelp.ithome.com.tw/users/20112160/ironman/1988&#34;&gt;易讀程式之美學&lt;/a&gt;，共勉之。&lt;/p&gt;
&lt;p&gt;如果你是正巧路過並且也寫 C#，希望這篇能讓你做為參考。但請記得，程式碼風格沒有絕對，最終還是回歸到團隊能否接受和將來的可維護性去考慮，畢竟教條是死的，人是活的。了解這樣做背後的原因，以及為自己寫的程式碼負責，這些都比對著隻字片語斤斤計較更加重要。&lt;/p&gt;
&lt;p&gt;Nothing is true, everything is permitted. —— Assassin&amp;rsquo;s creed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;命名原則&#34;&gt;命名原則&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;想像下一個接手你程式碼的人是個暴力傾向的重度精神病患者&lt;/p&gt;
&lt;p&gt;而且他知道你住在哪。　　—— 《無瑕的程式碼》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;strong&gt;有意義的命名&lt;/strong&gt;，請重視描述性。除了迴圈計數器例外&lt;/li&gt;
&lt;li&gt;盡量不要超過五個單字&lt;/li&gt;
&lt;li&gt;業界和慣例中有對應縮寫時可以使用縮寫&lt;/li&gt;
&lt;li&gt;承上，縮寫兩個字母時全大寫，三個字母以上時只第一字大寫&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;命名空間&#34;&gt;命名空間&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;基礎類別庫：{組織} . {大類/應用範圍} . {小類/專案名稱}
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MyStudio.Libs.Basic&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MyStudio.Libs.Web.BaseTools&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;專案類別庫：{專案名稱} . {子專案/類別/用途}
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MyProject.Permiss.Proxy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MyProject.Permiss.Repository&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;類別&#34;&gt;類別&lt;/h3&gt;
&lt;p&gt;使用&lt;strong&gt;名詞&lt;/strong&gt;或名詞片語，不使用任何前綴，須和檔案名稱相同
類別應該要能夠在 25 個字之內做出描述&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基底類別 (Basic Class)&lt;/strong&gt;：後綴 &lt;strong&gt;Base&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public class ProductBase&lt;/code&gt; （=產品基底類別）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一般類別 (General Class)&lt;/strong&gt;  註：抽象類別與一般類別的命名相同
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public class Product&lt;/code&gt; （=產品類別）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集合類別 (Collection Class)&lt;/strong&gt;：後綴 &lt;strong&gt;Collection&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public class ProductCollection&lt;/code&gt; （=產品集合類別）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工廠類別 (Factory Class)&lt;/strong&gt;：後綴 &lt;strong&gt;Factory&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public class ProductFactory&lt;/code&gt; （=產品工廠類別）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Help 類別&lt;/strong&gt;：應以 Help 名稱、Help 性質方式命名
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public class SystemTimeHelp&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有使用 Partial 的類別&lt;/strong&gt;：檔名按照類別階層命名
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public partial class Core&lt;/code&gt; 此類別分散到 Album 和 Banner
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;internal Public class Album&lt;/code&gt;  -&amp;gt; 檔名為 &lt;code&gt;Core.Album.cs&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;internal Public class Banner&lt;/code&gt; -&amp;gt; 檔名為 &lt;code&gt;Core.Banner.cs&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;列舉&lt;/strong&gt;：大駱駝峰，並後綴 &lt;strong&gt;Enum&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public enum KeywordTypeEnum&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;介面&lt;/strong&gt;：大駱駝峰，前綴 &lt;code&gt;I&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ICarFactory&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;變數屬性&#34;&gt;變數、屬性&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;公開變數使用大駱駝峰&lt;/strong&gt;，例如 &lt;code&gt;public string Name { set; get; }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;私有變數使用小駱駝峰&lt;/strong&gt;，例如 &lt;code&gt;private int approvalRating&lt;/code&gt;，看專案決定需不需要加上底線當前綴&lt;/p&gt;
&lt;p&gt;常數一律大寫，但建議使用 static readonly 然後使用大駱駝峰。因為前輩的文件表示過使用常數連結 DLL 時如果修改 DLL 的常數再參考但尚未建置時會導致一些神奇的錯誤&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const double PI = 3.14159;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static readonly double Pi = 3.14159;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;命名變數時的注意事項：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包含邊界的極值優先使用 &lt;code&gt;min&lt;/code&gt; 與 &lt;code&gt;max&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;閉區間優先使用 &lt;code&gt;first&lt;/code&gt; 與 &lt;code&gt;end&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;半開放區間優先使用 &lt;code&gt;begin&lt;/code&gt; 與 &lt;code&gt;end&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Boolean 變數開頭必須使用 &lt;code&gt;is&lt;/code&gt; &lt;code&gt;can&lt;/code&gt; &lt;code&gt;has&lt;/code&gt; &lt;code&gt;should&lt;/code&gt; 或有狀態差異的形容詞&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;宣告變數時的注意事項：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;變數越多越難記得所有變數
&lt;ul&gt;
&lt;li&gt;減少沒用到的、或對可讀性沒有幫助的變數&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;變數存活的範圍越大，就必須記越久
&lt;ul&gt;
&lt;li&gt;盡量&lt;strong&gt;避免使用全域變數&lt;/strong&gt;，縮限並控制所有變數的範圍&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;變數越常改變越難記得目前的數值和意義
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;偏好單次寫入變數&lt;/strong&gt;，盡量不要過度重複寫入造成混亂&lt;/li&gt;
&lt;li&gt;當變數內容改變，就可以考慮宣告成新的變數&lt;/li&gt;
&lt;li&gt;變數的宣告和其命名都是為了讓閱讀者&lt;strong&gt;能直接看出改變的差異或當下變數的狀態&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;方法&#34;&gt;方法&lt;/h3&gt;
&lt;p&gt;一律使用大駱駝峰，前綴字規定如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;擷取&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Get&lt;/code&gt;：從資料庫抓回資料&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Search&lt;/code&gt;：頁面或定義為搜尋時&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Find&lt;/code&gt;：在既有的資料集合找資料&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Fetch&lt;/code&gt;：從遠端 (透過API) 獲取資料，例如：`FetchUsers()&lt;/li&gt;
&lt;li&gt;&lt;code&gt;load&lt;/code&gt;：從本地端加載資料，例如：&lt;code&gt;LoadFile()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;修改&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Update&lt;/code&gt;：對資料庫的異動&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Modify&lt;/code&gt;：現有變數或資料集合的變動&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;建立&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Insert&lt;/code&gt;：資料庫的資料建立&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Create&lt;/code&gt;：資料集合或物件的建立&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Generate&lt;/code&gt;：單純產生特定資料供使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;刪除&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Delete&lt;/code&gt;：資料庫的資料刪除（資料將不存在）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Remove&lt;/code&gt;：資料集合的資料移除／資料間的關係移除（資料仍存在）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其他&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Convert&lt;/code&gt;：代碼轉文字／編碼之間的轉換&lt;/li&gt;
&lt;li&gt;&lt;code&gt;calculate/calc&lt;/code&gt;：通過計算獲取資料，例如：&lt;code&gt;CalcBMI()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;show&lt;/code&gt;：顯示物件，例如：&lt;code&gt;ShowDialog()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;on&lt;/code&gt;：定義 event 的時候使用，像是 &lt;code&gt;OnClick()&lt;/code&gt;, &lt;code&gt;OnChange()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;handle&lt;/code&gt;：當 &lt;code&gt;OnClick&lt;/code&gt; 之類的 event 發生時所觸發的 function&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;方法中用到的參數視作私有變數&lt;/strong&gt;，使用小駱駝峰，如 &lt;code&gt;(string name, int age)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果有泛型直接使用 &lt;code&gt;T&lt;/code&gt; 做表示（如 &lt;code&gt;List&amp;lt;T&amp;gt; T1, List&amp;lt;T&amp;gt; T2&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;其他注意事項：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;比起弄很多大櫃子然後把東西都塞進去，分工明確的小抽屜更方便靈活&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;輸入參數應該越少越好，如果參數高於三個以上，試著&lt;strong&gt;換個思路&lt;/strong&gt;重構這個方法&lt;/li&gt;
&lt;li&gt;輸入參數&lt;strong&gt;不要使用傳入 Boolean 來改變類別和函式的行為&lt;/strong&gt;（違反單一職責）&lt;/li&gt;
&lt;li&gt;有多載的需求時，將輸入參數最多的宣告設為 virtual，其他較少輸入參數的則以呼叫最多輸入參數的函式來完成建構&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;類別的名稱已經有足夠的說明，則方法名稱就不需要再複誦一次&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;例如 &lt;code&gt;ProductService.GetProduct()&lt;/code&gt; 就是贅詞&lt;/li&gt;
&lt;li&gt;可以改為 &lt;code&gt;ProductService.Get()&lt;/code&gt; 就好&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;呼叫方法時，如果傳入參數無法直接識別內容，則應使用具名傳遞
&lt;ul&gt;
&lt;li&gt;例如 &lt;code&gt;Get(productId, true)&lt;/code&gt; 很難看出來 true 代表的意思&lt;/li&gt;
&lt;li&gt;可以改為 &lt;code&gt;Get(productId, isInStock: true)&lt;/code&gt; 就好&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;回傳值除了單純的運算式以外，一律回傳變數&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;(2022/1/25) 補充：&lt;/p&gt;
&lt;p&gt;最近在命名方法時，關於動詞的部份我會參考兩個實用的東東，這邊也分享給各位：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/EngTW/English-for-Programmers&#34;&gt;EngTW/English-for-Programmers: 《程式英文》：用英文提昇程式可讀性 (github.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/powershell/scripting/developer/cmdlet/approved-verbs-for-windows-powershell-commands?view=powershell-7.2#common-verbs&#34;&gt;已核准的 PowerShell 命令動詞 - PowerShell | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;斷行與縮排&#34;&gt;斷行與縮排&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;整潔的程式碼讀起來就像一篇優美的散文&lt;/p&gt;
&lt;p&gt;　　—— 《無瑕的程式碼》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;不要過多的斷行，也不要都擠在一起，&lt;strong&gt;組織成不同的段落&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;方法之間空一行&lt;/li&gt;
&lt;li&gt;參數過長時斷至下一行&lt;/li&gt;
&lt;li&gt;程式碼單行欄位數目以不超過 100~120 字元為原則&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不要省略括弧，&lt;strong&gt;讓程式碼範疇／區塊明顯可見&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;迴圈和 IF 等區塊確實斷行和使用括弧，以維持可閱讀性&lt;/li&gt;
&lt;li&gt;運算式的優先部分也要加上括弧，方便一眼看出計算順序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使 code 的&lt;strong&gt;順序流暢&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;參數按照傳入的順序排列&lt;/li&gt;
&lt;li&gt;相似方法之間的傳入參數順序盡可能一致&lt;/li&gt;
&lt;li&gt;相關的宣告和操作放在一起&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;當因為參數過多的時候必須斷到下一行時，從第一個參數之前就開始斷行
&lt;ul&gt;
&lt;li&gt;因本條規則斷行後，則一個參數獨立一行，必要時具名，使閱讀時能直接往下閱讀&lt;/li&gt;
&lt;li&gt;不過如果方法參數過多，應先考慮是否重構該方法，極可能違反單一職責&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;風格一致、風格一致、風格一致&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;邏輯運算&#34;&gt;邏輯運算&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;儘管區塊只有一行（例如 if else），&lt;strong&gt;仍一律使用大括號&lt;/strong&gt;，避免改寫時沒注意到&lt;/li&gt;
&lt;li&gt;條件式的左側為「變化值」、右側則是前者的「比較基準」
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;符合口語邏輯&lt;/strong&gt;：如果你高於 180 公分 =&amp;gt; &lt;code&gt;if(lenght &amp;gt; 180)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;處理 if/else 的順序時，大多有以下思路
&lt;ul&gt;
&lt;li&gt;先處理&lt;strong&gt;肯定&lt;/strong&gt;的再處理否定的（如：if 成功 else 失敗）&lt;/li&gt;
&lt;li&gt;先處理&lt;strong&gt;簡單&lt;/strong&gt;的再處理複雜的（如：if 吃了一顆糖 else 吃了兩顆糖以上）&lt;/li&gt;
&lt;li&gt;先處理比較&lt;strong&gt;有趣或明顯&lt;/strong&gt;的（舉例舉不出來= =）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三元運算式&#34;&gt;三元運算式&lt;/h3&gt;
&lt;p&gt;簡單卻繁瑣的時候使用，但是複雜的時候就乖乖用 if else。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; gender = (member.Sex == &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;F&amp;#34;&lt;/span&gt;) ? &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;女性&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;男性&amp;#34;&lt;/span&gt;; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 很棒&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; result = (exponent &amp;gt;= &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)? mantissa * (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; exponent): mantissa / (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; -exponent)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ？？？&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;迴圈&#34;&gt;迴圈&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;迴圈不要用 do/while
&lt;ul&gt;
&lt;li&gt;因為大多數方法和區塊邏輯判斷都在前面，因此使用後置條件會影響閱讀性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;減少巢狀結構，不要玩波動拳
&lt;ul&gt;
&lt;li&gt;減少巢狀的有效方法是「&lt;strong&gt;儘早返回&lt;/strong&gt;」：直接離開當前的函式&lt;/li&gt;
&lt;li&gt;迴圈中可以使用 &lt;code&gt;continue&lt;/code&gt; 或 &lt;code&gt;break&lt;/code&gt; 來直接進入下一個或離開&lt;/li&gt;
&lt;li&gt;在方法／函式中可以先處理能直接 &lt;code&gt;return&lt;/code&gt; 結果離開的區塊&lt;/li&gt;
&lt;li&gt;發生錯誤或非預期結果時可以直接擲出錯誤 &lt;code&gt;throw new Exception&lt;/code&gt; 中斷程式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;存取修飾詞&#34;&gt;存取修飾詞&lt;/h3&gt;
&lt;p&gt;型別的存取層級，用來控制其他程式碼能不能使用這些型別或內容成員，也就是&lt;strong&gt;指定能夠存取的範圍，進而避免誤用、亂用或其他錯誤&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Public
&lt;ul&gt;
&lt;li&gt;可以讓同組件和參考該組件的任何其他程式碼存取&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Private
&lt;ul&gt;
&lt;li&gt;只能由相同類別或結構中的程式碼存取&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Protected
&lt;ul&gt;
&lt;li&gt;只能由相同類別或結構，或是從該類別衍生的類別存取&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Internal / Friend
&lt;ul&gt;
&lt;li&gt;可由相同組件的任何程式碼存取，但是其他組件的程式碼不能存取&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Static / Shared
&lt;ul&gt;
&lt;li&gt;用來宣告靜態成員&lt;/li&gt;
&lt;li&gt;此成員屬於型別本身而不屬於任何物件（＝全實體共用同個成員）&lt;/li&gt;
&lt;li&gt;不能用在索引子 (Indexer)、解構函式 (Destructor) 以及不在類別裡的型別&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;註解&#34;&gt;註解&lt;/h3&gt;
&lt;p&gt;基本上對各個格式（如結構、函數）都必須加上說明註解，其中的參數和成員（例如列舉）也必須說明。
VS 中 /// 就會幫忙把參數註解格式打好。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C#&#34; data-lang=&#34;C#&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// 資料庫連線類別&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DatabaseConstants&lt;/span&gt; : IDatabaseConstants
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Something&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;重點在於：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;簡短敘述，避免模稜兩可或不知去向的代名詞（例如：更新那個東東）&lt;/li&gt;
&lt;li&gt;描述函式行為，例如（計算檔案的行數 =&amp;gt; 計算檔案中的換行位元個數(\n)）&lt;/li&gt;
&lt;li&gt;描述處理過程的原因，要知道做了什麼可以直接看程式碼，要知道為什麼做只能看註解&lt;/li&gt;
&lt;li&gt;常數旁邊一定要做原因或用途的說明&lt;/li&gt;
&lt;li&gt;函式可以加上範例 &lt;code&gt;&amp;lt;example&amp;gt; Strip(&amp;quot;aba&amp;quot;,&amp;quot;ab&amp;quot;) return &amp;quot;a&amp;quot; &amp;lt;/example&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;移除不需要的註解，例如日誌、署名、重複資訊、被註解掉的 code 之類&lt;/li&gt;
&lt;li&gt;使用註解標籤：Todo = 待辦事項； Fixme = 需修復；可搭配 VS 內建的&lt;a href=&#34;https://reurl.cc/rl1Kab&#34;&gt;工作清單&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;附錄型別&#34;&gt;附錄：型別&lt;/h3&gt;
&lt;h4 id=&#34;實質型別&#34;&gt;實質型別&lt;/h4&gt;
&lt;p&gt;包含所有的數字型別、布林、字元和日期，以及結構和列舉&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;傳值&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;不允許 Null （除非特別指派 Nullable）&lt;/li&gt;
&lt;li&gt;有隱含的預設建構式，不需要用 new&lt;/li&gt;
&lt;li&gt;初始化之後才能使用&lt;/li&gt;
&lt;li&gt;資料傳遞時是將&lt;strong&gt;資料&lt;/strong&gt;複製到另一個變數&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;參考型別&#34;&gt;參考型別&lt;/h4&gt;
&lt;p&gt;能進一步分為陣列和類別型別，其中包含字串、所有陣列、類別、委派和介面。以及匿名和通用型別&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;傳址&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;必須要使用 new 建立實體，並將該實體的參考記在變數&lt;/li&gt;
&lt;li&gt;資料傳遞時是將&lt;strong&gt;參考&lt;/strong&gt;複製到另一個變數&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;註記：&lt;strong&gt;字串比較特別&lt;/strong&gt;，實際上比較像一個結構。可以試著當成字元的串列比較好記，可以從 &lt;code&gt;char[] letters = {&#39;H&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;};&lt;/code&gt; 和 &lt;code&gt;string a = new string(letters);&lt;/code&gt; 的實驗中感覺到一絲端倪。字串建立後也不允許直接變更，可能是藉此閃避一些更改時的問題。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;轉型&#34;&gt;轉型&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;隱含轉換&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;屬於安全的轉換，所以不用使用特殊語法&lt;/li&gt;
&lt;li&gt;小型到大型整數型別的轉換（如 int -&amp;gt; long）&lt;/li&gt;
&lt;li&gt;衍生型別 (Derived Class) 到基底型別 (Base Class) 的轉換&lt;/li&gt;
&lt;li&gt;例如 &lt;code&gt;int num = 2147483647; long bigNum = num;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;明確轉換&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;資料可能在轉換中遺失或失敗時，需要使用轉型運算子&lt;/li&gt;
&lt;li&gt;往精確度較低或範圍較小的型別進行的數值轉換（如 double -&amp;gt; int）&lt;/li&gt;
&lt;li&gt;基底類別往衍生類別的轉換&lt;/li&gt;
&lt;li&gt;例如 &lt;code&gt;double x = 1234.7; int y= (int)x&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用 Helper 類別轉換&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;在不相容型別間進行轉換時使用（如 int -&amp;gt; System.DateTime）&lt;/li&gt;
&lt;li&gt;使用 Helper 進行轉換（如 Int32.Parse），例如
&lt;ul&gt;
&lt;li&gt;System.BitConverter 類別&lt;/li&gt;
&lt;li&gt;System.Convert 類別&lt;/li&gt;
&lt;li&gt;內建數字型別 (Numeric Type) 的 Parse 方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;例如 &lt;code&gt;string x = &amp;quot;2016-04-08&amp;quot;; DateTime z = System.DateTime.Parse(x)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Pocket —— 稍後閱讀，想看再看</title>
      <link>https://igouist.github.io/post/2020/07/pocket/</link>
      <pubDate>Sat, 18 Jul 2020 10:17:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/pocket/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;前言：由於我這人特喜歡發完文之後一想到就回去改改，因此現在還在修改上一篇物件導向的內容囧。講好聽是有持續交付的精神，講難聽就是比較後知後覺一點。因此這幾篇仍會像之前我要買便當系列一樣，主軸間穿插個幾篇小工具或心得，以這個節奏前進。所以這邊就介紹一下我幾乎每天都會用到的小工具：&lt;strong&gt;Pocket&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在兩個多月前，我們介紹過將文章用 RSS 訂閱集中起來的工具 &lt;a href=&#34;https://igouist.github.io/post/2020/04/feedly/&#34;&gt;Feedly&lt;/a&gt;。但是，有些時候雖然對文章挺有興趣的，但並&lt;strong&gt;不適合馬上看&lt;/strong&gt;（例如在公司或學校的時候，看到社論、科技新聞等等）；或是像我個人平常休息時逛逛一些論壇或是文檔，這時候如果遇到一些&lt;strong&gt;比較長的、主題式的文章&lt;/strong&gt;，就會想要把文章存放起來，等晚些時候再看。&lt;/p&gt;
&lt;p&gt;雖然 Feedly 也有提供 Read Later 的功能，只要勾個標籤就可以之後再到 Read Later 的頁面去觀看。但懶惰如我，就會想要把所有稍後再看的文章集中在一塊，因此必須尋找一個前述場景都共用的做法，這時我就遇上了 Pocket。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://getpocket.com/&#34;&gt;Pocket&lt;/a&gt; 是一個簡單直接的「稍後閱讀」服務，操作方便，只需要擴充套件或分享，和一段能靜下來好好閱讀的時間即可服用&lt;/strong&gt;。在開始介紹之前，有幾件事必須報告：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果你和我一樣可能變成倉鼠型玩家，看到什麼都想加到稍後閱讀，可能要當心。建議可以先閱讀一下 &lt;a href=&#34;https://www.playpcesor.com/2011/10/blog-post.html&#34;&gt;用「稍後閱讀」過濾資訊洪水的五種層次與六個方法 - 電腦玩物&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;就像在 Feedly 介紹中提到的：這類工具是用來幫助我們完成&lt;strong&gt;被動接收資訊＋主動篩選資訊&lt;/strong&gt;的，莫要忘記原則，否則真的很容易看不完看到超載，心會很累。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你是 Android 或 iOS 的使用者，由於 Pocket 有提供網頁和 APP 等平台，但本篇以電腦的操作為主，使用手機操作的朋友可以參考 &lt;a href=&#34;https://www.kocpc.com.tw/archives/266659&#34;&gt;Pocket 稍後閱讀 APP，收藏想看的文章和網頁！&lt;/a&gt; 這篇的說明。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你已經決定要尋找稍後閱讀功能的工具，可以參考 &lt;a href=&#34;https://pickydigest.com/productivity/read-it-later-bookmark-app-competition/&#34;&gt;10個稍後閱讀書籤服務大評比！Pocket、Instapaper、Diigo還有更多！&lt;/a&gt;本篇並不會提到別的工具。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;介紹&#34;&gt;介紹&lt;/h2&gt;
&lt;p&gt;首先，我們得先到 &lt;a href=&#34;https://getpocket.com/&#34;&gt;Pocket&lt;/a&gt; 申請一個帳號，我個人是直接使用 Google 帳號做登入。成功登入之後應該能到 Pocket 的大廳：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/JHo0YQh.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我們之後儲存的文章就會出現在這裡。上方工具列還有探索的功能，但我個人試過之後大多都是英文文章，對我這種英文白癡派不上什麼用場。&lt;/p&gt;
&lt;p&gt;接著讓我們安裝 Chrome 的 擴充套件：&lt;a href=&#34;https://chrome.google.com/webstore/detail/save-to-pocket/niloccemoadcdkdjlinkgdfekeahmflj&#34;&gt;Save to Pocket&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;之後我們直接找個一篇文章做示範，然後讓我們按下擴充套件的 Pocket 按鈕…&lt;/p&gt;
&lt;p&gt;（如果是手機使用者，這邊就是把目標網頁分享給 Pocket App）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/tjRP5o2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;再回到 Pocket …&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/SAlnwW4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;就成功把文章存下來啦！&lt;/p&gt;
&lt;p&gt;點進去之後可以發現，它和 Notion、Evernote 那些筆記軟體的擷取方式一樣，是&lt;strong&gt;將文章內容擷取出來&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/HwQbPRP.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;當然，作為一個閱讀服務，Pocket 服務該有的都有。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/nyAVhSd.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;畫面上方有一些基礎操作的工具列，例如替&lt;strong&gt;文章內容畫線、或是將文章加上分類標籤、進行封存和刪除等等&lt;/strong&gt;。此外，右上方也能調整閱讀版面的設定，但除了基本的&lt;strong&gt;主題色彩和字體大小&lt;/strong&gt;以外，更客製化的設定選項就必須付費才能取得了。&lt;/p&gt;
&lt;p&gt;（當然，如果像我這種有在使用 &lt;a href=&#34;https://chrome.google.com/webstore/detail/simpread-reader-view/ijllcpnolfcooahcekpamkbidhejabll/related&#34;&gt;簡閱&lt;/a&gt; 這類閱讀擴充套件的話，這部分就不會有什麼問題了XD）&lt;/p&gt;
&lt;p&gt;Pocket 作為稍後閱讀的暫存站，我個人是免費就用得很開心。如果有需要無限期存放文章或是無限標籤等需求，請再前往 &lt;a href=&#34;https://getpocket.com/premium?ep=10&#34;&gt;升級頁面&lt;/a&gt; 參考。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;註：Pocket 也有提供朗讀文章的功能，需要的時候可以用聽的，不過我個人沒有試過，因為遇到需要用聽的情景的話，我會跑去聽 Podcast。如果有聽文章習慣或是有興趣的朋友，可以參考&lt;a href=&#34;https://www.playpcesor.com/2016/02/pocket-reade-later.html&#34;&gt;[生活駭客3] 開始「聽」文章，日常時間加一倍的魔法&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;稍後閱讀功能的服務還挺多的，我之所以最後選定使用 Pocket，有一大半原因是因為我發現它&lt;strong&gt;能和我的 Kobo 電子書閱讀器同步&lt;/strong&gt;。作為一個通勤搭車每天動輒一兩小時的上班族，搭車時間拿來看看書看看文章真是再愜意不過了。但由於我真的很懶，捷運又常常站著，書還是挺重的不方便帶來帶去，所以後來我還是毅然決然踏入閱讀器的世界，這時候我才發現了 Pocket。&lt;/p&gt;
&lt;p&gt;利用 Pocket 我就能把早上從 Feedly 看見的部分文章，挪到上下班搭車的時候再用輕便的電子書閱讀，豈不妙哉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/cIkoRR1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;示意圖（單純只是想秀一下閱讀器）&lt;/p&gt;
&lt;p&gt;利用 Pocket 我就能把想讀的文章同步到網頁、APP 和閱讀器等各平台，並利用碎片時間來看個一兩篇，既分散了有時遇到太多篇想看的文章的那種壓迫，瑣碎時間也不用再煩惱要幹嘛就能順手看一下，對我這種懶得想當下要幹嘛的人，真的是挺有幫助啊。&lt;/p&gt;
&lt;h2 id=&#34;結語&#34;&gt;結語&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;所有的工具都是為了完成整體流程的某個環節而存在&lt;/strong&gt;，凡如開發功能、佈 CI/CD 環境、或是專案管理具等等，我們無不利用各項工具和技術的搭配來組合成我們需要的流程。當然，資訊篩選也是如此，Pocket 提供了延後閱讀的服務，但這個服務的使用方式取捨於個人的習慣。如果能像電腦玩物說的，在把文章丟進稍後閱讀時，能先想一想「&lt;strong&gt;這則資訊我真的想要認真讀它嗎？&lt;/strong&gt;」如果是，那麼我就相信 Pocket 一定能夠幫上忙。&lt;/p&gt;
&lt;p&gt;我個人現在的習慣方式是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;從 &lt;strong&gt;Feedly&lt;/strong&gt; 取得篩選來源的文章，或是有空閒時從常用的幾個論壇和網站，從中挑選有興趣的讀&lt;/li&gt;
&lt;li&gt;若是當天有興趣的太多，或是文章過長不適合當下閱讀，就利用 &lt;strong&gt;Pocket&lt;/strong&gt; 暫存起來&lt;/li&gt;
&lt;li&gt;閱讀後，將認為有價值或喜歡的文章存放到 &lt;strong&gt;Notion&lt;/strong&gt; 並分類&lt;/li&gt;
&lt;li&gt;需要的時候，例如用到相關技術或想分享文章給朋友，就從 &lt;strong&gt;Notion&lt;/strong&gt; 中的分類提取文章出來&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;藉由這些工具組成了一個每日固定的閱讀流程，並穩定地增加庫存（對我本質還是倉鼠型），目前為止我都還覺得挺不錯的，這邊分享給各位。&lt;/p&gt;
&lt;p&gt;最後的最後，因為真的覺得&lt;strong&gt;電子書很讚&lt;/strong&gt;，還是想推廣一下。如果有對電子書有興趣的朋友，可以看一下以下這兩篇，整理得相當不錯，優缺點都有列到，尤其是閱讀前哨站那篇的 Q&amp;amp;A 整理部份已經涵蓋最常遇到的問題，推薦在考慮入坑時讀個一遍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://readingoutpost.com/ebook-ereader-experience/&#34;&gt;2年讀100本書的全職科技人，電子書閱讀器使用心得與感想&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aronhack.com/%E8%B3%BC%E8%B2%B7%E9%9B%BB%E5%AD%90%E6%9B%B8%E9%96%B1%E8%AE%80%E5%99%A8%E5%89%8D-%E5%BF%85%E8%AE%80%E5%84%AA%E7%BC%BA%E9%BB%9E%E5%8F%8A%E5%BF%83%E5%BE%97%E5%88%86%E4%BA%AB/&#34;&gt;購買電子書閱讀器前，必讀優缺點及心得分享&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那麼今天的分享就到這裡，如果有不錯的工具或是建議，也歡迎不吝提出。那麼，我們下周見！&lt;/p&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.playpcesor.com/2011/10/blog-post.html&#34;&gt;用「稍後閱讀」過濾資訊洪水的五種層次與六個方法 - 電腦玩物&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.playpcesor.com/2012/04/pocket-read-it-later.html&#34;&gt;Pocket Read it later 稍後閱讀同步、離線、免費行動口袋 - 電腦玩物&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.playpcesor.com/2016/02/pocket-reade-later.html&#34;&gt;[生活駭客3] 開始「聽」文章，日常時間加一倍的魔法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pickydigest.com/productivity/read-it-later-bookmark-app-competition/&#34;&gt;10個稍後閱讀書籤服務大評比！Pocket、Instapaper、Diigo還有更多！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kocpc.com.tw/archives/266659&#34;&gt;Pocket 稍後閱讀 APP，收藏想看的文章和網頁！&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (7): 介面</title>
      <link>https://igouist.github.io/post/2020/07/oo-7-interface/</link>
      <pubDate>Sun, 12 Jul 2020 23:53:07 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/oo-7-interface/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/9eGbMlk.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果說&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;繼承&lt;/a&gt;是用來表明物件「屬於什麼」；那麼介面就是用來表明物件「能做什麼」。&lt;/p&gt;
&lt;p&gt;如果說&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;封裝&lt;/a&gt;是將物件視作一個整體，是隱藏複雜度；那麼介面就是封裝精神的體現。&lt;/p&gt;
&lt;p&gt;如果說&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;多型&lt;/a&gt;是指藉著繼承後能實作不同的行為的可能性達到擴展的彈性；那麼介面就是在實作多型。&lt;/p&gt;
&lt;p&gt;介面就是這麼厲害，這麼瀟灑。介面就是我大哥，今天誰不服介面，對不起！我們不認識。&lt;/p&gt;
&lt;p&gt;介面就像是針對類別的實作、物件的行為去做規定的一個契約書，會先定義好要實作這個介面的類別所必須要有的方法，而當我們建立符合這個介面的類別時，就必須實作出所有介面中定義好方法才可以。……這樣說起來實在太繞口，總而言之介面的核心概念只有一條：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我不在乎你是誰，我只在乎你能做什麼。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;還是公司誠徵工程師的例子&#34;&gt;還是公司誠徵工程師的例子&lt;/h2&gt;
&lt;p&gt;由於介面基本上就是封裝繼承多型抽象之大雜燴，所以我們把前面&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;多型&lt;/a&gt;的小明小華例子稍微修改來用吧。也就是以公司徵人的方式去理解介面。&lt;/p&gt;
&lt;p&gt;介面就像是老闆開出來的要求列表，例如說：要會寫 C#、要會寫 SQL、要會 VB…等等，於是老闆就貼出了徵人啟示，要求新來的員工必須要有 &lt;code&gt;IProgrammer&lt;/code&gt; 寫的能力：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;IProgrammer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; WriteCSharp();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; WriteSQL();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; WriteVB();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;特別注意和前面多型的例子的不同處，&lt;strong&gt;介面只需要先定義好該做的事，裡面怎麼做不需要管；所以只需要宣告要求的方法，不需要撰寫方法本體&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;於是今天小華就又(?)來面試了，但是他其實並不會寫 C#：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Hua&lt;/span&gt; : IProgrammer
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Error: Hua 未實作 IProgrammer.WriteCSharp()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; WriteSQL() { &lt;span style=&#34;color:#75715e&#34;&gt;/* Work */&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; WriteVB() { &lt;span style=&#34;color:#75715e&#34;&gt;/* Work */&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這時候編譯器就會跳出錯誤了：很抱歉，你不符合我們 &lt;code&gt;IProgrammer&lt;/code&gt; 的規定，因為我們只喜歡訓練精英（略），請你實作完之後再來。否則你就不能掛上我們 &lt;code&gt; : IProgrammer&lt;/code&gt; 的頭銜。&lt;/p&gt;
&lt;p&gt;雖然小華面試失敗了，不過至少小華幫我們示範了一件事：類別要標上介面的方法就和繼承一樣，在類別名稱後面加上 &lt;code&gt;:&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;而小華走了之後，馬上就輪到小明開開心心地來應徵了，他不只會寫 C#、SQL 和 VB，甚至還會泡英式奶茶：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Ming&lt;/span&gt; : IProgrammer
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; WriteCSharp() { &lt;span style=&#34;color:#75715e&#34;&gt;/* Work */&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; WriteSQL() { &lt;span style=&#34;color:#75715e&#34;&gt;/* Work */&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; WriteVB() { &lt;span style=&#34;color:#75715e&#34;&gt;/* Work */&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Tea MakeTea() { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Tea(teaName: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;MilkTea&amp;#34;&lt;/span&gt;); }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;火速通過面試之後，老闆就讓小明上工了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Work()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    IProgrammer programmer = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Ming();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    programmer.WriteCSharp();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    programmer.WriteCSharp();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    programmer.WriteCSharp();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在這個時候，小明已經不再只是小明，對老闆而言他就是一個&lt;strong&gt;符合應徵要求的工程師&lt;/strong&gt;，這裡只需要「&lt;strong&gt;我（老闆）要求能做這些事的人&lt;/strong&gt;」而不是「小明」，是 &lt;code&gt;IProgrammer&lt;/code&gt; 而不是 &lt;code&gt;Ming&lt;/code&gt;。在呼叫 &lt;code&gt;IProgrammer programmer = new Ming()&lt;/code&gt; 的同時，這裡就只剩下一個無情的寫程式機器，再也沒有小明。&lt;/p&gt;
&lt;p&gt;上面這句雖然和多型範例的說明九成一樣，但絕對不是我偷懶（真的），差異的地方就是介面的本質。可以稍加對照看看。&lt;/p&gt;
&lt;p&gt;當然，小明仍然不准在上班時間泡英式奶茶。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Work()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    IProgrammer programmer = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Ming();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    programmer.WriteCSharp();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    programmer.MakeTea(); &lt;span style=&#34;color:#75715e&#34;&gt;// Error: IProgrammer 未包含 MakeTea 的定義&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;多型的時候，這個原因是由於今天的小明是工程師，工程師不需要會泡奶茶。也就是說子類別替代父類別時不需要那些父類別不會的動作。此處也是一樣的精神，我們要的是一個會寫程式的工程師，&lt;strong&gt;不是介面規範上的東西我們不需要&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這是達成關注點分離和職責分離必經的道路，習慣之後對於公開方法和私有方法也會有更進一步的心得，以公開方法實現介面的要求，配合私有方法拆解內部的複雜度，甚至&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;組合多個介面&lt;/a&gt;讓類別具有多項能力，這個過程只能用舒爽來形容（前提是介面不要開得太爛的話啦）。&lt;/p&gt;
&lt;h2 id=&#34;變更的彈性&#34;&gt;變更的彈性&lt;/h2&gt;
&lt;p&gt;介面作為特性的體現，更多的是概念上的東西。最後這一小段就讓我們聊聊這些部分。&lt;/p&gt;
&lt;p&gt;在新訓時改變我想法最多的就是介面，在這之前我只會一個函式硬寫到底，而習慣從介面開始設計物件後，才開始從功能的角度去想要怎麼寫。&lt;/p&gt;
&lt;p&gt;介面不同於前面各項特性是告訴我們物件應該有什麼特徵，而是要求我們用「不同功能的物件之間對接時，我們該怎麼處理」的角度去看待問題。&lt;/p&gt;
&lt;p&gt;介面的核心概念在於提供了更多的彈性，更精確地說是&lt;strong&gt;變更的彈性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;原本是連線到 MySQL 取得資料，哪天突然就必須更改成要連線到 MongoDB 取得資料；&lt;/p&gt;
&lt;p&gt;原本是只要實作出使用者儲存訂單的操作，突然接到指令說使用者必須區分成一般使用者和尊爵用戶並且實作出不同的操作流程等等。&lt;/p&gt;
&lt;p&gt;變更總是來得又急又快，而這也讓我們靜下來想，當我們把關注點放在整個邏輯的時候－－&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我需要的是「連線到 MySQL 取得資料」的工具嗎？並不是，只要是「能連線到資料庫、能取得資料」就好了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我需要的是「以ＯＯＯ技術替使用者建立訂單並儲存」的工具嗎？並不是，「替使用者建立訂單並儲存」才是最重要的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;資料庫是可以替換的，儲存訂單到資料庫的工具也是可以替換的，甚至替使用者建立訂單的過程也是可以替換的。&lt;/p&gt;
&lt;p&gt;因此，從介面開始設計時最重要的是釐清「&lt;strong&gt;我需要的是什麼&lt;/strong&gt;」，用介面定義一份契約，把使用對象和實作銜接起來；並且把實作隔離成可替換的部件，達到解除&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;耦合&lt;/a&gt;的目標。&lt;/p&gt;
&lt;p&gt;最後還是回到了關注點分離的議題：主流程、商業邏輯專心做好自己的事，他們只需要知道這個物件能夠提供拿到資料的方法就好。而實際上怎麼拿到資料，則由實作的物件內部去處理，也就是封裝的核心精神。&lt;/p&gt;
&lt;p&gt;要理解介面的概念，訣竅在於把目光更集中在「功能」的角度。我們在理解物件的時候，可以知道冰箱是一個物件、冰櫃是一個物件、保冷袋是一個物件；但當我們在海邊釣到魚，想要找個地方保存的時候，我們需要的是冰箱嗎？是冰櫃嗎？是保冷袋嗎？&lt;/p&gt;
&lt;p&gt;都不是，我們需要的是「能低溫保存食物的東西」而已，今天你能用冰箱從海邊運到你家也沒關係，只要你實作得出來，並且魚是新鮮的就好。於是我們把&lt;strong&gt;觀看物件的角度集中在它的功能上&lt;/strong&gt;，我們針對我們的需求去定義好我們需要的功能，這就是介面。&lt;/p&gt;
&lt;p&gt;我們定義好什麼叫做飛行，於是鴿子跟烏鴉都算是實作了飛行；我們定義好什麼叫做游泳，於是海豚跟鯨魚都算是實作了游泳。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只要你符合我需要的功能，達到我要的目的，不論你是誰，你如何實作，我都無所謂。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如此我們既達到了關注點分離，也保留了定好規則，將來可以使用不同實作的彈性；甚至將來接手的是另一個人，他看你的介面就能知道如何替換，替換時對象至少要能做到哪些事，今天他接到需求是上頭覺得保冷袋太 Low 了，我們要改用冰櫃車，他也有個接口／介面去指示他修改的方向。&lt;/p&gt;
&lt;p&gt;而在兩個系統，或是兩個分層之間要介接的時候，只需要提供我這個功能需要的接口／介面給對方，就能讓對方知道他必須實作哪些功能，如果我們要把運魚的需求託付給貨運公司，他看介面就知道我們要的是「低溫保存食物」，便可以提供對應的服務／實做給我們。如此豈不美哉！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;備註：一些有寫過前後端銜接的，或是做過一些小工具的到這邊可能會覺得有點熟悉。例如說：程式和使用者銜接的點，叫做使用者介面；前端跟後端交換資料的 API，叫做應用程式介面。所謂的介面／接口就是這麼一回事，這裡也不例外。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;小結&#34;&gt;小結&lt;/h2&gt;
&lt;p&gt;到這邊我們就介紹完介面的部分了，希望各位朋友能夠大概感覺到介面的精神。&lt;/p&gt;
&lt;p&gt;當然有些讀者看到這裡可能也會有點疑惑：&lt;/p&gt;
&lt;p&gt;像上面的例子中 &lt;code&gt;IProgrammer programmer = new Ming();&lt;/code&gt; 當我們宣告的當下不就還是知道了我們實作的對象是 &lt;code&gt;Ming&lt;/code&gt; 了嗎？這樣並沒有完全分離呀？（&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;依賴注入&lt;/a&gt;熱身中）&lt;/p&gt;
&lt;p&gt;等等諸如此類一堆問題，都也是我有過的想法，在接下來的新訓系列也將會逐漸說明，欲知後續如何，且待&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;下回&lt;/a&gt;分曉！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列下一篇：&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10229700&#34;&gt;設計模式起手式：介面（Interface）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@ChunYeung/%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E4%B8%AD%E7%9A%84%E4%BB%8B%E9%9D%A2%E8%88%87%E6%8A%BD%E8%B1%A1%E9%A1%9E%E5%88%A5%E6%98%AF%E4%BB%80%E9%BA%BC-1199804ccc5f&#34;&gt;物件導向中的介面與抽象類別是什麼 ?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://benyi.logdown.com/posts/2018/02/11/oop-what-is-interface&#34;&gt;[物件導向] 何謂介面（interface）？ - Benyi Hsia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@ad57475747/c-%E9%9B%9C%E8%A8%98-%E4%BB%8B%E9%9D%A2-interface-%E6%8A%BD%E8%B1%A1-abstract-%E8%99%9B%E6%93%AC-virtual-%E4%B9%8B%E6%88%91%E8%A6%8B-dc3c5878bb80&#34;&gt;C#雜記 — 介面(interface)、抽象(abstract)、虛擬(virtual)之我見 - Medium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://exfast.me/2016/09/c-sharp-use-interface-abstract-override-inheritance-implements-a-simple-example/&#34;&gt;[C#] 利用 interface(介面) abstract(抽象) override(覆寫) inherit(繼承) 實作簡單範例 - 從入門到放棄&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/initials/2016/06/18/102618&#34;&gt;[心得整理] c# 物件導向程式 - 3.抽象與介面 interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-4_%E6%8A%BD%E8%B1%A1%E9%A1%9E%E5%88%A5abstract%E8%88%87%E4%BB%8B%E9%9D%A2interface/&#34;&gt;Object Oriented物件導向-4:抽象類別(Abstract)與介面(Interface) - Sian&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;推薦系列文&#34;&gt;推薦系列文&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/11/newbie-6-dependency-injection&#34;&gt;菜雞新訓記 (6): 使用 依賴注入 (Dependency Injection) 來解除強耦合吧&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同系列文章&#34;&gt;同系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (6): 抽象、覆寫</title>
      <link>https://igouist.github.io/post/2020/07/oo-6-abstract-override/</link>
      <pubDate>Sun, 12 Jul 2020 23:53:06 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/oo-6-abstract-override/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Y2gHFsr.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;備註：這邊的抽象是指程式語言中的抽象類別，而非抽象化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;抽象的概念很直接，請回想一下前面的例子就可以了：&lt;/p&gt;
&lt;p&gt;當我們在用卡牌的例子時，雖然怪獸卡跟魔法卡都繼承了 Card 這個類別，但是我們仍然能 &lt;br/&gt; &lt;code&gt;new Card()&lt;/code&gt; 來建立一張新卡牌，那…怪怪的吧，這張卡牌到底是什麼呀，空白的卡片嗎？&lt;/p&gt;
&lt;p&gt;又或是動物的例子，我們的狗跟貓都繼承了哺乳類，那我們能實例化一個哺乳類嗎？我們的狗跟鳥都是動物，那我們能實例化一個動物嗎？&lt;/p&gt;
&lt;p&gt;小明跟小華都繼承了工程師，那我們能 new 一個工程師嗎…？&lt;/p&gt;
&lt;p&gt;有些類別就是這樣，它們負責定義共通的那些特性，&lt;strong&gt;然而它們本身不應該被實體化成一個物件，這種類別我們就應該把它們標記為抽象類別&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象類別在 C# 裡用 &lt;code&gt;abstract&lt;/code&gt; 這個修飾詞來表示&lt;/strong&gt;，可以加在類別或方法上。例如 &lt;code&gt;abstract class Animal&lt;/code&gt; 就代表動物這個類別是個抽象類別，它不能被實例化。&lt;/p&gt;
&lt;p&gt;而當加在方法上時，例如 &lt;code&gt;public abstract void Eat()&lt;/code&gt; 就是代表這個進食的方法無法被叫用，只能由繼承者去重新定義這個方法。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Animal&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; color { &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Eat();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那麼繼承者們，也就是衍生類別如何去重新定義父類別的方法呢？&lt;/p&gt;
&lt;p&gt;&lt;del&gt;所謂「欲戴王冠，必 Override」&lt;/del&gt;，這時候就必須使用&lt;strong&gt;覆寫（&lt;code&gt;override&lt;/code&gt;）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;覆寫是指對於像是前述的抽象方法時，在同名的方法前加上 &lt;code&gt;override&lt;/code&gt; 關鍵字就可以讓程式知道你要覆寫這個方法（你不覆寫的話，編譯器還會生氣）。&lt;/p&gt;
&lt;p&gt;例如前述的 Eat，狗就可以用 &lt;code&gt;public override void Eat()&lt;/code&gt; 的方式去覆寫吃東西這個方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Dog&lt;/span&gt; : Animal
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; color { &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt;; } = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Black&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Eat()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;/* 嚼嚼嚼 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但有時候我們只是希望秉持著多型的精神，讓子類別有可以重新定義的彈性，這時候我們就會使用&lt;br/&gt; &lt;strong&gt;虛擬（&lt;code&gt;virtual&lt;/code&gt;）&lt;/strong&gt; 的方式去標記這個方法，如此一來就可以實作，同時也讓子類別可以覆寫。&lt;/p&gt;
&lt;p&gt;例如可能狗有 &lt;code&gt;public virtual void Eat()&lt;/code&gt; 這個進食的方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Dog&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Eat()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;/* 嚼嚼熱狗 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那假設我們有個 &lt;code&gt;Giwawa&lt;/code&gt; 繼承了 &lt;code&gt;Dog&lt;/code&gt;，但牠也是吃熱狗的，就可以選擇不去覆寫 &lt;code&gt;Eat()&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Giwawa&lt;/span&gt; : Dog
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/* 不打算實作 Eat，直接使用 Dog 類別的 Eat */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而當我們有了 &lt;code&gt;RobotDog&lt;/code&gt; 這個類別，它就可以繼承並且重新改寫掉 &lt;code&gt;Eat()&lt;/code&gt; 這個方法，從吃肉變成喝汽油。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;RobotDog&lt;/span&gt; : Dog
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Eat()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;/* 嚼嚼汽油 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;除了使用 &lt;code&gt;override&lt;/code&gt; 去覆寫父類別的方法以外，也可以用 &lt;code&gt;new&lt;/code&gt; 去隱藏父類別的方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CyberDog&lt;/span&gt; : Dog
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Eat()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;/* 嚼嚼汽油 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;override&lt;/code&gt; 和 &lt;code&gt;new&lt;/code&gt; 的差別在於多型時轉型成父類別時的行為：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;override&lt;/code&gt; 會直接取代掉父類別的方法，即使轉型為父類別還是以子類別的實作為主&lt;/li&gt;
&lt;li&gt;&lt;code&gt;new&lt;/code&gt; 則是會建立一個子類別專屬的方法，若轉型為父類別就會變回父類別的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我們直接用例子來看看吧，假設我們現在有「拉不拉多」和「機器狗」，都繼承了「狗」。差別在於拉不拉多 override 了 &lt;code&gt;Eat()&lt;/code&gt; 這個方法，而機器狗 new 了 &lt;code&gt;Eat()&lt;/code&gt; 這個方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Dog&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Eat() 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    =&amp;gt; Console.WriteLine(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;吃了熱狗&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Labrador&lt;/span&gt; : Dog
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Eat() 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    =&amp;gt; Console.WriteLine(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;吃了超大熱狗&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;RobotDog&lt;/span&gt; : Dog
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Eat() 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    =&amp;gt; Console.WriteLine(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;喝了超多汽油&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接著讓我們來看看當他們被實例化之後，以及被轉型為父類別的時候的 &lt;code&gt;Eat()&lt;/code&gt; 有什麼不一樣吧：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Labrador =&amp;gt; override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; lala = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Labrador();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;lala.Eat(); &lt;span style=&#34;color:#75715e&#34;&gt;// 吃了超大熱狗&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;((Dog)lala).Eat(); &lt;span style=&#34;color:#75715e&#34;&gt;// 吃了超大熱狗&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ==============================&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// RobotDog =&amp;gt; new &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; robot = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; RobotDog();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;robot.Eat(); &lt;span style=&#34;color:#75715e&#34;&gt;// 喝了超多汽油&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;((Dog)robot).Eat(); &lt;span style=&#34;color:#75715e&#34;&gt;// 吃了熱狗&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到使用 &lt;code&gt;new&lt;/code&gt; 來覆寫的 RobotDog 在被轉型為 Dog 的時候突然就變回吃熱狗了！&lt;/p&gt;
&lt;p&gt;要特別注意的是：當你覆寫了父類別的方法，卻忘記加上 &lt;code&gt;override&lt;/code&gt; 的話，默認會當成是要 &lt;code&gt;new&lt;/code&gt;，所以覆寫的時候還是小心一點，具體地把 &lt;code&gt;override&lt;/code&gt; 或 &lt;code&gt;new&lt;/code&gt; 寫出來吧！&lt;/p&gt;
&lt;p&gt;關於抽象和覆寫這部份的範例，因為我個人碰觸的比較少，唯恐我的舉例不夠深入，這邊再附上幾個不錯的範例，可以作為參考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@ad57475747/c-%E9%9B%9C%E8%A8%98-%E4%BB%8B%E9%9D%A2-interface-%E6%8A%BD%E8%B1%A1-abstract-%E8%99%9B%E6%93%AC-virtual-%E4%B9%8B%E6%88%91%E8%A6%8B-dc3c5878bb80&#34;&gt;C#雜記 — 介面(interface)、抽象(abstract)、虛擬(virtual)之我見 - Medium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://exfast.me/2016/09/c-sharp-use-interface-abstract-override-inheritance-implements-a-simple-example/&#34;&gt;[C#] 利用 interface(介面) abstract(抽象) override(覆寫) inherit(繼承) 實作簡單範例 - 從入門到放棄&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接著&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;下一篇&lt;/a&gt;，我們就接著看這一部分的最後一片拼圖：介面吧！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列下一篇：&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@ad57475747/c-%E9%9B%9C%E8%A8%98-%E4%BB%8B%E9%9D%A2-interface-%E6%8A%BD%E8%B1%A1-abstract-%E8%99%9B%E6%93%AC-virtual-%E4%B9%8B%E6%88%91%E8%A6%8B-dc3c5878bb80&#34;&gt;C#雜記 — 介面(interface)、抽象(abstract)、虛擬(virtual)之我見 - Medium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://exfast.me/2016/09/c-sharp-use-interface-abstract-override-inheritance-implements-a-simple-example/&#34;&gt;[C#] 利用 interface(介面) abstract(抽象) override(覆寫) inherit(繼承) 實作簡單範例 - 從入門到放棄&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://matthung0807.blogspot.com/2018/02/java-overload.html&#34;&gt;Java 什麼是多載(Overload), 覆寫(Override), 多型(Polymorphism) - 菜鳥工程師肉豬&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-2_%E5%BB%BA%E6%A7%8B%E5%BC%8Fconstructor%E5%A4%9A%E8%BC%89overloading%E8%88%87%E8%A6%86%E5%AF%ABoverriding/&#34;&gt;Object Oriented物件導向-2:建構式(Constructor)、多載(Overloading)與覆寫(Overriding) - Sian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/csharp/language-reference/keywords/abstract&#34;&gt;Abstract - Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords&#34;&gt;了解使用 Override 和 New 關鍵字的時機 - Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同系列文章&#34;&gt;同系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (5): 多型</title>
      <link>https://igouist.github.io/post/2020/07/oo-5-polymorphism/</link>
      <pubDate>Sun, 12 Jul 2020 23:53:05 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/oo-5-polymorphism/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/65N5R3A.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;多型算是比較三特性之中給人感覺比較溫和的了，不如說只要有了繼承，那麼多型的到來就是必然的。多型的定義是：不同的物件能夠做出一樣的行為，但必須由他們自己的程式碼來實作。&lt;/p&gt;
&lt;p&gt;白話一點說就是：&lt;strong&gt;一樣的事，不同做法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;多型相對是比較好理解的，畢竟每個人做同一件事的方法本來就不太一樣。例如一樣是泡奶茶，英國就正常地泡，&lt;a href=&#34;https://www.ettoday.net/news/20200707/1754177.htm&#34;&gt;美國就會用微波爐&lt;/a&gt;；一樣是肉粽，有些人就是比較愛吃油飯；到了程式的世界裡也是，即使繼承了同一個物件，實現這個行為的方式也可以不同。&lt;/p&gt;
&lt;p&gt;在此可以先推菜鳥工程師肉豬的這篇 &lt;a href=&#34;https://matthung0807.blogspot.com/2018/02/java-overload.html&#34;&gt;Java 什麼是多載(Overload), 覆寫(Override), 多型(Polymorphism)&lt;/a&gt; 中的說明。其中可以從例子看到儘管狗跟鳥都是繼承自動物這個類別，但對於「移動」這個方法，他們實作的方式並不一樣。這就是多型的範例。&lt;/p&gt;
&lt;p&gt;我個人更喜歡用職位的方式去理解多型。&lt;/p&gt;
&lt;p&gt;被繼承者就像是該職位的工作，例如說：&lt;code&gt;Programmer&lt;/code&gt; 要會寫 C#、要會寫 SQL、要會 VB…等等，於是老闆就貼出了徵人啟示，要求新來的員工必須要有 &lt;code&gt;Programmer&lt;/code&gt; 寫的能力：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Programmer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; WriteCSharp()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;/* 努力地寫 C# */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; WriteSQL()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;/* 努力地寫 SQL */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; WriteVB()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;/* 努力地寫 VB */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;補充說明：這邊用到的 &lt;code&gt;virtual&lt;/code&gt; 和 &lt;code&gt;override&lt;/code&gt; 這兩個關鍵字&lt;br/&gt;
我們會在下一篇的&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override/&#34;&gt;覆寫&lt;/a&gt;進行介紹。有興趣的朋友也可以先偷看一眼呦！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;於是今天小華就來面試了，不過他寫的程式碼品質…不怎麼樣。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Hua&lt;/span&gt; : Programmer
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; WriteCSharp()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ShitCode&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; WriteSQL()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ShitCode&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; WriteVB()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ShitCode&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而小華應徵的隔天，小明也開開心心地來應徵了，他不只 C#、SQL 和 VB 都寫得很好，甚至還會泡英式奶茶：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Ming&lt;/span&gt; : Programmer
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; WriteCSharp()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;CleanCode&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; WriteSQL()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;CleanCode&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; WriteVB()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;CleanCode&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Tea MakeTea() 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    { 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Tea(teaName: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;MilkTea&amp;#34;&lt;/span&gt;); 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;火速通過面試之後，老闆就讓小明上工了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Work()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Programmer programmer = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Ming();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    programmer.WriteCSharp(); &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;CleanCode&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    programmer.WriteCSharp(); &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;CleanCode&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    programmer.WriteCSharp(); &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;CleanCode&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;過了幾天後，老闆決定讓小明和小華一起寫同個專案：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; newProject()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Programmer programmer001 = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Ming();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Programmer programmer002 = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Hua();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    programmer001.WriteCSharp(); &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;CleanCode&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    programmer002.WriteCSharp(); &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;ShitCode&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    programmer001.WriteCSharp(); &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;CleanCode&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    programmer002.WriteCSharp(); &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;ShitCode&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這裡也就是多型的核心概念，&lt;strong&gt;用子類別實作出各式各樣不同的方法，藉此讓父類別的方法藉此達到延伸和多樣化的效果&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如說一樣是 &lt;code&gt;Programmer&lt;/code&gt; 的 &lt;code&gt;WriteCSharp()&lt;/code&gt; 這個方法，小明的實現就是 &lt;code&gt;return &amp;quot;CleanCode&amp;quot;;&lt;/code&gt; 而小華的實作方式則是 &lt;code&gt;return &amp;quot;ShitCode&amp;quot;;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;同樣地，最常被舉的例子就是動物。當有動物這個類別時，儘管狗跟貓都繼承了這個類別，但他們都可以對「叫聲」做出不同的實作。&lt;/p&gt;
&lt;p&gt;因為有了多型，動物這個父類別，就能夠藉由子類別來完成擴展。更進一步來說，藉由子類別的擴展，我們能夠&lt;strong&gt;讓父類別做出各式各樣的事，而不需要更動父類別本身&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最常碰到的例子就是資料庫連線。例如說，我們可以讓 &lt;code&gt;MySqlDBConnect&lt;/code&gt; 和 &lt;code&gt;MongoDBConnect&lt;/code&gt; 都繼承 &lt;code&gt;DBConnect&lt;/code&gt;，但各自保有對應不同資料庫的實作。&lt;/p&gt;
&lt;p&gt;如此一來，&lt;code&gt;DBConnect&lt;/code&gt; 就獲得了用不同方法連線到不同資料庫的擴展，得到了對應狀況靈活使用的彈性。同時，使用 &lt;code&gt;DBConnect&lt;/code&gt; 物件的其他物件也可以不用管現在的 &lt;code&gt;DBConnect&lt;/code&gt; 連線是哪個子類別來工作的，只要知道能夠連線並取得資料就好，也達到了以封裝降低耦合的要求。&lt;/p&gt;
&lt;p&gt;以上就是多型的核心。但當我們把子類別塞到父類別的殼裡面使用的時候，還需要注意：這時候的子類別已經是父類別的形狀了&lt;/p&gt;
&lt;p&gt;當我們&lt;strong&gt;將小明宣告成工程師&lt;/strong&gt;這一瞬間，小明已經不再只是小明，對老闆而言他就只是一個工程師，&lt;strong&gt;這裡只剩下「工程師」而不是「小明」&lt;/strong&gt;，是 &lt;code&gt;Programmer&lt;/code&gt; 而不是 &lt;code&gt;Ming&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;Programmer programmer = new Ming()&lt;/code&gt; 執行完畢的同時，這裡就只剩下一個無情的寫程式機器，再也沒有小明。&lt;/p&gt;
&lt;p&gt;當然，小明也不准在上班時間泡英式奶茶，我們不是請你來做這個的！&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Work()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Programmer programmer = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Ming();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    programmer.WriteCSharp();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    programmer.MakeTea(); &lt;span style=&#34;color:#75715e&#34;&gt;// Error: Programmer 未包含 MakeTea 的定義&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這樣只會讓編譯器尷尬地說：請你照我們契約書上面走好嗎？畢竟這裡只剩下 &lt;code&gt;Programmer&lt;/code&gt; 而不是 &lt;code&gt;Ming&lt;/code&gt; 了，一個無情的寫程式機器是不需要，也不會知道怎麼泡英式奶茶的。&lt;/p&gt;
&lt;p&gt;這邊我們就能知道：&lt;strong&gt;當子類別被以父類別的名義建立出來時，他就只能夠表現出父類別的樣子&lt;/strong&gt;。換句話說，我們宣告的是什麼，他就只會做什麼，但要怎麼做倒是沒關係。雖然是一個令人悲傷的故事，但為了遵守&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;封裝&lt;/a&gt;的精神，讓呼叫的物件不需要去了解是誰繼承、又由誰實作等等，為了物件界的秩序，這也是莫可奈何。&lt;/p&gt;
&lt;p&gt;最後再說一聲，大話設計模式用兒子代替爸爸上台表演京劇的例子實在舉得很不錯，有興趣的可以去看看，這例子很能表現出那種披著父親的皮，用著自己的技術，但遮著臉不能被發現的感覺。如此傳神！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;到這邊三大特性就說明完了，雖然我說明的相當模糊籠統，但希望概念能夠傳達到。&lt;/p&gt;
&lt;p&gt;畢竟，就像我開頭引用的，我很喜歡這句「&lt;strong&gt;如果你問 100 個人這個問題，可能會得到 200 個答案，所以你一定要有自己獨到、有自信、精闢的見解或描述方式&lt;/strong&gt;。」像我女友，當我問他物件導向的時候，她（大致上）是這樣說明的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;封裝：醬包跟麵的工作都在泡麵工廠做完了，我們只要拿來泡就好&lt;/li&gt;
&lt;li&gt;繼承：我們可以買了泡麵之後，再自己加蛋加料&lt;/li&gt;
&lt;li&gt;多型：一樣是泡麵，實作出來的口味都不一樣&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;說得我都要去買一碗來煮了。但是，物件是為了貼近我們的現實世界，而每個人的世界觀本來就不一樣。&lt;strong&gt;你必須自己體會，然後才會有自己的觀點&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;至於那些說：你不是說要用卡牌當範例，怎麼突然多了個工程師小明小華？我只能說抱歉，洗澡的時候突然想到的，不寫不舒服。卡牌就想到再補吧，耶嘿。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;下一篇&lt;/a&gt;開始就要進入抽象等等更模糊籠統的部分了，希望還能穩住哪。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列下一篇：&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/initials/2016/06/10/171117&#34;&gt;[心得整理] c# 物件導向程式 - 2.封裝、繼承、多型的三大特性 - 聊聊程式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@totoroLiu/%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-object-oriented-programming-%E6%A6%82%E5%BF%B5-5f205d437fd6&#34;&gt;物件導向(Object Oriented Programming)概念 - Po-Ching Liu - Medium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-3_%E5%B0%81%E8%A3%9Dencapsulation%E7%B9%BC%E6%89%BFinheritance%E8%88%87%E5%A4%9A%E5%9E%8Bpolymorphism/&#34;&gt;Object Oriented物件導向-3:封裝(Encapsulation)、繼承(Inheritance)與多型(polymorphism)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://matthung0807.blogspot.com/2018/02/java-overload.html&#34;&gt;Java 什麼是多載(Overload), 覆寫(Override), 多型(Polymorphism) - 菜鳥工程師肉豬&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tenlong.com.tw/products/9789866761799&#34;&gt;《大話設計模式》附錄：物件導向基礎&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;推薦系列文&#34;&gt;推薦系列文&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同系列文章&#34;&gt;同系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (4): 繼承</title>
      <link>https://igouist.github.io/post/2020/07/oo-4-inheritance/</link>
      <pubDate>Sun, 12 Jul 2020 23:53:04 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/oo-4-inheritance/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/g9FZ3WN.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接著要介紹的是繼承 aka 物件導向三大特性之王 aka 濫用榜 Ko.1 ，繼承的強大幾乎和它的惡名一樣可怕，給一個從聊聊程式的這篇 &lt;a href=&#34;https://dotblogs.com.tw/initials/2016/06/10/171117&#34;&gt;[心得整理] c# 物件導向程式 - 2.封裝、繼承、多型的三大特性&lt;/a&gt; 摘過來的例子就可以略知一二了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/IFV4xjr.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;什麼也不做，僅僅只是繼承而已，就取得了繼承對象（C# 中稱為基底類別）近乎全部的內容，真是太可怕了。在 C# 中，繼承可以取得基底類別除了 &lt;code&gt;Private&lt;/code&gt; 以外所有的內容，例如 &lt;code&gt;Protected&lt;/code&gt; 更是表明就是只給繼承使用的。&lt;/p&gt;
&lt;p&gt;由此可見，在減少重複程式碼的路上，繼承無疑達到了全新的高度。&lt;/p&gt;
&lt;p&gt;那麼繼承代表的是什麼意思呢？大多的網站都能直接說明：&lt;strong&gt;繼承是一種「is-a」的關係。當你能說出Ａ是一個Ｂ的時候，就代表你認為Ａ可以繼承自Ｂ&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最直覺的繼承例子就是&lt;strong&gt;物種的分類&lt;/strong&gt;。舉例來說，狗跟貓都是哺乳類，因此他們都可以繼承到一些哺乳類共通的特徵（例如哺乳、用肺呼吸）。藉由繼承，我們可以把這些哺乳類共有的特徵全部放在哺乳類這個物件，再由狗和貓分別去繼承哺乳類，藉此讓他們都能得到哺乳類的特徵，再進一步發展出自己的特徵和行為，甚至重新定義基底類別的方法為自己所用。因此，像大話設計模式就將繼承說明如：繼承者是對於被繼承者的一種特殊化。&lt;/p&gt;
&lt;p&gt;如此一來，當我們需要修改哺乳類的定義的時候，&lt;strong&gt;只需要修改一個地方，而繼承了哺乳類的這些物件（C# 中稱為衍生類別）全都能夠一起修改到，大大地減少了跑來跑去修改的次數，也讓程式碼的重複大幅度地減少&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;然而也因為如此，繼承最大的惡名出現了：&lt;strong&gt;繼承享受了取用基底類別內容的好處，卻也必須背負牽一髮動全身的風險&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;繼承的特性和封裝有天生的衝突。為了從封裝好的物件之中取得內容，減少程式碼的重複，我們有了繼承，然而這樣無疑破壞了基底類別的封裝，完整地暴露給了衍生類別，兩者之間形成了強&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;耦合&lt;/a&gt;的關係。&lt;/p&gt;
&lt;p&gt;對於衍生類別而言，它必須依賴著基底類別，倘若哪天基底類別的屬性變更了，例如型別或名稱有變動，那麼所有衍生類別使用到的地方都會受到影響，這時候在程式碼裡的修改規模，將會隨著繼承的濫用程度提升，達到一個相當龐大的地步。&lt;/p&gt;
&lt;p&gt;事實上，這是相當好理解的。我們藉由哺乳類去繼承出了狗科跟貓科兩個類別；那麼假設我們時光回溯，重新改變了哺乳類的演化過程，今天的哺乳類變成了三隻腳而且還有翅膀，那麼後面演化出來的狗跟貓又會怎麼樣呢？&lt;strong&gt;直接修改源頭，對後續的衍生者而言無疑是相當大的災難&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;同時由於繼承的方便和概念實在相當廣泛，因此也經常被胡亂使用。我個人就遇過專案之中，前人為了讓某個類別擁有各式各樣的方法，先後繼承了數學運算、連線至資料庫、畫面上的資料處理等等數個類別，形成一條既長又龐大的繼承鏈，最終達到了無法修改的地步。&lt;/p&gt;
&lt;p&gt;沒有人知道這個合成怪獸是來做什麼的，這種&lt;a href=&#34;https://en.wikipedia.org/wiki/God_object&#34;&gt;神之物件&lt;/a&gt;搖身一變就變成滅世主宰，實在是相當恐怖。&lt;/p&gt;
&lt;p&gt;因此對於繼承，前輩們通常只有一種叮囑：&lt;strong&gt;謹慎使用，或是乾脆不要用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;對於繼承的概念，這邊推薦可以看看，&lt;a href=&#34;https://milikao.pixnet.net/blog/post/543592&#34;&gt;到底誰該去繼承誰？ 物件導向初學者應該要知道的事情(三)&lt;/a&gt; 這篇從圓和橢圓的各種繼承方式切入，很仔細地講解了不同思路使用繼承遇到的問題，尤其是示範完直覺的做法之後展示經典的段落相當重要。&lt;/p&gt;
&lt;p&gt;另外，我們在後續的&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;里氏替換原則&lt;/a&gt;也會提到繼承需要注意的一些問題，此處暫且按下不表。&lt;/p&gt;
&lt;p&gt;那麼我們就回到卡牌的例子：&lt;/p&gt;
&lt;p&gt;假使我們的卡牌現在有了功能卡，這類卡牌在遊戲王叫做魔法卡，而在爐石稱之為法術，雖然這也是一種卡片，但和前面提過的戰士和怪獸等等顯然完全不同。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MagicCard&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; Name;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Cost; &lt;span style=&#34;color:#75715e&#34;&gt;// 資源花費&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Magic Effect; &lt;span style=&#34;color:#75715e&#34;&gt;// 法術效果&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; _description;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; MagicCard() { &lt;span style=&#34;color:#75715e&#34;&gt;/* 建構式 */&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; Description { &lt;span style=&#34;color:#75715e&#34;&gt;/* set; get; */&lt;/span&gt;} 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;魔法卡並沒有攻擊力和生命值，只有對應的法術效果。同時，我們發現卡牌有資源花費的需要，像是爐石戰記或是殺戮尖塔這類有資源的遊戲，打出卡片的時候會需要花費水晶等資源，藉此限制玩家一回合內能使用的策略。&lt;/p&gt;
&lt;p&gt;現在我們明顯可以發現兩個問題：這兩個種類的卡片，都是卡片呀！而且，內容有一半都是重複的。這是我們該使用繼承的時機了。&lt;/p&gt;
&lt;p&gt;首先我們將原本的卡片更改為 怪獸卡。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MonsterCard&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; Name;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Cost;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Attack;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Health;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; _description;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; MonsterCard() { &lt;span style=&#34;color:#75715e&#34;&gt;/* 建構式 */&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; Description { &lt;span style=&#34;color:#75715e&#34;&gt;/* set; get; */&lt;/span&gt;} 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Hit(MonsterCard target) { &lt;span style=&#34;color:#75715e&#34;&gt;/* 一些痛揍其他怪獸卡的方法 */&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接著我們開始設計基底類別：卡片。我們可以觀察到，怪獸卡和魔法卡相同的部分有：名稱、敘述和卡片花費。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Card&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Cost;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; _description;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; Description { &lt;span style=&#34;color:#75715e&#34;&gt;/* set; get; */&lt;/span&gt;} 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;將原本的怪獸卡和魔法卡改成繼承自卡片類別，並且將重複的部份移除，直接取用基底類別的內容就好。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MonsterCard&lt;/span&gt; : Card
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Attack;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Health;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; MonsterCard() { &lt;span style=&#34;color:#75715e&#34;&gt;/* 建構式 */&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Hit(MonsterCard target) { &lt;span style=&#34;color:#75715e&#34;&gt;/* 一些痛揍其他怪獸卡的方法 */&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MagicCard&lt;/span&gt; : Card
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Cost;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Magic Effect;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; MagicCard() { &lt;span style=&#34;color:#75715e&#34;&gt;/* 建構式 */&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到我們在 C# 的繼承方式是使用 &lt;code&gt;類別 : 基底類別&lt;/code&gt; 的方式來宣告。並且也能發現，怪獸卡的內容變簡潔了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; goblin = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; MonsterCard(name: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;哥布林&amp;#34;&lt;/span&gt;, attack: &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, health: &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; warrior = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; MonsterCard(name: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;戰士&amp;#34;&lt;/span&gt;, attack: &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, health: &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;warrior.Description = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;他是一個專殺哥布林的戰士！&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;warrior.Hit(goblin);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;並且在使用上也沒有任何差錯，我們仍然能給予怪獸卡名字和敘述。&lt;/p&gt;
&lt;p&gt;當然在實際的卡牌遊戲中，魔法卡還能細分出更多種類，因此魔法卡類別還能再被一些更細的分類，例如指向法術等等去繼承，形成如同樹狀的繼承關係，如同物種演化一般。&lt;/p&gt;
&lt;p&gt;繼承的段落也快結束了，這邊再次叮嚀一番：&lt;strong&gt;除非你很確定，否則請不要使用繼承&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;繼承帶來了相當大的好處，減少的重複程式碼量號稱三特性之冠；但同時他帶來的後果也是最嚴重的，堪稱三特性中的擊墜之王，鏖殺了數以萬計濫用和誤用的工程師…和維護他們系統的工程師，不可不慎。&lt;/p&gt;
&lt;p&gt;但如果已經看到了這裡，還請你先記著繼承的概念，在不遠處的將來你將會遇到他那不太像又有點像的兄弟：介面。這邊就先打住。&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;下一篇&lt;/a&gt;就讓我們繼續來看三特性的末席：多型吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列下一篇：&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10204633&#34;&gt;不要造神 (神一般的物件) - 可不可以不要寫糙 code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://milikao.pixnet.net/blog/post/543592&#34;&gt;到底誰該去繼承誰？ 物件導向初學者應該要知道的事情(三)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@ChunYeung/%E4%BB%80%E9%BA%BC%E6%98%AFoo-%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%88%87%E7%B9%BC%E6%89%BF-6955239576af&#34;&gt;什麼是OO？物件導向與繼承 - Chun Yeung - Medium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/initials/2016/06/10/171117&#34;&gt;[心得整理] c# 物件導向程式 - 2.封裝、繼承、多型的三大特性 - 聊聊程式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@totoroLiu/%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-object-oriented-programming-%E6%A6%82%E5%BF%B5-5f205d437fd6&#34;&gt;物件導向(Object Oriented Programming)概念 - Po-Ching Liu - Medium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/csharp/tutorials/inheritance&#34;&gt;C# 和 .NET 中的繼承 - Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tenlong.com.tw/products/9789866761799&#34;&gt;《大話設計模式》附錄：物件導向基礎&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;推薦系列文&#34;&gt;推薦系列文&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同系列文章&#34;&gt;同系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (3): 封裝</title>
      <link>https://igouist.github.io/post/2020/07/oo-3-encapsulation/</link>
      <pubDate>Sun, 12 Jul 2020 23:53:03 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/oo-3-encapsulation/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/cc9DLDo.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;封裝包含了兩個重要的觀念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;控制物件和外部進行互動的出入口&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隱藏物件內部的細節資訊&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;強者我同事整理的&lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-3_%E5%B0%81%E8%A3%9Dencapsulation%E7%B9%BC%E6%89%BFinheritance%E8%88%87%E5%A4%9A%E5%9E%8Bpolymorphism/&#34;&gt;文章&lt;/a&gt;裡的例子就舉得不錯：當你按下鍵盤的Ａ鍵，螢幕隨即出現了Ａ，你不必知道中間發生了什麼事，你只需要知道怎麼操作和最後得到什麼就可以了。&lt;/p&gt;
&lt;p&gt;其中鍵盤提供的按鍵，就是我們對電腦進行互動的出入口；而電腦實際上做了什麼事情，也被隱藏了起來，讓我們只需要關注結果就好。&lt;/p&gt;
&lt;p&gt;此外我也看到過販賣機的例子，&lt;strong&gt;當你去販賣機買飲料，你也不需要知道裡面的構造，只要知道你選了飲料投了錢，飲料就會跑出來就行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;從上面的兩個例子，相信大家已經掌握到封裝的概念了：&lt;strong&gt;將物件視作一個整體，把內部的實作內容隱藏起來，讓使用者只需要知道怎麼使用這個物件即可。&lt;/strong&gt;（相似的思路，我們後續的&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;介面&lt;/a&gt;會再提到）&lt;/p&gt;
&lt;p&gt;如果封裝做得夠好，除了可以將程式碼整理得井井有條以外，也能讓物件內部的修改不會直接影響到使用物件的地方，達成了降耦合的目標&lt;/p&gt;
&lt;p&gt;並且也能讓物件的使用者直覺地知道如何使用物件提供的方法，如此使用者就可以專注在更高層次的抽象，而不用被物件內部的細節所干擾。&lt;/p&gt;
&lt;p&gt;最後，從上面的敘述中我們可以察覺到要實現封裝，最重要的就是：&lt;strong&gt;對外的開放程度（存取範圍）的控制&lt;/strong&gt;。或是套一句前輩的說法：&lt;strong&gt;給程式碼隱私的空間&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;補充：如果想問「什麼是耦合？」的朋友，建議可以看看這篇：&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10203659&#34;&gt;實務上的高內聚與低耦合&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;或是參照本系列後續的 &lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;內聚與耦合&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;存取範圍與存取子&#34;&gt;存取範圍與存取子&lt;/h2&gt;
&lt;p&gt;先讓我們從存取範圍開始說起吧，因為我個人慣用的是 C#，因此就介紹一下 C# 是怎麼控制存取範圍的。&lt;/p&gt;
&lt;p&gt;在 C# 之中，類別裡控制可見度是使用修飾子來定義存取範圍，也就是當我們替類別宣告欄位時常看到的 &lt;code&gt;Public&lt;/code&gt; 和 &lt;code&gt;Private&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Public&lt;/code&gt;: 這是公開的，所有人都看得到&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Private&lt;/code&gt;: 這是私有的，只有自己看得到&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了最常用的這兩個以外，還有其他的修飾子可以先知道一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Protected&lt;/code&gt;: 這是受到保護的，只有自己和繼承的孩子們看得到&lt;/li&gt;
&lt;li&gt;&lt;code&gt;internal&lt;/code&gt;: 這是內部的，只有身為同一個組件的朋友們看得到&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Protected internal&lt;/code&gt;：組合上面兩個，也就是可以給同個組件的朋友們，或是其他組件繼承的孩子們看見&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下來的部分會以最常見的 &lt;code&gt;Public&lt;/code&gt; 和 &lt;code&gt;Private&lt;/code&gt; 來繼續說明，對存取範圍的這些修飾子有興趣的朋友，可以參照 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/csharp/language-reference/keywords/accessibility-levels&#34;&gt;存取範圍層級&lt;/a&gt; 的說明。&lt;/p&gt;
&lt;p&gt;現在我們已經知道了有哪些修飾子可以用來控制存取範圍，但為什麼我們會需要宣告存取範圍的大小呢？其根本是為了&lt;strong&gt;將控制權掌握在物件本身&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;就像大話設計模式比喻的：物件就像間房子，我們不希望被看光光，可以看見的 &lt;code&gt;Public&lt;/code&gt; 就像門和窗，而不該看見的 &lt;code&gt;Private&lt;/code&gt; 則是用牆壁隱藏起來，而對於這間房子而言，門窗是可以控制的。&lt;/p&gt;
&lt;p&gt;對於這部分的範例，我覺得 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/csharp/programming-guide/classes-and-structs/using-properties&#34;&gt;微軟文件的範例&lt;/a&gt; 裡設定月份的區塊已經能很清楚表達了。但為了這篇文章的一致性，還是硬擠著一個範例出來：&lt;/p&gt;
&lt;p&gt;某一天，我們突然決定讓使用者可以傳入卡牌敘述了，但是卡牌上能顯示的字數有限，只能顯示 30 個字，因此首先我們先把卡牌敘述改成私有的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Card&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; Name;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Level;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Attack;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Health;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; _description; &lt;span style=&#34;color:#75715e&#34;&gt;// 更改為私有的&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/* 一些其他方法 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;呃可能第一步就會讓人有些疑惑：「啊你要給人家傳東西進來還改私有？」但等等，且聽我娓娓道來：&lt;strong&gt;C# 中的屬性，是用 &lt;code&gt;Set&lt;/code&gt; 和 &lt;code&gt;Get&lt;/code&gt; 兩個方法去存取的&lt;/strong&gt;，又稱做&lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/csharp/programming-guide/classes-and-structs/restricting-accessor-accessibility&#34;&gt;存取子&lt;/a&gt;。這兩個看門仔也就擔當了房屋的門窗、出入境時的海關、古代大戰中的關隘這類「控制進出通道」的角色。&lt;/p&gt;
&lt;p&gt;現在讓我們試著規劃出我們的門和窗，在上面的例子中，我們想要當卡牌的敘述進來時，保持在 30 個字：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Card&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 略&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; _description;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; Description
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;value&lt;/span&gt;.Length &amp;gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; &lt;span style=&#34;color:#66d9ef&#34;&gt;value&lt;/span&gt;.Length &amp;lt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;._description = &lt;span style=&#34;color:#66d9ef&#34;&gt;value&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; System.Exception(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;就跟你說限 30 個字看不懂喔！&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;._description;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/* 一些其他方法 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如此一來我們就能對存取屬性時的行為進行管控囉。&lt;/p&gt;
&lt;p&gt;那可能有些朋友會有疑惑：那為什麼我不能直接對外開放卡牌敘述，然後修改的時候檢查完再傳進來 set 就好了呢？這個就牽涉到一些「改太多地方了我要死啦」的悲情故事，這邊再舉個例子給大家體會一下。&lt;/p&gt;
&lt;p&gt;例如說，我們的卡片現在加入了戰力指數系統，這個戰力是預先從卡片的各項資訊計算好，並存放在資料庫的。而且因為計算的關係可能有小數點後十位之類的，那我們拿出來的時候可能會長這樣：&lt;code&gt;Power: 99.256256&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;而在建立類別的時候，也很自然地選用了 &lt;code&gt;double&lt;/code&gt; 來處理，於是現在類別就長這樣：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Card&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; Power;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這個系統上線運行了一段時間之後，突然上頭來了需求：請把所有顯示到卡片敘述的地方都改成小數點後兩位就好。&lt;/p&gt;
&lt;p&gt;假設我們不能直接修改從資料表取出來時的數值（或是已經改了然後被前輩電）因為記 Log 或是什麼戰力對決(?)功能還會需要用到原本的戰力數值之類的理由，因此物件存放的戰力數值必須和資料表中的一致等等，總之不允許改資料&lt;/p&gt;
&lt;p&gt;如果先前直接開放存取，那麼這下子要改的地方就變成「所有使用到這個屬性的地方」，再要是當場看到 Visual Studio 上面寫：&lt;code&gt;99 個參考&lt;/code&gt;，那可能當場整個腦子就直接下班了。&lt;/p&gt;
&lt;p&gt;但如果我們是使用 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 的方式去處理的話，那麼我們只需要修改 &lt;code&gt;get&lt;/code&gt; 存取子的規則，讓它讀取的時候幫忙四捨五入到小數點第二位就好了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Card&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{   
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; _power;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; Power 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    { 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt; { &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;._power = &lt;span style=&#34;color:#66d9ef&#34;&gt;value&lt;/span&gt;; } 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt; { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Math.Round(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;._power, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這樣應該就能看出使用 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 去把攔位封裝起來的好處了，也就是：&lt;strong&gt;把「資料進出時加以處理的主導權」留在物件本身&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而在 C# 裡，如果你並沒有（或是說「還沒有」）要特別針對存取另做額外處理，可以直接使用&lt;strong&gt;自動實作&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; Description { &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這樣實際上就會自動幫你建立一個私有屬性，並且只能經由這個公開屬性的 &lt;code&gt;set&lt;/code&gt; 和 &lt;code&gt;get&lt;/code&gt; 進行存取。&lt;/p&gt;
&lt;p&gt;藉由自動實作來簡化寫法之後，例如唯讀就可以這樣寫：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; Description { &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或是&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; Description { &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用自動實作時，若要加上預設值的話請這樣寫&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; Description { &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;; } = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;這是一張卡牌。&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以說是方便很多。將來如果要針對設值給值的地方進行修改，也會比較方便一點。&lt;/p&gt;
&lt;p&gt;稍微了解了上面提到的存取範圍、存取子、自動實作這些工具之後，現在，我們就可以決定外部的使用者能看到物件的哪些部份了。&lt;/p&gt;
&lt;h2 id=&#34;隱藏複雜度&#34;&gt;隱藏複雜度&lt;/h2&gt;
&lt;p&gt;當然，封裝的概念並不僅僅只是對屬性定義存取範圍如此而已，&lt;strong&gt;提高類別內的內聚性，降低對外的耦合性，隱藏複雜資訊才是最重要的方針&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;也就是說，我們需要妥善地運用「把大的類別和方法切割成小的類別和方法」、「活用存取範圍，對外隱藏複雜資訊、對內切割成各個工作的私有方法」等等技巧，才能夠更接近完善的封裝一點。然而這只能在設計時，或是維護到頭痛才能親自體會了。&lt;/p&gt;
&lt;p&gt;接續著上面的技巧來說：&lt;strong&gt;當你面對在一個公開方法中需要處理一長串的商業邏輯，以至於需要將他們切割成數個小函式時，將它們宣告成 &lt;code&gt;Private&lt;/code&gt; 就是相當好的選擇&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如說，我們有個連線到資料庫取得客戶資料的方法（可能是 &lt;code&gt;UserRepository.Get(int UserId)&lt;/code&gt; 這種感覺），可能我們除了 &lt;code&gt;Public&lt;/code&gt; 的 &lt;code&gt;Get&lt;/code&gt; 方法以外，還有一些 &lt;code&gt;Private&lt;/code&gt; 的 &lt;code&gt;ConnectDB&lt;/code&gt; 等輔助方法。&lt;/p&gt;
&lt;p&gt;這意味著這些工具僅讓你的物件內部使用，外面的人不應該直接調用其中的任何功能，同時又能幫助你的主要流程變得更簡潔，提升維護和修改時的速度。&lt;/p&gt;
&lt;p&gt;同時以資料庫的例子來說：&lt;strong&gt;呼叫這個函式的使用端不需要知道這個函式是怎麼連線到資料庫的，又是怎麼搜尋出資料的，只需要知道呼叫了之後能拿到客戶資料就好&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;兩個物件之間「知道」得越多，其耦合就越高。替換和修改時互相牽連的機會和規模也越大，因此封裝可以說是物件導向的基石也不為過。封裝的好或不好（亦即物件是否足夠內聚，其職責是否單一，暴露內部資訊的多寡等等），直接關係到整個架構的優劣，不可謂不慎。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;補充：封裝的核心在於「隱藏複雜資訊」。而我們前段所提到需要注意的幾個部份：&lt;/p&gt;
&lt;p&gt;「物件是否內聚」可以參照 &lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;「職責是否單一」可以參照 &lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這些概念之間彼此相扣，此處就先按下不表。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;小結&#34;&gt;小結&lt;/h2&gt;
&lt;p&gt;封裝的部分就講到這裡，並不是很難理解，但是要封裝得好，或是說知道怎樣才算封裝得好，還是需要經驗，不是我這種菜雞一時半刻能理得白說得清的，之後有心得再和大家分享。&lt;/p&gt;
&lt;p&gt;封裝、繼承、多型並稱物件導向三大特性，我們也會按照這個順序快速地介紹。接著我們就繼續來看 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;繼承&lt;/a&gt; 吧！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列下一篇：&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;延伸閱讀：&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10203659&#34;&gt;實務上的高內聚與低耦合 - 可不可以不要寫糙 code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@ChunYeung/%E4%BB%80%E9%BA%BC%E6%98%AFoo-%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%88%87%E5%B0%81%E8%A3%9D-80379c24e62&#34;&gt;什麼是OO？物件導向與封裝 - Chun Yeung - Medium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-3_%E5%B0%81%E8%A3%9Dencapsulation%E7%B9%BC%E6%89%BFinheritance%E8%88%87%E5%A4%9A%E5%9E%8Bpolymorphism/&#34;&gt;Object Oriented物件導向-3:封裝(Encapsulation)、繼承(Inheritance)與多型(polymorphism) - Sian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/initials/2016/06/10/171117&#34;&gt;[心得整理] c# 物件導向程式 - 2.封裝、繼承、多型的三大特性 - 聊聊程式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ithome.com.tw/node/45903&#34;&gt;思考物件導向(1)物件導向與封裝 - 蔡學鏞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@totoroLiu/%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-object-oriented-programming-%E6%A6%82%E5%BF%B5-5f205d437fd6&#34;&gt;物件導向(Object Oriented Programming)概念 - Po-Ching Liu - Medium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tenlong.com.tw/products/9789866761799&#34;&gt;《大話設計模式》附錄：物件導向基礎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aihuadesign.com/2020/03/16/access-modifiers-c-sharp/&#34;&gt;Public? Private? 比較各種修飾詞存取範圍 – 理工宅 Nelson&amp;rsquo;s Diary (aihuadesign.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/csharp/language-reference/keywords/accessibility-levels&#34;&gt;存取範圍層級 - C# 參考 | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/csharp/programming-guide/classes-and-structs/restricting-accessor-accessibility&#34;&gt;限制存取子的存取範圍 - C# 程式設計手冊 | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;推薦系列文&#34;&gt;推薦系列文&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同系列文章&#34;&gt;同系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (2): 建構式、多載</title>
      <link>https://igouist.github.io/post/2020/07/oo-2-constructor-overload/</link>
      <pubDate>Sun, 12 Jul 2020 23:53:02 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/oo-2-constructor-overload/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/naCjLay.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我就直接說了，有用前面的程式碼區塊的人，絕對執行不了。因為我們建立哥布林和戰士這兩張卡片的時候，根本就沒有給他們數值呀！&lt;/p&gt;
&lt;p&gt;雖然可以先呼叫出來再賦值…&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; goblin = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Card();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;goblin.Name = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;哥布林&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;goblin.Attack = &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;goblin.Health = &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* ...其他賦值 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這實在相當占空間，也有點奇怪。畢竟如果是阿福（狗），一出生的時候應該就確定了一些特徵才對，例如品種、血型、眼睛顏色這種。並不會出生後過一陣子，才突然決定這些東西，既然如此，我們在產生物件的時候，當然也會希望在&lt;strong&gt;建立的同時就先決定好一部份內容&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這時候我們就可以藉由&lt;strong&gt;建構式&lt;/strong&gt;的方式，在建立物件時就進行一些我們想要的操作。&lt;/p&gt;
&lt;h2 id=&#34;建構式&#34;&gt;建構式&lt;/h2&gt;
&lt;p&gt;事實上，&lt;strong&gt;當我們呼叫 &lt;code&gt;new Card()&lt;/code&gt; 的時候&lt;/strong&gt;（不覺得這個 () 很有呼叫方法的感覺嗎？）&lt;strong&gt;我們就是正在調用 Card 的建構式&lt;/strong&gt;。而當我們沒有特別去定義建構式的時候，就會直接使用內建的建構式去幫我們產生物件。&lt;/p&gt;
&lt;p&gt;現在我們替 Card 新增一個建構式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Card&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Card (&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; name, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; attack, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; health)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Name = name;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Attack = attack;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Health = health;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/* ... 其他屬性和方法 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 C# 的時候，建構式必須和類別同名，且不需要定義回傳類型。當我們有了建構式，剛剛的例子就可以改寫成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; goblin = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Card(name: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;哥布林&amp;#34;&lt;/span&gt;, attack: &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, health: &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; warrior = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Card(name: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;戰士&amp;#34;&lt;/span&gt; , attack: &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, health: &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;warrior.Hit(goblin);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;建構式也就是建立這個物件時執行的函式&lt;/strong&gt;，通常會用來進行初始化，也就是做一些建立物件必要的準備。例如傳遞必要屬性或是建構需要的其他物件、或是給予私有屬性初始值等等，例如說我們的卡牌一建立，就會需要知道它的名字和戰鬥力，這樣才有卡牌的感覺，而不該像一些 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%AD%A6%E8%97%A4%E9%81%8A%E6%88%B2&#34;&gt;壞決鬥者&lt;/a&gt; 邊打牌邊偷偷印卡。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;註：當然有建立時執行的，也就會有消滅時執行的。請參見 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/csharp/programming-guide/classes-and-structs/destructors&#34;&gt;解構式&lt;/a&gt;，由於較少用到，此處先按下不表。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;多載&#34;&gt;多載&lt;/h2&gt;
&lt;p&gt;當然，有了建構式就會有更多問題。現在我們只有一個方法可以建立卡牌了，這無疑是相當不彈性的，例如說我希望預設的攻擊力和血量就是四呢？實際上我們經常會遇到需要用不同素材去建立一個物件的場合，這時候就必須得提到另一個要點：多載了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多載指的就是可以有很多個同樣名字的方法，各自去接不同的參數&lt;/strong&gt;。例如說我們的 Card 建構式就可以利用多載來改造一下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Card&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Card (&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; name, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; attack, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; health)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Name = name;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Attack = attack;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Health = health;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Card (&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; name)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Name = name;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Attack = &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Level;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Health = &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Level;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Card ()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Name = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Noname&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Attack = &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Level;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Health = &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Level;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如此一來，我們在建立卡片的時候就能夠有更多選擇了，現在我們可以根據狀況給予需要的參數，剩下的就交給建構式去處理就好。&lt;/p&gt;
&lt;p&gt;實務上，如果規則或是建立的步驟一致的話，為了能夠把規則集中到一個地方方便修改，並且減少多餘的程式碼。我們通常會試著讓其他的建構式去呼叫主要的建構式，在 C# 中，呼叫自己的建構式是使用 &lt;code&gt;: this()&lt;/code&gt; 來進行的，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Card (&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; name, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; attack, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; health)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Name = name;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Attack = attack;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Health = health;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 會呼叫上面那個建構式&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Card (&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; name) : &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;(name: name, attack: &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, health: &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 呼叫完 Card(name, attack, health) 之後做的事&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 會呼叫上面那一個建構式&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Card () : &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;(name: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Noname&amp;#34;&lt;/span&gt;) 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 呼叫完 Card(name) 之後做的事   &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如此一來只要建構的方式有變更，我們只需要集中修改第一個建構式就好了。這部份的流程也可以參照 &lt;a href=&#34;https://dotblogs.com.tw/yc421206/2011/07/25/32097&#34;&gt;[C#.NET] 為建構子建立正確的初始化 - 余小章 @ 大內殿堂&lt;/a&gt; 這篇的說明。&lt;/p&gt;
&lt;p&gt;當然多載也不只是用在建構子，而是大多數時候都可以用的寫法。例如當你的函式&lt;strong&gt;雖然做同樣的事，但允許接收不同的參數來處理時，就請考慮使用多載&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如說當你要記錄發生錯誤時的 Log ，就能允許只傳遞錯誤內容，或是傳遞錯誤內容和當時操作的參數，甚至是當下的環境資料等等。&lt;/p&gt;
&lt;p&gt;又或者是查詢客戶資料（GetUser 之類的）的函式，提供使用 客戶代號，或是 訂單編號 等不同的方式進行查詢時，就可以考慮多載的應用。&lt;/p&gt;
&lt;p&gt;例如說 .net 中協助類別對映的名套件 &lt;a href=&#34;https://igouist.github.io/post/2020/07/automapper&#34;&gt;AutoMapper&lt;/a&gt;，在轉換類別的 Map 方法就很漂亮地使用了多載：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/DAgNTwc.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;註：看不到圖片的可以直接看 &lt;a href=&#34;https://github.com/AutoMapper/AutoMapper/blob/master/src/AutoMapper/Mapper.cs&#34;&gt;Github&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;當然隨著多載的應用越來越稀鬆平常，時至今日，我們只要使用&lt;strong&gt;選擇性參數&lt;/strong&gt;就可以輕鬆達到一樣的效果囉：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Card (&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; name = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Noname&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; attack = &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; health = &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Name = name;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Attack = attack;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Health = health;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;當有預設值的時候，該參數就會變成可選的，這時候就可以輕鬆決定要傳進來的內容了。當然，如果傳進來的並非只是數量上的差別，而是整個型別都不一樣的話，還是要回歸到多載的做法，建立兩個同名但不同傳入參數類型的方法，可讀性會比較高呦。&lt;/p&gt;
&lt;p&gt;多載提供的好處在於：&lt;strong&gt;同個目標的函式可以根據傳入的參數不同做不一樣的處理&lt;/strong&gt;。例如當我們寫了一個連線取資料的方法，可以分為&lt;/p&gt;
&lt;p&gt;(1) 傳入連線的話，就使用連線取得資料&lt;/p&gt;
&lt;p&gt;(2) 傳入連線字串的話，就先用連線字串開啟連線，再使用連線取得資料&lt;/p&gt;
&lt;p&gt;等等，根據參數的場合來進行處理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;藉由傳入不同的參數類型和數量，就可以處理不同狀況的內容，既擴展了函式在使用上的彈性，同時也增加函式能派上用場的時機&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而最重要的是這將讓編寫程式的人員去思考：&lt;strong&gt;我設計的這個方法將能應用在什麼場景？&lt;/strong&gt; 這將會成為一個相當優良的習慣。&lt;/p&gt;
&lt;p&gt;那麼這次就說到這裡，我們&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;下篇&lt;/a&gt;見！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列下一篇：&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://matthung0807.blogspot.com/2018/02/java-overload.html&#34;&gt;Java 什麼是多載(Overload), 覆寫(Override), 多型(Polymorphism) - 菜鳥工程師肉豬&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-2_%E5%BB%BA%E6%A7%8B%E5%BC%8Fconstructor%E5%A4%9A%E8%BC%89overloading%E8%88%87%E8%A6%86%E5%AF%ABoverriding/&#34;&gt;Object Oriented物件導向-2:建構式(Constructor)、多載(Overloading)與覆寫(Overriding) - Sian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/yc421206/2011/07/25/32097&#34;&gt;[C#.NET] 為建構子建立正確的初始化 - 余小章 @ 大內殿堂&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://adon988.logdown.com/posts/1185453-c-destructors-teaching-notes-using-visual-studio&#34;&gt;C# 解構子 Destructors - 教學筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tenlong.com.tw/products/9789866761799&#34;&gt;《大話設計模式》附錄：物件導向基礎&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同系列文章&#34;&gt;同系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (1): 類別、物件</title>
      <link>https://igouist.github.io/post/2020/07/oo-1-class-object/</link>
      <pubDate>Sun, 12 Jul 2020 23:53:01 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/oo-1-class-object/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/TIEIXm5.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;直覺上你當然知道什麼是物件；物件就在你的身邊。&lt;/p&gt;
&lt;p&gt;汽車、iPhone、收音機、吐司機、廚房用具等等，你說得出來的都是。&lt;/p&gt;
&lt;p&gt;　　——《深入淺出學會編寫程式》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;什麼是物件？一切都是物件。&lt;/p&gt;
&lt;p&gt;物件導向試圖讓抽象的程式碼，更貼近於我們的實際生活，其認為一切是由各式各樣的人事物互動所組成的，因此有了物件這個共通、最基本的概念。&lt;/p&gt;
&lt;p&gt;假設現實世界存在一頭狗，叫做阿福。而我們想要在虛擬世界裡表達「有一隻叫做阿福的狗」這件事&lt;/p&gt;
&lt;p&gt;這時候就要在系統裡有一個能代表「阿福（狗）」的東西存在，也就是「阿福」這個物件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;關於「把現實世界的物件，抽象化成程式世界裡的物件」的邏輯，可以參考 &lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10201905&#34;&gt;一個語言如果不改變你的思考方式，就不值得學？談程式語言的本質&lt;/a&gt; 這篇，尤其是選擇保留哪些資訊的部份我認為描述得很好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;現在我們知道，&lt;strong&gt;物件就是用來在虛擬世界中代表「某個特定的東西」&lt;/strong&gt;，例如說叫做阿福的狗就是一個物件，阿福今天晚上要吃的飼料罐也是一個物件。&lt;/p&gt;
&lt;p&gt;理解物件的概念是相當直覺且迅速的，畢竟你我身邊有著數不清的東西，它們都是一件一件的物件，但這樣的理解還不夠明確。&lt;/p&gt;
&lt;p&gt;就像前文所引的 &lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10201905&#34;&gt;談程式語言的本質&lt;/a&gt; 文中所提到的，在抽象化的同時我們必然要選擇保留哪些資訊。&lt;/p&gt;
&lt;p&gt;例如說阿福這隻狗，是一個物件；飼料罐也是一個物件&lt;/p&gt;
&lt;p&gt;而這些物件之間還會彼此互動，例如說阿福是一隻狗，而我們觀察到狗都有吃東西這個&lt;strong&gt;動作&lt;/strong&gt;，例如「阿福吃了飼料」&lt;/p&gt;
&lt;p&gt;同時物件也會有一些專屬於它的&lt;strong&gt;特徵&lt;/strong&gt;，例如說阿福是黑色的，我們就知道狗有毛色的差別。&lt;/p&gt;
&lt;p&gt;那麼我們要怎麼表達「阿福」作為一隻「狗」擁有的那些動作和特徵呢？狗的毛色？狗可以吃飼料？&lt;/p&gt;
&lt;p&gt;我們需要選擇怎麼去描述「狗」－－也就是阿福這隻狗，被我們抽象化後的樣子，我們需要將它用程式碼的方式定義出來。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;這時候我們就會需要類別，來定義出我們觀察到同一類的物件該有哪些特徵和動作，也就是我們替物件「分門別類」後、篩選出特定資訊的抽象化結果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;延續前面的例子，假設今天我們從阿福身上觀察到進食跟毛色兩個狗的重要資訊，我們就可以建立類別 Dog：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Dog&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; color;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Eat(IFood food) { &lt;span style=&#34;color:#75715e&#34;&gt;/* 進食與消化之類的 */&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;藉由我們定義的類別，就可以從類別中實例化（＝建立）出物件。&lt;/p&gt;
&lt;p&gt;也就是說，現在我們終於可以用「狗」這個類別，來表達出我們需要的「阿福」了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Dog afu = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Dog(); &lt;span style=&#34;color:#75715e&#34;&gt;// 阿福是一隻狗&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Console.Write(afu.Color); &lt;span style=&#34;color:#75715e&#34;&gt;// 阿福是黑色的&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;afu.Eat(food); &lt;span style=&#34;color:#75715e&#34;&gt;// 阿福會吃食物&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;類別最常看到的比喻，就是物件的設計圖。我們藉由類別去定義我們要的物件有什麼特徵、有什麼功能，再從類別根據設計圖產生物件出來使用。&lt;/p&gt;
&lt;p&gt;這個從類別中產生的物件，就等於是這個類別定義的一個實際的例子，所以我們也會把類別產生的物件叫做&lt;strong&gt;實例&lt;/strong&gt;。而從類別產生物件的過程，就叫做實例化。&lt;/p&gt;
&lt;p&gt;也就是說，類別實際上就是我們認知中對這個物件的定義，我們篩選出&lt;strong&gt;我們需要的、我們認為這個物件應該具有的這些特徵和功能&lt;/strong&gt;，按照我們的認知去設計了類別&lt;/p&gt;
&lt;p&gt;接著我們再利用這個類別告訴程式如何建立出我們認為的這個物件，最終我們才能在程式中使用我們需要的這個物件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;當我們定義了一個狗的類別，我們實際上是在描述我們眼中的、我們歸納出來的、我們需要的「狗」&lt;/strong&gt;，我們認為狗就是會吃東西。&lt;/p&gt;
&lt;p&gt;接著，&lt;strong&gt;我們再從我們設計好的這份定義，去實例化出我們需要的狗：阿福&lt;/strong&gt;，於是阿福就有了吃東西的能力。&lt;/p&gt;
&lt;p&gt;我們有了抽象化的設計圖之後，就可以利用這個設計圖去建立多個符合這個設計的物件。例如說前面的狗，我們就可以建立出黑色的阿福，黃色的阿黃等等。&lt;/p&gt;
&lt;p&gt;在現實中，我們將阿福、阿黃等等歸類為狗這個概念，而到了程式裡，我們利用這個狗的概念定義出類別，進而產生阿福、阿黃。&lt;/p&gt;
&lt;p&gt;從這邊也能察覺到：類別是一個歸納好的概念，這概念中包含許多獨立的個體，也就是物件，而這些物件之間的差異則從我們定義類別時選擇的特徵去區分。&lt;/p&gt;
&lt;p&gt;因此，一個人設計的類別，和他使用物件的方式，反映了他對於這個物件的看法和他覺得需要的內容。&lt;/p&gt;
&lt;p&gt;同時，&lt;strong&gt;使用物件導向也意味著：比起 &lt;code&gt;EatFood(dog, food)&lt;/code&gt; 而言，我們認同 &lt;code&gt;Dog.Eat(food)&lt;/code&gt; 更直覺和易於理解。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那麼這邊就讓我們以卡牌遊戲舉例，理所當然卡牌遊戲不能沒有卡牌。&lt;/p&gt;
&lt;p&gt;對我來說卡牌通常都需要這些&lt;strong&gt;特徵&lt;/strong&gt;，我們在物件裡稱為&lt;strong&gt;屬性&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;卡片名稱&lt;/li&gt;
&lt;li&gt;攻擊力&lt;/li&gt;
&lt;li&gt;防禦力&lt;/li&gt;
&lt;li&gt;卡牌描述&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等等，另外卡牌也應該能作出某些&lt;strong&gt;動作&lt;/strong&gt;，也就是這個物件的&lt;strong&gt;方法&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;攻擊&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我們確認了這些要素以後，就可以把它設計成一個類別 &lt;code&gt;Card&lt;/code&gt; 如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Card&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; Name;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Level;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Attack;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Health;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; Description;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 攻擊目標卡片&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Hit(Card target) 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        target.damage(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Attack)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 被攻擊的時候扣血&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; damage(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; attack) 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Health -= attack;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Health &amp;lt;= &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        { 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;/* 可能呼叫死翹翹方法？ */&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;抱歉我菜，如果有真的設計卡牌遊戲的工程師經過拜託不要打我。&lt;/p&gt;
&lt;p&gt;接著我們就能在需要的時候藉由這個類別來實例化我們的卡牌：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; goblin = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Card();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; warrior = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Card();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;warrior.Hit(goblin);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;再提醒一次：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;類別是定義、是設計圖、是描述；物件是類別產生的實體、是實際上的執行者&lt;/li&gt;
&lt;li&gt;類別是抽象化的資訊，例如「狗」；物件則是一個特定的實例，例如「叫做阿福的狗」&lt;/li&gt;
&lt;li&gt;承上，狗的類別用來告訴程式什麼是狗；叫做阿福的物件則是程式根據我們的指示，建立出來的一條指定的狗&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到此應該能夠初步掌握物件和類別的概念了。這邊推薦一下可以閱讀保哥的這篇 &lt;a href=&#34;https://blog.miniasp.com/post/2009/08/27/OOP-Basis-What-is-class-and-object&#34;&gt;物件導向基礎：何謂類別(Class)？何謂物件(Object)？&lt;/a&gt;，裡面除了對物件和類別有更易懂的介紹和舉例以外，還有十題概念題可以幫助你搞懂物件和類別的意義與差異，相當值得一看。另外，也可以參考這幾篇的說明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ytyubox.github.io/posts/2020/02/29/oop-discussion/&#34;&gt;有物件導向的世界與沒有物件導向的世界&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://matthung0807.blogspot.com/2017/10/java_24.html&#34;&gt;Java 物件導向的概念 - 菜鳥工程師肉豬&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-1_%E9%A1%9E%E5%88%A5class%E8%88%87%E5%AF%A6%E9%AB%94object/&#34;&gt;Object Oriented物件導向-1:類別(Class)與實體(Object) - Sian&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;物件的部份由於是最初的概念，不免多廢話了一些。下一篇開始就讓我們快速看過物件導向的幾項功能和特性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列下一篇：&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;2022.12.02 補充：感謝公司前輩簡潔有力的說明，修正了開頭時對物件的介紹&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10201905&#34;&gt;一個語言如果不改變你的思考方式，就不值得學？談程式語言的本質&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.miniasp.com/post/2009/08/27/OOP-Basis-What-is-class-and-object&#34;&gt;物件導向基礎：何謂類別(Class)？何謂物件(Object)？ - The Will Will Web&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ytyubox.github.io/posts/2020/02/29/oop-discussion/&#34;&gt;有物件導向的世界與沒有物件導向的世界&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://matthung0807.blogspot.com/2017/10/java_24.html&#34;&gt;Java 物件導向的概念 - 菜鳥工程師肉豬&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-1_%E9%A1%9E%E5%88%A5class%E8%88%87%E5%AF%A6%E9%AB%94object/&#34;&gt;Object Oriented物件導向-1:類別(Class)與實體(Object) - Sian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://notepad.yehyeh.net/Content/CSharp/CH01/03ObjectOrient/1ObjectAndClass/index.php&#34;&gt;[C#] 物件與類別 - Yehyen&amp;rsquo;s Notepad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/csharp/programming-guide/concepts/object-oriented-programming&#34;&gt;物件導向程式設計（C#） - Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@totoroLiu/%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-object-oriented-programming-%E6%A6%82%E5%BF%B5-5f205d437fd6&#34;&gt;物件導向(Object Oriented Programming)概念 - Po-Ching Liu - Medium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tenlong.com.tw/products/9789866761799&#34;&gt;《大話設計模式》附錄：物件導向基礎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.books.com.tw/products/0010824582&#34;&gt;《深入淺出學會編寫程式》Ch7：模組、方法、類別以及物件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同系列文章&#34;&gt;同系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (0): 前言</title>
      <link>https://igouist.github.io/post/2020/07/oo-0-object-oriented/</link>
      <pubDate>Sun, 12 Jul 2020 23:53:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/oo-0-object-oriented/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/9UtcyAf.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在訂便當告一段落之後，其實就已經和同事約好要來整理公司新訓的筆記。但儘管已經到職快一年了，有些工具已經在專案碰過好幾次。但遇到需要跟朋友討論，或是聽前輩說明觀念的時候，還是不自主地會想「我真的懂嗎？」故一直是挺畏懼的。&lt;/p&gt;
&lt;p&gt;但幸虧同事的鼓勵和以身作則，最終還是開啟了這個新系列，決定直接開坑把當初前輩新訓指導過的部分整理下來，也算是讓自己能趁著這機會好好複習一番，把自己的想法跟心得記錄下來。&lt;/p&gt;
&lt;p&gt;另外，如果你是真心希望弄懂物件導向的朋友，這邊推薦&lt;a href=&#34;https://www.tenlong.com.tw/products/9789866761799&#34;&gt;《大話設計模式》&lt;/a&gt;的附錄，內容對物件導向的介紹清晰易懂且循序漸進，非常適合作為了解物件導向的起頭。&lt;/p&gt;
&lt;p&gt;本篇的段落將會分成以下幾個部份，由於只是筆記一下，因此會附上一些知識點的參考資料，看見的時候可以先行閱讀；末尾也會附上有關的參考資料及文章，對於這類概念性的東西，一向是推薦多方閱讀以增強理解，就像保哥寫的：「&lt;strong&gt;如果你問 100 個人這個問題，可能會得到 200 個答案，所以你一定要有自己獨到、有自信、精闢的見解或描述方式&lt;/strong&gt;。」如果有寫得不錯的文章想推薦給我，或是有地方需要補充和指證，還請不吝指教。共勉之。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最後，儘管這系列的篇幅會有點長，但我覺得仍做不到說明透徹，&lt;del&gt;畢竟大部份也是只花一天壓線趕工出來的&lt;/del&gt;。因此往後如果有想到什麼地方必須修正，或是找到什麼更好的表達方式，還是會回來修改這系列文章，希望能逐漸修訂成讓我自己都能輕鬆看懂的物件導向入門文。&lt;/p&gt;
&lt;p&gt;下一篇就直接從類別和物件開始囉。那麼，還請各位閱覽拙見，為此先道一聲感謝。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列下一篇：&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;8/9 註記：和朋友們聊過之後，發現之前集中成一篇感覺太長了，更何況新訓的內容也是包山包海。因此將原先的內文拆解成多篇文章，做成系列文；由於一些大人的原因（例如不想打亂鼠年全馬、不想重註冊 URL 等等），本篇就留著作為目錄使用，以上。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>AutoMapper —— 類別轉換超省力</title>
      <link>https://igouist.github.io/post/2020/07/automapper/</link>
      <pubDate>Sun, 05 Jul 2020 23:40:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/automapper/</guid>
      <description>&lt;p&gt;類別間的轉換幾乎是每個專案每個工程師都會碰到的動作，舉凡是分層架構每層之間的轉換，如 Dto 轉換成 ViewModel；或是接收到資料要塞進自定義的類別時也需要進行轉換。但&lt;strong&gt;在遠古時代，當我們要把一個類別的資料倒進另一個類別時，總免不了一番折騰&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如一個卡片對戰遊戲的資料庫，光是要先把卡片資料讀取出來就需要：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/c81Hx5I.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;有些時候也會看見用 Foreach 然後逐一傳值的場景，或是各種差不多的變種情況。同樣的是，光是將一個簡單的卡片資訊轉換成 ViewModel，就花了一大段在做對映的處理。這個過程本身枯燥乏味又占空間，更可怕的是，&lt;strong&gt;如果有個陳年資料表，動不動就上百個欄位，那這個轉換過程的恐怖程度可想而知&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;幸好！天無絕人之路，這種時候就是本日的主角 —— AutoMapper 出場的時候了。&lt;/p&gt;
&lt;p&gt;當 AutoMapper 一出手，轉換的過程瞬間就變成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/KxHAKpi.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;是不是精簡很多呢？接著就讓我們來看看怎麼開始使用吧！&lt;/p&gt;
&lt;h2 id=&#34;安裝與使用&#34;&gt;安裝與使用&lt;/h2&gt;
&lt;p&gt;首先，當然要先到 NuGet 把 AutoMapper 給裝下來。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/TEAZwU7.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/3ADyJXv.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;確認安裝之後，就開始基本的使用吧。&lt;/p&gt;
&lt;p&gt;只需要&lt;strong&gt;先註冊好 Mapper 的設定內容，也就是哪些類別之間可以互相對映；再實體化 Mapper 出來使用就可以了&lt;/strong&gt;。直接看程式碼應該就能理解：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; IEnumerable&amp;lt;CardViewModel&amp;gt; GetCard()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; data = &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.GetCardFromRepositoryMock();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; config = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; MapperConfiguration(cfg =&amp;gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cfg.CreateMap&amp;lt;Card, CardViewModel&amp;gt;()); &lt;span style=&#34;color:#75715e&#34;&gt;// 註冊Model間的對映&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; mapper = config.CreateMapper(); &lt;span style=&#34;color:#75715e&#34;&gt;// 建立 Mapper&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; result = mapper.Map&amp;lt;IEnumerable&amp;lt;CardViewModel&amp;gt;&amp;gt;(data); &lt;span style=&#34;color:#75715e&#34;&gt;// 轉換型別&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;沒錯，只需要簡簡單單幾步， &lt;strong&gt;AutoMapper 會自動將指定類別間同樣名稱的屬性內容做轉換&lt;/strong&gt; ，因此能夠省下相當多的功夫，也能夠隱藏類別本身的內容，專心在處理功能本身。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;註：網路上挺多 AutoMapper 的文章會直接使用 &lt;code&gt;Mapper.CreateMap()&lt;/code&gt; 這類靜態方法，然而這些方法已經在 AutoMapper 5 的時候被廢除，改成現在由 &lt;code&gt;MapperConfiguration&lt;/code&gt; 產生 Mapper 的方法。&lt;/p&gt;
&lt;p&gt;然而整體的使用方式仍然大同小異，這些文章仍能稍微調整並使用，惟使用過程中需自己注意語法的差異和多加測試。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;客製化轉換&#34;&gt;客製化轉換&lt;/h3&gt;
&lt;p&gt;但當然實際上我們並不一定每個欄位的名稱都是一模一樣的，總是會有遇到同個資料在不同層的 Model 裡名稱不一樣的時候，又或者是某個欄位是由兩三個欄位組成的時候。對於這種需要客製化的轉換，這時候我們就可以在註冊對映時對欄位內容的對映方式做指定：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; config = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; MapperConfiguration(cfg =&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    cfg.CreateMap&amp;lt;Card, CardViewModel&amp;gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .ForMember(x =&amp;gt; x.Id, y =&amp;gt; y.MapFrom(o =&amp;gt; o.CardId))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .ForMember(x =&amp;gt; x.Name, y =&amp;gt; y.MapFrom(o =&amp;gt; &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;{o.Id}: {o.Name}&amp;#34;&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ); &lt;span style=&#34;color:#75715e&#34;&gt;// 註冊Model間的對映 建立設定檔&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到 &lt;strong&gt;我們能用 &lt;code&gt;ForMember&lt;/code&gt; 去對類別成員做操作，並傳入目標的類別成員，以及該成員對應的操作，像這邊就使用 &lt;code&gt;MapFrom&lt;/code&gt; 來指定目標類別成員的轉換來源&lt;/strong&gt;，這樣就可以達到轉換時的客製化了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;註：對於欄位之間有使用 &lt;code&gt;ForMember&lt;/code&gt; 來處理過內容再轉換的型別，建議在轉換型別時，也就是實際 mapper.Map() 的時候，稍做註解提醒一下。&lt;/p&gt;
&lt;p&gt;尤其是會將 Mapper 的 Config 集中整理的架構裡更應該要對額外的操作做揭露，這樣對彼此都好。真的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;補充：AutoMapper 在轉換像是 &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; 這類的集合時，預設會將來源為 Null 的成員轉換成空集合（而非 Null）&lt;/p&gt;
&lt;p&gt;如果希望 Null 就好好轉換成 Null 的朋友，可以在建立設定檔時用 &lt;code&gt;cfg.AllowNullCollections = true;&lt;/code&gt; 來讓所有為 Null 的空集合轉換對象都乖乖保持 Null&lt;/p&gt;
&lt;p&gt;也能夠在 ForMember 的時候使用 AllowNull 來針對欄位指定規則。例如 &lt;code&gt;ForMember(x =&amp;gt; x.Members, y =&amp;gt; y.AllowNull())&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;需要更詳細說明的朋友，也可以參照官方文檔的 &lt;a href=&#34;https://docs.automapper.org/en/stable/Lists-and-arrays.html#handling-null-collections&#34;&gt;Handling null collections&lt;/a&gt; 一節&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;忽略指定的欄位&#34;&gt;忽略指定的欄位&lt;/h3&gt;
&lt;p&gt;除了會有欄位名稱和來源的不同以外，最常遇到的應該就是兩個類別之間大多數欄位雖然對映，但某幾個欄位是沒有對映的。例如傳送給前端使用時一併送出其他來源的資料，但資料由資料表取出時並沒有這個欄位，必須轉換以後再呼叫別的方法去補上資料。&lt;strong&gt;如果直接使用 Map 來進行轉換，就會發生找不到對映欄位的錯誤。這時候就可以使用 &lt;code&gt;Ignore&lt;/code&gt; 來忽略掉指定的欄位&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; config = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; MapperConfiguration(cfg =&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    cfg.CreateMap&amp;lt;Card, CardViewModel&amp;gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       .ForMember(x =&amp;gt; x.ImgUri, y =&amp;gt; y.Ignore())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    );
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如上述程式碼，可能卡片的圖像位置必須由別的方式取得，這種情況我們在 &lt;code&gt;ForMember&lt;/code&gt; 的時候就可以將其指定為 &lt;code&gt;Ignore&lt;/code&gt; 讓 AutoMapper 不要去嘗試轉換它。除了 &lt;code&gt;Ignore&lt;/code&gt; 以外，AutoMapper 還有配備像是 &lt;code&gt;IgnoreAllPropertiesWithAnInaccessibleSetter&lt;/code&gt; 這種光方法名稱長度就有點強的大殺器，也還有像是 &lt;code&gt;AllowNull&lt;/code&gt; 等更多對欄位操作的方法，這部份請各位在使用時按照需求自行摸索。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;註(1)：上述舉的例子中有需要從多個來源轉換為一個類別的場合，可以參照 &lt;a href=&#34;https://kevintsengtw.blogspot.com/2014/03/automapper.html&#34;&gt;AutoMapper 兩個物件對映到一個類別 - mrkt 的程式學習筆記&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;註(2)：上面使用到的 Ignore 方法還是有些眉角需要注意，可以參照 &lt;a href=&#34;https://dotblogs.com.tw/supershowwei/2016/07/17/162815&#34;&gt;[料理佳餚] AutoMapper 中不容忽視的 Ignore() Mapping 的順序 - 軟體主廚的程式料理廚房&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;註(3)：面對一些比較複雜的轉換時，也可以考慮使用 &lt;a href=&#34;https://igouist.github.io/post/2021/12/automapper-convert-using/&#34;&gt;ConvertUsing&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最後還要補充的一個方法是 &lt;code&gt;ReverseMap&lt;/code&gt; ，它能夠反轉對映，建立一個反方向的對映表。當你的類別之間可能需要往回轉型，又或是想要忽略來源類別的欄位時，&lt;code&gt;ReverseMap&lt;/code&gt; 就會顯得相當有用。通常為了避免轉來轉去轉出意外，建議註冊時還是補上一個 &lt;code&gt;ReverseMap&lt;/code&gt; 為佳。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; config = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; MapperConfiguration(cfg =&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    cfg.CreateMap&amp;lt;Card, CardViewModel&amp;gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       .ForMember(x =&amp;gt; x.Id, y =&amp;gt; y.MapFrom(o =&amp;gt; o.CardId))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       .ForMember(x =&amp;gt; x.ImgUri, y =&amp;gt; y.Ignore())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       .ReverseMap() &lt;span style=&#34;color:#75715e&#34;&gt;// 反轉&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    );
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;到目前為止，程式碼可能會變成如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; IEnumerable&amp;lt;CardViewModel&amp;gt; GetCard()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; data = &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.GetCardFromRepositoryMock();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; config = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; MapperConfiguration(cfg =&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cfg.CreateMap&amp;lt;Card, CardViewModel&amp;gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           .ForMember(x =&amp;gt; x.Id, y =&amp;gt; y.MapFrom(o =&amp;gt; o.CardId))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           .ForMember(x =&amp;gt; x.Name, y =&amp;gt; y.MapFrom(o =&amp;gt; &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;{o.Id}: {o.Name}&amp;#34;&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           .ForMember(x =&amp;gt; x.ImgUri, y =&amp;gt; y.Ignore())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           .ReverseMap());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; mapper = config.CreateMapper(); &lt;span style=&#34;color:#75715e&#34;&gt;// 建立 Mapper&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; result = mapper.Map&amp;lt;IEnumerable&amp;lt;CardViewModel&amp;gt;&amp;gt;(data); &lt;span style=&#34;color:#75715e&#34;&gt;// 轉換型別&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;(2021/6/9) 補充：&lt;/p&gt;
&lt;p&gt;在我們前面提到的欄位轉換時，要特別注意兩個欄位的型別是否能夠對應上。由於 AutoMapper 會貼心地幫我們進行轉換，但有些時候可能會產生問題，讓我們看看下面這個例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Boo&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; Val { &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Foo&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Val { &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Foo Sut()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; boo = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Boo
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Val = &lt;span style=&#34;color:#ae81ff&#34;&gt;2.65&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; config = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; MapperConfiguration(cfg =&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cfg.CreateMap&amp;lt;Boo, Foo&amp;gt;());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; mapper = config.CreateMapper();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; foo = mapper.Map&amp;lt;Foo&amp;gt;(boo);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; foo; &lt;span style=&#34;color:#75715e&#34;&gt;// 3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到上面這個例子中，我們可以把 &lt;code&gt;double&lt;/code&gt; 的欄位直接 Mapping 到 &lt;code&gt;int&lt;/code&gt; 的欄位上，因為 AutoMapper 的貼心，所以不會出錯，但過程中還是可能發生喪失精度的問題。&lt;/p&gt;
&lt;p&gt;像是例子中的 2.65 就直接變成了 3，如果符合我們的需求（例如本來就打算轉型）倒是沒關係，但如果是因為不小心轉到的話，在找問題上可能就會比較麻煩。&lt;/p&gt;
&lt;p&gt;因此在轉換的時候，還請特別留意一下轉換雙方的型別，測試一下轉換結果是不是自己要的結果會比較好呦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;簡化整理&#34;&gt;簡化整理&lt;/h2&gt;
&lt;p&gt;可能看到這裡有些讀者就開始疑惑了：這好像跟一開始簡介不太一樣啊，詐欺？又或者是：我每個方法裡面都要重新建一個 Mapper？這不太對吧？&lt;/p&gt;
&lt;p&gt;的確是這樣沒錯，AutoMapper 要達到更簡潔，還需要再做一些整理。例如使用 Profile 將對映關係集中起來，以及把 Mapper 的建構抽取出來。可能是在建構式建立共用的 Mapper ，或是以依賴注入 (Dependency Injection) 的方式來注入 Mapper 等等。以下就逐步進行介紹。&lt;/p&gt;
&lt;h3 id=&#34;profile&#34;&gt;Profile&lt;/h3&gt;
&lt;p&gt;首先我們先建立一個用來放對映關係的 Profile。我個人習慣會另開一個 Mappings 資料夾，並按照轉換所在的分層 + Mappings 來命名。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ServiceMappings&lt;/span&gt; : Profile
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; ServiceMappings()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        CreateMap&amp;lt;Card, CardViewModel&amp;gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            .ForMember(x =&amp;gt; x.Id, y =&amp;gt; y.MapFrom(o =&amp;gt; o.CardId))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            .ForMember(x =&amp;gt; x.Name, y =&amp;gt; y.MapFrom(o =&amp;gt; &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;{o.Id}: {o.Name}&amp;#34;&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            .ForMember(x =&amp;gt; x.ImgUri, y =&amp;gt; y.AllowNull())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            .ReverseMap(); 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// ...其他的對映內容 (使用 CreateMap&amp;lt;&amp;gt; 建立下一組)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;從上面可以看到，我們&lt;strong&gt;繼承 AutoMapper 提供的 Profile 類，接著在建構式裡面將需要的轉換關係組都建立起來&lt;/strong&gt;。接著當我們建立 Mapper 時，就可以直接用 &lt;code&gt;AddProfile&lt;/code&gt; 和建立好的 Profile 來直接讀入對映關係：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; IEnumerable&amp;lt;CardViewModel&amp;gt; GetCard()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; data = &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.GetCardFromRepositoryMock();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; config = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; MapperConfiguration(cfg =&amp;gt; cfg.AddProfile&amp;lt;ServiceMappings&amp;gt;());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; mapper = config.CreateMapper(); &lt;span style=&#34;color:#75715e&#34;&gt;// 用設定檔建立 Mapper&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; result = mapper.Map&amp;lt;IEnumerable&amp;lt;CardViewModel&amp;gt;&amp;gt;(data); &lt;span style=&#34;color:#75715e&#34;&gt;// 轉換型別&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;當然，&lt;strong&gt;在 &lt;code&gt;MapperConfiguration&lt;/code&gt; 的時候是可以對 cfg 去做多次 &lt;code&gt;AddProfile&lt;/code&gt; 的&lt;/strong&gt;，既然可以載入多組對映關係，就代表可以按照實務上的運用去將對映關係做分類和整理。&lt;/p&gt;
&lt;p&gt;這邊還是要再度提醒一下，將 &lt;code&gt;CreateMap&lt;/code&gt; 都整理到 Profile 之後，若是有些類別之間的轉換有對欄位做額外的處理，例如 DateTime 去除時間只留下年月日，又或是某幾個欄位銜接成一個欄位等等，&lt;strong&gt;在實際進行類別轉換的時候需要註記一下，請後續的維護人員或團隊夥伴記得先確認過 Profile，避免造成一些隱藏重要資訊挖洞給人跳的問題&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;整理到建構式&#34;&gt;整理到建構式&lt;/h3&gt;
&lt;p&gt;接著由於一個處理資料或商業邏輯的部分通常會有許多方法都用到 Mapper，因此將建立 Mapper 的過程取出來避免重複絕對是必要的。故整理的第一步就是將 Mapper 的建立拆分出來，不再等每次用到的時候才建，而是先建立好一個 Mapper，需要的時候再來使用它。&lt;/p&gt;
&lt;p&gt;這邊就先嘗試將其挪到私有變數和建構式處理：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; IMapper _mapper;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; MapSimpleService() &lt;span style=&#34;color:#75715e&#34;&gt;// 建構式&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; config = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; MapperConfiguration(cfg =&amp;gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cfg.AddProfile&amp;lt;ServiceMappings&amp;gt;());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;._mapper = config.CreateMapper();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那麼我們實際上的方法就會變成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; IEnumerable&amp;lt;CardViewModel&amp;gt; GetCard()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; data = &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.GetCardFromRepositoryMock();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; result = &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;._mapper.Map&amp;lt;IEnumerable&amp;lt;CardViewModel&amp;gt;&amp;gt;(data);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;走向注入&#34;&gt;走向注入&lt;/h3&gt;
&lt;p&gt;由於本篇篇幅無法說明好依賴注入（DI）的概念，相關的部份就留待在&lt;a href=&#34;https://igouist.github.io/post/2021/11/newbie-6-dependency-injection&#34;&gt;之後的文章&lt;/a&gt;中說明，這邊就以 .net Core 為示範來記錄一下步驟，提供給已經會 DI 的朋友參考。&lt;/p&gt;
&lt;p&gt;在開始之前，我們會需要再前往 NuGet 安裝 AutoMapper DI 用的套件：
&lt;img src=&#34;https://i.imgur.com/hae1zfj.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接著在 &lt;code&gt;Startup.cs&lt;/code&gt; 裡的 &lt;code&gt;ConfigureServices&lt;/code&gt; 加上 &lt;code&gt;services.AddAutoMapper(typeof(Startup))&lt;/code&gt; 來註冊我們的 Mapper：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; ConfigureServices(IServiceCollection services)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    services.AddControllers(); 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Demo 用的 Service&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    services.AddScoped&amp;lt;IMapSimpleService, MapSimpleService&amp;gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 註冊 Mapper&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    services.AddAutoMapper(&lt;span style=&#34;color:#66d9ef&#34;&gt;typeof&lt;/span&gt;(Startup)); 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可能有些人會有點疑惑：前面還需要 &lt;code&gt;MapperConfiguration&lt;/code&gt; 怎麼這次不用了呢？那是因為 &lt;code&gt;AddAutoMapper&lt;/code&gt; 的時候就會用反射去取得同組件中的 &lt;code&gt;Profile&lt;/code&gt; 來載入，所以這部分就可以不用擔心，只要專心在使用上就好。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(2021/4/23) 補充：&lt;/p&gt;
&lt;p&gt;感謝同事們的討論，這邊也補充給大家參考一下&lt;/p&gt;
&lt;p&gt;當我們直接使用 &lt;code&gt;services.AddAutoMapper(typeof(Startup));&lt;/code&gt; 註冊的時候，AutoMapper 會去抓我們 &lt;code&gt;typeof&lt;/code&gt; 的型別，並對該型別所在的 Assembly 進行反射找出所有的 &lt;code&gt;Profile&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但如果你有用到多層的架構、或是不同的組件內都有 &lt;code&gt;Profile&lt;/code&gt; 需要註冊，又或者只是想要逐個 &lt;code&gt;Profile&lt;/code&gt; 進行註冊，方便進行控管的話，可以考慮使用 &lt;strong&gt;&lt;code&gt;AddProfile&lt;/code&gt;&lt;/strong&gt; 或 &lt;strong&gt;&lt;code&gt;AddProfiles&lt;/code&gt;&lt;/strong&gt; 的方式來進行註冊，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;services.AddAutoMapper(config =&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    config.AddProfile&amp;lt;ControllerProfile&amp;gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    config.AddProfile&amp;lt;ServiceProfile&amp;gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這樣的可讀性更好，也能讓維護的人迅速掌握當前的 Profile，有需要的朋友可以嘗試看看。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;(2021/8/27) 補充：&lt;/p&gt;
&lt;p&gt;感謝 &lt;a href=&#34;https://raychiutw.github.io/&#34;&gt;Ray&lt;/a&gt; 大大提供的方法，這邊也補充給大家參考一下&lt;/p&gt;
&lt;p&gt;我們前面有提到 &lt;code&gt;AddAutoMapper&lt;/code&gt; 會對該型別所在的 Assembly 進行反射找出所有的 &lt;code&gt;Profile&lt;/code&gt;，那麼我們也可以轉換一下思路：只要把全部的組件都丟到 &lt;code&gt;AddAutoMapper&lt;/code&gt; 裡就好了！這種時候我們就可以利用反射來達到我們的目的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;services.AddAutoMapper(AppDomain.CurrentDomain.GetAssemblies());
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;相較於 &lt;code&gt;AddProfile&lt;/code&gt; 這種逐一新增 &lt;code&gt;Profile&lt;/code&gt; 的作法，利用反射會讓註冊顯得更乾淨，並且也更不容易有所遺漏。各位可以按照開發的場景選擇一下註冊的方式，有需要的朋友也可以都嘗試看看。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;註冊好之後，我們就能將剛剛的示範部分更改為使用注入的方式來取得 Mapper：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; IMapper _mapper;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; MapSimpleService(IMapper mapper) &lt;span style=&#34;color:#75715e&#34;&gt;// 建構式&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;._mapper = mapper;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;執行之後就能確認確實有轉換到值囉！最後再來對照一下商業邏輯的部份：&lt;/p&gt;
&lt;p&gt;－－瘦身前－－&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; IEnumerable&amp;lt;CardViewModel&amp;gt; GetCard()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; data = &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.GetCardFromRepositoryMock();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; result = data.Select(x =&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; CardViewModel
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            Id = x.Id,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            Name = x.Name,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            Cost = x.Cost,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            Attack = x.Attack,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            Health = x.Health,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            Note = x.Note &lt;span style=&#34;color:#75715e&#34;&gt;// ...etc&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;－－瘦身後－－&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; IEnumerable&amp;lt;CardViewModel&amp;gt; GetCard()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; data = &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.GetCardFromRepositoryMock();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; result = &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;._mapper.Map&amp;lt;IEnumerable&amp;lt;CardViewModel&amp;gt;&amp;gt;(data);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;結語&#34;&gt;結語&lt;/h2&gt;
&lt;p&gt;當我們把類別轉換的區段利用 AutoMapper 擷取出來，就能&lt;strong&gt;讓原本的程式碼更著重在該方法本身的邏輯和功能&lt;/strong&gt;，而不會被冗長的轉換過程洗版，使用 Mapper 的方法只要知道這兩個類別能夠互相轉換即可。除了看起來更舒服、更能將焦點放在方法本身以外，也能夠讓維護時的修改更加直覺，若是轉換的過程需要修改，就去變更 Profile，不需要去變動實現商業邏輯的方法本身，這樣就能朝單一職責的目標更前進一點。&lt;/p&gt;
&lt;p&gt;到這邊算是把 AutoMapper 基本的用法介紹過一遍了，當然還有很多進階的用法和需要注意的部分並沒有說明完全，但相信這樣的紀錄已經能夠幫助我在將來需要的時候回想起怎麼使用，和解決大部分需要做類別轉換的場景了。剩餘的延伸閱讀將會補充在參考資料裡，那麼下週見～&lt;/p&gt;
&lt;h2 id=&#34;參考資料及延伸閱讀&#34;&gt;參考資料及延伸閱讀&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/yc421206/2016/07/15/automapper_version_5_MapperConfiguration&#34;&gt;[AutoMapper] AutoMapper 5.0.2 的新寫法 - 余小章 @ 大內殿堂&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kevintsengtw.blogspot.com/2013/04/automapper.html&#34;&gt;使用 AutoMapper 處理類別之間的對映轉換 - mrkt 的程式學習筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kevintsengtw.blogspot.com/2014/03/automapper.html&#34;&gt;AutoMapper 兩個物件對映到一個類別 - mrkt 的程式學習筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kevintsengtw.blogspot.com/2013/04/automapper-configuration.html&#34;&gt;AutoMapper 的設定 (Configuration) - mrkt 的程式學習筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/yc421206/2014/12/12/147619&#34;&gt;[C#.NET] 使用 AutoMapper.Profile 簡化對應設定 - 余小章 @ 大內殿堂&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10157130&#34;&gt;AutoMapper 介紹 - 簡單化Entity和ViewModel之間的轉換&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/keigen/2017/06/28/151917&#34;&gt;AutoMapper 初體驗 - 中年大叔的鹹魚翻身作戰計畫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://iter01.com/155318.html&#34;&gt;.NET Core 中依賴注入 AutoMapper 小記 - IT人&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/supershowwei/2016/07/17/162815&#34;&gt;[料理佳餚] AutoMapper 中不容忽視的 Ignore() Mapping 的順序 - 軟體主廚的程式料理廚房&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/12/automapper-convert-using/&#34;&gt;AutoMapper 使用 ConvertUsing 自定義類型轉換，將包含串列成員的物件映射為一組串列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Electron.net —— 把網頁包成桌面應用吧</title>
      <link>https://igouist.github.io/post/2020/06/electron-net/</link>
      <pubDate>Sun, 28 Jun 2020 19:41:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/06/electron-net/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://github.com/ElectronNET/Electron.NET/raw/master/assets/images/electron.net-logo.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;因緣際會下想要弄出一些單機小工具來跑，這時候正巧接觸到 &lt;a href=&#34;https://github.com/ElectronNET/Electron.NET&#34;&gt;Electron.net&lt;/a&gt; 這個神器，特別紀錄一下以免忘記。這是 &lt;a href=&#34;https://www.electronjs.org/&#34;&gt;Electron&lt;/a&gt; 搭配 .net Core 的框架， &lt;strong&gt;Electron 是用 Chromium 和 Node.js 將網頁封裝成桌面應用程式&lt;/strong&gt;，像是 Visual Studio Code、Slack 也都有使用到 Electron。而 &lt;a href=&#34;https://github.com/ElectronNET/Electron.NET&#34;&gt;Electron.net&lt;/a&gt; 顧名思義就是 .net 用的 Electron 框架囉。&lt;/p&gt;
&lt;p&gt;這邊記錄一下自己嘗試時載入套件和建置的流程，主要參考自黑大的 &lt;a href=&#34;https://blog.darkthread.net/blog/electron-net/&#34;&gt;用 ASP.NET Core 寫桌面 GUI 應用程式 - Electron.NET&lt;/a&gt; 和 &lt;a href=&#34;https://blog.darkthread.net/blog/electron-api-brief/&#34;&gt;Electron.NET API 快速巡覽&lt;/a&gt; 這兩篇文章，以及官方的 &lt;a href=&#34;https://github.com/ElectronNET/electron.net-api-demos&#34;&gt;API DEMO&lt;/a&gt;，特此感謝。&lt;/p&gt;
&lt;p&gt;本篇小節：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%89%E8%A3%9D%E5%A5%97%E4%BB%B6%E5%8F%8A%E7%92%B0%E5%A2%83%E8%A8%AD%E7%BD%AE&#34;&gt;安裝套件及環境設置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%8D%E5%BE%8C%E7%AB%AF%E5%82%B3%E5%80%BC-ipcmain-ipcrenderer&#34;&gt;前後端傳值 (IpcMain, IpcRenderer)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%89%93%E5%8C%85%E6%88%90%E5%9F%B7%E8%A1%8C%E6%AA%94exe&#34;&gt;打包成執行檔（.exe）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BE%8C%E8%A8%98&#34;&gt;後記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99&#34;&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那麼首先從建立新專案開始，這邊用 .net Core MVC 來測試&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/xf2fOwT.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/O0jwPZF.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;安裝套件及環境設置&#34;&gt;安裝套件及環境設置&lt;/h2&gt;
&lt;p&gt;建立專案之後，前往 Nuget 先把 &lt;strong&gt;ElectronNET API&lt;/strong&gt; 安裝下來&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/hT5JZu0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;安裝完畢之後，開始做一些前置動作，首先：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Program.cs&lt;/code&gt; 的部分，加上 &lt;code&gt;.UseElectron(args)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Vm7P1ds.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Startup.cs&lt;/code&gt; 的部分，加上 &lt;code&gt;Task.Run(async () =&amp;gt; await Electron.WindowManager.CreateWindowAsync()&lt;/code&gt;，讓專案啟動時一併啟動 Electron&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/gvsXNx4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接著打開命令提示字元或 Powershell ，輸入 &lt;code&gt;dotnet tool install ElectronNET.CLI -g&lt;/code&gt; 安裝 ElectronNET 工具。如果有安裝成功應該會看到下圖的回傳。如果已經安裝，就可以直接進到下一步。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/hf4mg6u.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接著移動到專案資料夾，並輸入 &lt;code&gt;electronize init&lt;/code&gt; 進行初始化，將會建立資料夾和必需檔案，這一步一定要確認成功並顯示 &lt;code&gt;Everything done&lt;/code&gt;，否則後面怎麼跑也起不來。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/q6RdjDm.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;補充：如果 &lt;code&gt;electronize init&lt;/code&gt; 的時候跳出 &amp;ldquo;Path cannot be null on init&amp;rdquo; 的錯誤，請移動到 &lt;code&gt;Startup.cs&lt;/code&gt; 或是 &lt;code&gt;Program.cs&lt;/code&gt; 所在的目錄再試一次。&lt;/p&gt;
&lt;p&gt;參考來源：&lt;a href=&#34;https://github.com/ElectronNET/Electron.NET/issues/245&#34;&gt;Electron.NET&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最後輸入 &lt;code&gt;electronize start&lt;/code&gt; 就可以準備看專案 On 起來囉！&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/HoSdpvU.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;另外除了 &lt;code&gt;electronize start&lt;/code&gt;，環境設置完畢後也可以直接從 Visual Studio 偵錯囉～&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/iFqkq6d.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;成功從桌面應用開起來了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Y89i3HK.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;前後端傳值-ipcmain-ipcrenderer&#34;&gt;前後端傳值 (IpcMain, IpcRenderer)&lt;/h2&gt;
&lt;p&gt;在 Electron 中，會分成&lt;strong&gt;跑應用程式的主處理序 (main process)&lt;/strong&gt;、和&lt;strong&gt;處理網頁畫面的渲染處理序 (renderer process)&lt;/strong&gt;。而兩者之間的&lt;strong&gt;溝通則經由 &lt;code&gt;Ipc&lt;/code&gt; 開啟頻道傳遞訊息來實現&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;這邊簡單嘗試一次，首先，我們先在 &lt;code&gt;Views/Home/index.cshtml&lt;/code&gt; 加上一個簡單的按鈕&lt;/p&gt;
&lt;p&gt;並且加上 JavaScript 發送訊息和接收訊息的方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/DaNlQgS.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;ipcRenderer&lt;/span&gt; } &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;require&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;electron&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 發送訊息，這邊傳送一個 Hello
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sendMessageToServer&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;ipcRenderer&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;send&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;channelToServer&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Hello&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 接收訊息
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ipcRenderer&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;on&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;channelToClient&amp;#39;&lt;/span&gt;, (&lt;span style=&#34;color:#a6e22e&#34;&gt;event&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;arg&lt;/span&gt;) =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    document.&lt;span style=&#34;color:#a6e22e&#34;&gt;getElementById&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Welcome&amp;#34;&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;innerText&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;arg&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接著到對應的 &lt;code&gt;Controllers/HomeController&lt;/code&gt; 的 &lt;code&gt;Index()&lt;/code&gt; 也加上接受到訊息之後加工並發出訊息的處理&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Xw3AX8r.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; IActionResult Index()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 接收訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Electron.IpcMain.On(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;channelToServer&amp;#34;&lt;/span&gt;, (args) =&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 傳送訊息，把接收到的訊息再加上 World&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; mainWindow = Electron.WindowManager.BrowserWindows.First(); &lt;span style=&#34;color:#75715e&#34;&gt;// 現在只有一個視窗所以直接拿&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Electron.IpcMain.Send(mainWindow, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;channelToClient&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;{args}, world!&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; View();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接著就讓我們執行看看，當我們按下按鈕&amp;hellip;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/qdkrpQ5.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/HYo0DUp.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;這樣就能成功在前後端之間傳值了！但要注意，它是建立一個 Channel 來傳遞訊息，所以&lt;strong&gt;兩邊的 channel 名稱可不能錯了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;另外也有提供同步版本的 &lt;code&gt;ipcRendered.sendSync()&lt;/code&gt; 與 &lt;code&gt;Electron.IpcMain.OnSync()&lt;/code&gt; 等等方法，相關的操作可以參照官方的 &lt;a href=&#34;https://github.com/ElectronNET/electron.net-api-demos&#34;&gt;API DEMO&lt;/a&gt; 中的 &lt;code&gt;Controllers/IpcController.cs&lt;/code&gt; 及 &lt;code&gt;Views/Ipc/Index.cshtml&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;而關於 IPC 的說明，可以參考這篇 &lt;a href=&#34;https://medium.com/@terracotta_ko/electron-ipc-%E6%A9%9F%E5%88%B6-2a1b087c9ae5&#34;&gt;[Electron] IPC 機制&lt;/a&gt;，以及官方文件：&lt;a href=&#34;https://www.electronjs.org/docs/api/ipc-main&#34;&gt;ipcMain&lt;/a&gt;、&lt;a href=&#34;https://www.electronjs.org/docs/api/ipc-renderer&#34;&gt;ipcRenderer&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;打包成執行檔exe&#34;&gt;打包成執行檔（.exe）&lt;/h2&gt;
&lt;p&gt;既然是桌面軟體，當然是要包裝成 exe 直接執行囉。畢竟總不能做了個小工具分享給朋友，還要「欸你自己開專案建置一下」吧 XD&lt;/p&gt;
&lt;p&gt;在專案資料夾下用命令列輸入指令 &lt;code&gt;electronize build /target win&lt;/code&gt; ，其中 &lt;code&gt;/target&lt;/code&gt; 除了 win 也可以指定 osx, liunx 等等&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/4iSSuCC.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;編譯需要一段時間，直到看見 &lt;code&gt;done&lt;/code&gt; 就可以了&lt;/p&gt;
&lt;p&gt;編出來的安裝包和執行檔會在 &lt;code&gt;bin\Desktop&lt;/code&gt; 和 &lt;code&gt;bin\Desktop\win-unpacked&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/JKqNsVl.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;稍微打開看看&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Ywg2CoQ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以正常執行！&lt;/p&gt;
&lt;h2 id=&#34;後記&#34;&gt;後記&lt;/h2&gt;
&lt;p&gt;目前只做到專案成功跑起來和一些簡單的測試而已，幸虧黑大的文章跟網路上的一些教學相當完整，並沒有花費太多時間。但是畢竟約好了要玩玩看這個框架，且許多功能沒有試過，例如 &lt;a href=&#34;https://blog.darkthread.net/blog/electron-api-brief/&#34;&gt;Electron.NET API 快速巡覽&lt;/a&gt; 提到的大多功能，&lt;del&gt;因此還在煩惱後續的紀錄要集中在這一篇還是另外開成系列文，這部分等下週更新再說囉。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;6/29 更新: 最後還是決定把最近嘗試的都集中在這一篇了，畢竟我還是挺懶的，這樣比較好找嘛～&lt;/p&gt;
&lt;p&gt;另外有興趣自己試試的朋友，也可以參閱 &lt;a href=&#34;https://www.electronjs.org/docs&#34;&gt;官方文檔&lt;/a&gt; 其實相當完整。基本上只要會寫網頁，就能夠寫桌面 GUI，真是有夠賺。&lt;/p&gt;
&lt;p&gt;最後要特別感謝一下，當我開 Visual Studio 預設的範本時，赫然發現只有 Angular 和 React 的模板可以直接用，竟然沒有 Vue！真是嚇傻我了，幸好最後有找到 &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=alexandredotnet.netcorevuejs&amp;amp;ssr=false#overview&#34;&gt;VueJS with Asp.Net Core 3.1 Web API Template&lt;/a&gt; 才不致落得自造輪子的下場，感謝前輩們和社群的貢獻，南無南無。&lt;/p&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.darkthread.net/blog/electron-net/&#34;&gt;用 ASP.NET Core 寫桌面 GUI 應用程式 - Electron.NET - 黑暗執行緒&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.darkthread.net/blog/electron-api-brief/&#34;&gt;Electron.NET API 快速巡覽 - 黑暗執行緒&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10200819&#34;&gt;ElectronNET : .NET Core+NodeJS做跨平台桌面程式 - iT邦幫忙&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@terracotta_ko/electron-ipc-%E6%A9%9F%E5%88%B6-2a1b087c9ae5&#34;&gt;[Electron] IPC 機制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.electronjs.org/docs&#34;&gt;Electronjs - Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>讀《黑馬思維》</title>
      <link>https://igouist.github.io/post/2020/06/darkhorse/</link>
      <pubDate>Sat, 20 Jun 2020 00:22:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/06/darkhorse/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://kbimages1-a.akamaihd.net/7b5f2f3f-4c9e-45f9-b6e9-a678e7761be5/353/569/90/False/jR89tVf-UjOvjOiRwLSBjw.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每個人都是天才。但如果你用爬樹能力來斷定一條魚有多少才幹，牠整個人生都會相信自己愚蠢不堪。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這邊整理一下這陣子讀&lt;a href=&#34;https://www.books.com.tw/products/0010819494&#34;&gt;《黑馬思維》&lt;/a&gt;這本書的筆記，以及一些個人心得。直接破題說，我個人覺得值得一讀。&lt;/p&gt;
&lt;p&gt;本書的目的是研究那些橫空出世的&lt;strong&gt;黑馬&lt;/strong&gt;。但在研究少數的黑馬之前，就必須先說明何謂多數，所以本書前段著重在介紹什麼是&lt;strong&gt;標準化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;從工業革命至今，為了能大量生產、品質穩定、降低成本、最終達到「&lt;strong&gt;一致、大量、簡單、有效&lt;/strong&gt;」的效果，最直接且有效的做法就是制定流程和規定。不管是製造業，或者是教育，甚至是人生，群眾總是試圖找出一個固定的流程，鋪設一條筆直的道路，並且告訴大家：&lt;strong&gt;只要遵循這個路線，就能夠達到成功&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;雖然比起更加以前的階級制而言，標準化的做法的確更加公平了。然而為了達到標準一致，勢必得要重視群體、忽視個人。標準化的做法將所有人一視同仁，如同工廠的機器，或是程式的流程，&lt;strong&gt;認為設定好的輸入，經過了制定好的流程，就該有期待的產出&lt;/strong&gt;。為了達到標準，因此無法認為每個人是特別的，甚至那些過於特別的，反而對標準化而言是個麻煩。&lt;/p&gt;
&lt;p&gt;標準化的成功很直接：跟別人做一樣的事，但做得更好，就是最佳路線。&lt;/p&gt;
&lt;p&gt;但有一些人，並不遵循標準化建議的路線，仍然取得了成功，他們就是黑馬。在個人化崛起的這個時代，媒體、醫療、廣告，甚至教育都開始有了量身打造的選項，隨處可見精準投放，個人菜單，標準化漸漸被個人化取代，於是作者們提出了疑問：什麼是「&lt;strong&gt;個人化的成功&lt;/strong&gt;」呢？他們開始研究這些黑馬。&lt;/p&gt;
&lt;p&gt;直接結論：黑馬們的個性、背景和領域都不大一樣，然而他們有一部分是相似的。有些人說：我認為自己做的事情是值得的，有些人說他感覺到熱忱，也有人說這是他的天職。&lt;strong&gt;黑馬的共通點在於：他們都並非為了想要成功或是達到目標才努力前進，而是靠著追求自我實現而成就卓越&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Chase Excellence, Success will follow. - 3 Idiots&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而對於這些黑馬如何追求自我實現，如何走出和標準化不同的路。本書提出以下四個重點：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;知道你的微動力&lt;/li&gt;
&lt;li&gt;清楚你的選擇&lt;/li&gt;
&lt;li&gt;了解你的策略&lt;/li&gt;
&lt;li&gt;忽略你的目的地&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;知道你的微動力&#34;&gt;知道你的微動力&lt;/h2&gt;
&lt;p&gt;說起來很直接：&lt;strong&gt;嘗試去弄清楚：什麼對你最重要？你渴望什麼？不渴望什麼？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;標準化提升動力的方式著重在整體，例如辦公室喜歡更換座位，班級有共同獎章等等，然而那並不等於個人的動力；標準化也常提出大方向的動力，例如成長。誰不想要成長呢？但並不是對所有人有效，只一昧喊著要成長要成長，既虛幻又遙遠。我們需要的是確實一點的動力。&lt;/p&gt;
&lt;p&gt;因此，觀察自己對什麼有動力是相當重要的。書中舉了相當多例子，諸如喜歡整理實際空間，喜歡立體文物等等。微動力也可以分得很細，賞鳥就能分成喜歡看的和喜歡聽的。去觀察、找出自已的微動力，並思考如何應用它，讓生計結合天性，才能更有動力，也更加快樂。&lt;/p&gt;
&lt;p&gt;但要觀察自己的動力是不容易的，因此書中提出了&lt;strong&gt;評判遊戲&lt;/strong&gt;。稍微留意一下，&lt;strong&gt;你什麼時候會評判別人？當你評判別人的時候，為什麼會有這些感覺？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;書中的例子如下：如果你評判說「追逐名利的人怎麼會快樂」，那可以知道名利對你可能不太重要；而如果評判「這傢伙只是個修沙發的，哪有可能多成功」則可以推論出地位跟讚揚可能對你很重要。&lt;strong&gt;微動力了解的越仔細越有幫助，掌握的越多越能夠有機會把他們互相結合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;善加留意你自己的想法，去剖析自己，如此才能更了解自己。&lt;/p&gt;
&lt;p&gt;而找出動力之後，令我最驚訝的部分是：書中並不建議單純遵循著自己的熱情行事。相反的，應該要&lt;strong&gt;打造自己的熱情&lt;/strong&gt;。遵循熱情是很簡單的，然而，這些動力會隨著時間轉變。打造熱情就比較辛苦，必須&lt;strong&gt;主動地去整理、了解自己的動力，根據不同機會和要求去啟動不同的微動力&lt;/strong&gt;，如此長久下來的報酬將會相當可觀，並且也更有彈性。&lt;/p&gt;
&lt;p&gt;至少哪天你熱情燒盡不想幹了，你能知道你想做的其他動力，而不會茫然失措；而在你動力尚存時，你也能明白自己在做什麼，而能夠保持熱情。&lt;/p&gt;
&lt;h2 id=&#34;清楚你的選擇&#34;&gt;清楚你的選擇&lt;/h2&gt;
&lt;p&gt;標準化的制度下，有許多看似選擇，實際上卻是被揀選的情況。例如我們的大考，似乎是你考了分數，然後你主動選擇了這些學校；但實際上，是這些學校先選好要不要錄取你，你只能從被決定好的選項之中挑一個。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;選擇是一個主動的行為。你有選擇的自由，可以自己創造甚至沒有人考慮過的機會。&lt;/p&gt;
&lt;p&gt;挑揀則是一個被動的行為。你挑揀一個別人給的選項，等於是別人替你真正做了選擇，你只是從他們替你準備的巧克力盒裡挑一顆來吃。 -《黑馬思維》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;關於選擇和揀選的關係，我個人推薦這篇「&lt;a href=&#34;https://opinion.udn.com/opinion/story/6685/382755&#34;&gt;佩迪特的共和主義 —— 一種對自由的理解&lt;/a&gt;」，內文中舉例的馬兒、不被阻擾及不被干涉的差別，我認為和選擇與揀選的差別是一致的。&lt;/p&gt;
&lt;p&gt;當然，如同書中所述，有些人主張：如果選擇過多，就等於無法選擇。這是合理的，而書中的對應我認為相當精采易懂：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你是一隻鳥，你會選擇住哪？亞馬遜盆地的熱帶雨林？緯度很高的青藏高原？明尼蘇達州淒冷的湖邊？&lt;/p&gt;
&lt;p&gt;選項這麼多，要做出選擇還真是非常棘手。不過如果你是一隻鳥，做選擇一點也不難：你是哪種鳥，就選哪種棲地。 -《黑馬思維》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;按照你所了解的自己，你的特質、你的動力去做選擇就可以了。只要你足夠了解你自己，自然就能做出選擇，需要考量的問題只在於：&lt;strong&gt;你自身的微動力和這個選擇契不契合？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;標準化著重於成功的機率，而這是整體的機率，不是你的。你應該衡量你自己，考量你的動力，著重於你自己。掌握你自己，就能清楚你的選擇。&lt;/p&gt;
&lt;h2 id=&#34;了解你的策略&#34;&gt;了解你的策略&lt;/h2&gt;
&lt;p&gt;有在玩遊戲的人，不論是槍戰、棋類甚至動作遊戲，應該都很清楚一個道理：沒有最佳策略，只有當下最適合的策略；大方向儘管一致，但細節決定勝負。對於黑馬來說，當下最好的策略就是&lt;strong&gt;找出最適合你的策略&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;書中舉了相當多例子來展示策略的多樣性，例如魔術方塊的解法，品酒師對酒類的記憶法等等。這是相當合理的，要前往一個地方的路線本來就不只一種，最大的問題在於：&lt;strong&gt;我要怎麼知道哪個路線適合我？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;黑馬思維的答案是：&lt;strong&gt;嘗試&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;強項對我們而言是很模糊的，我們能知道想不想看電影，卻很難知道我們某個領域有多強。譬如說：你要怎麼知道你天生多會騎河馬？&lt;/p&gt;
&lt;p&gt;強項關乎情境，且持續變動。我們必須嘗試，才能了解我們大致上的水平。比對標準化要求的策略大多是堅持到底，黑馬要求多加嘗試。&lt;strong&gt;只有經由嘗試，才能掌握現有的狀況，也才能逐步修正策略&lt;/strong&gt;。就我來說，這和迭代開發有著異曲同工之妙。&lt;/p&gt;
&lt;h2 id=&#34;忽略你的目的地&#34;&gt;忽略你的目的地&lt;/h2&gt;
&lt;p&gt;本書認為目的地對自我實現是有害的，對於標準化來說，提供一個目的地有助於一致性，但對個人而言卻不一定如此。&lt;/p&gt;
&lt;p&gt;設定好的目的地會令人要求預計時間、要求進度、要求妥善規劃。然而現在的社會變動迅速，人生過程變數太多，每個人做同樣的事花費時間又不同，因此目的地的飄忽不定，反倒是一種束縛，綁死了你策略上的彈性，和可選擇的道路。&lt;/p&gt;
&lt;p&gt;與其決定成為某個行業，再去蒐集那些行業的特質，然後花費一個預期的時間前進；不如&lt;strong&gt;先確定自己的特質，再逐步前進，看自己的特質和策略能到達哪裡&lt;/strong&gt;。後者無疑更量身訂造。&lt;/p&gt;
&lt;p&gt;然而要注意！目的地和目標是不同的，我們用遠近，或是可不可見的界線去區分它。&lt;strong&gt;目標是你個人的選擇，相當具體，能夠採取行動；目的地則是大家口中的目標，難以預測，相當遙遠&lt;/strong&gt;，兩者其實在直覺上相當好區分：在截稿日前寫完，是目標；得到諾貝爾文學獎，則是目的地。&lt;/p&gt;
&lt;p&gt;其實我個人覺得這個概念很好接受，在前進的路上，你並不會挑個目的地然後就筆直撞過去，而是會朝某個大方向，一步一步地前進。書中用 &lt;a href=&#34;https://zhuanlan.zhihu.com/p/36902908&#34;&gt;梯度上升法&lt;/a&gt; 來舉例，每一步都選更高的方向前進，那麼就能夠走到山頂。（雖然在這邊看到這詞時總感覺有點妙就是了）&lt;/p&gt;
&lt;p&gt;本段其實是呼應最一開始的「他們並非為了達到卓越才實現自我，而是靠著追求自我實現而成就卓越」，從了解自己的動力，到不斷嘗試和修正策略。因此，如果能理解前面章節的內容，忽略目的地也是順其自然就會發生的事而已了。&lt;/p&gt;
&lt;h2 id=&#34;黑馬或是標準化&#34;&gt;黑馬或是標準化&lt;/h2&gt;
&lt;p&gt;書的後半篇幅多用於描述黑馬和標準化的差異，以及對現存制度的探討。儘管黑馬看起來人人都可以嘗試，但並不代表黑馬就得取代標準化，有些人在標準化的制度中更能取得優勢，那也是一種選擇。&lt;/p&gt;
&lt;p&gt;本書的重點在於了解，甚至接受每個人都可以有選擇：你可以為自己負責，你可以選擇體制或是黑馬甚至是更多的路線，你能發掘自身的動力，你能夠追求自我實現。如同書中所引的，每個人都有追求幸福的權利。&lt;/p&gt;
&lt;h2 id=&#34;心得&#34;&gt;心得&lt;/h2&gt;
&lt;p&gt;本來只想大略介紹一段，想不到翻著翻著就越寫越多，弄得書的介紹比心得還長上幾倍。儘管如此，我仍覺得我無法精準或是完整地表達黑馬思維所要傳達的意思，因此如果有興趣的話，還是非常推薦親自讀過一遍，自己讀過一次勝過閱讀十篇心得。&lt;/p&gt;
&lt;p&gt;黑馬思維的結構非常明確：&lt;strong&gt;掌握（自己的）各項情報、選定方向、建立選擇時的準則、制定遇到狀況的做法、逐步調整、並且在當下行動&lt;/strong&gt;。我覺得這並不是太特別的邏輯，甚至可以說是決策的通則。舉凡卡牌和戰略遊戲、行程規劃、開發專案或是各種領域，大抵都可以按照這個步驟去處理。&lt;/p&gt;
&lt;p&gt;以我之前喜歡的卡牌或爬塔遊戲為例：你得先了解你有哪些牌能用，你有越多的牌，能做的選擇和搭配就越多。接著就是分清楚，哪些牌值得使用、哪些牌可以組合使用、又該在什麼場合使用？這些牌所組成的目標牌組，主要的策略是什麼？正好與微動力、選擇和策略不謀而合。&lt;/p&gt;
&lt;p&gt;然而過程中的每一步能做到多少、能否判斷出最合適的選擇、策略是否經得起狀況的考驗，就是真正的差別。如果不去瞭解，你不會知道你的動力在哪；如果不去嘗試，你不會知道你的策略多可靠。&lt;/p&gt;
&lt;p&gt;之前聽過一句話：&lt;strong&gt;你個人就是一個品牌，你要把自己當成品牌去經營&lt;/strong&gt;。那麼，你就得要知道自己的優勢、知道自己的劣勢，知道其他人用的策略並不一定適合你，去嘗試分析適合你自己的模式。如此一來，才談得上是在經營自己。因此，誠摯地推薦可以嘗試去閱讀過這本黑馬思維，也許能因此找到新的路線也說不定呢。&lt;/p&gt;
&lt;p&gt;當然，我在看這本書的時候也不是沒有疑惑。例如說，研究那些已經成功的黑馬，算不算是一種倖存者偏差呢？後來終於想通，本書更多的是在於宣導一種理念，是希望每個人都能從中找到自己的動力，因此對於實踐的方式著墨甚少，例如&lt;a href=&#34;https://www.books.com.tw/products/0010822522&#34;&gt;我該如何打造我自己的熱情？&lt;/a&gt;或是&lt;a href=&#34;https://www.books.com.tw/products/0010752714&#34;&gt;我該如何掌握並提升我的強項？&lt;/a&gt;這些都是可以進一步討論的部分。但整體來說，黑馬思維值得一讀，也許之後還會再整理相關的心得吧！下次見。&lt;/p&gt;
&lt;h2 id=&#34;延伸閱讀&#34;&gt;延伸閱讀&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://readingoutpost.com/dark-horse/&#34;&gt;《黑馬思維》讀書心得：尋找熱情前必問自己這6個問題&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/%E4%B8%80%E5%80%8B%E4%BA%BA%E7%9A%84%E6%96%87%E8%97%9D%E5%BE%A9%E8%88%88/%E9%BB%91%E9%A6%AC%E6%80%9D%E7%B6%AD-%E6%91%98%E8%A6%81-d6bdeedc5aae&#34;&gt;《黑馬思維》摘要&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>C#: 位元旗標 (Bit flag) 與列舉</title>
      <link>https://igouist.github.io/post/2020/06/bit-flags-and-enum/</link>
      <pubDate>Sun, 14 Jun 2020 21:27:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/06/bit-flags-and-enum/</guid>
      <description>&lt;p&gt;前陣子碰到個資料表儲存方式，因為這種位元運算的方式也常用在權限管理等地方，這邊就順手紀錄一下。&lt;/p&gt;
&lt;p&gt;平常遇到二元的情形（例如 開／關、有／沒有），我們會直接宣告個 Boolean 來處理。但這次遇到的是同時有多個「有／沒有」的狀況，但我遇到的程式碼並沒有分成多個 Bool 去做處理，而是直接儲存成一個數值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由於「有／沒有」只佔據一個位元，那麼將多個狀況按照位元順序排列的話，就只需要一個數字就可以紀錄或傳遞給其他系統了&lt;/strong&gt;。例如最常見的用處是在權限系統，若有「讀」、「寫」、「執行」等權限，那麼我們按照這個順序去排列，當 &lt;code&gt;讀＝可、寫＝不可、執行＝可&lt;/code&gt; 的時候，就記做 &lt;code&gt;101&lt;/code&gt; = &lt;code&gt;5&lt;/code&gt;。這種直接用一組位元表示狀態的方式就叫做&lt;strong&gt;位元旗標（Bit flag）&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1 讀   = 可
0 寫   = 不可
1 執行 = 可

/* 橫放 */
=&amp;gt; 101 (2進位) 
=&amp;gt; 5 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;假使某天老闆靈光一現，決定接下來的新人員工都要記錄他們會的程式語言，並且他們報到的時候就會發一張公司列好的程式語言清單請他們勾選。&lt;/p&gt;
&lt;h2 id=&#34;enum--flags&#34;&gt;Enum &amp;amp; Flags&lt;/h2&gt;
&lt;p&gt;在 C# 中已經有方便的工具可以處理數字列表，我們可以建立一個叫做 SkillEnum 的&lt;strong&gt;列舉（Enum）&lt;/strong&gt;，並且按照上面說明的，將老闆提到的每個技能各自用一個位元來表示。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[Flags]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; SkillEnum
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    C = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,     &lt;span style=&#34;color:#75715e&#34;&gt;// 0001&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    PHP = &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,   &lt;span style=&#34;color:#75715e&#34;&gt;// 0010&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    SQL = &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;,   &lt;span style=&#34;color:#75715e&#34;&gt;// 0100&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Java = &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;,  &lt;span style=&#34;color:#75715e&#34;&gt;// 1000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;註：&lt;code&gt;[Flags]&lt;/code&gt;的標籤是指 C# 專門提供給位元旗標使用的 Enum，請參見 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/api/system.flagsattribute?view=netcore-3.1&#34;&gt;FlagsAttribute&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;只要在 enum 上加上 Flags 的屬性，除了自動按照 2 的次元增加以外，在使用 ToString() 也能更方便看見旗標內容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有了這個列舉之後，我們就可以&lt;strong&gt;表達不同排列組合的狀況&lt;/strong&gt;了。例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;* C: C
* P: PHP
* S: SQL
* J: Java
===========
J S P C
0 0 0 0 =&amp;gt; 什麼都不會
0 0 0 1 =&amp;gt; 只會 C
0 0 1 1 =&amp;gt; 同時會 C 和 PHP
1 0 1 0 =&amp;gt; 同時 PHP 和 Java
1 1 1 1 =&amp;gt; 全部都會
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;查詢--and&#34;&gt;查詢 =&amp;gt; AND&lt;/h2&gt;
&lt;p&gt;那麼假使今天來的新人 Bob，他會 C, PHP 兩種語言，那現在他的資料欄位，就會是這兩種語言對應的位置為 1，其餘為 0，也就是 &lt;code&gt;0011&lt;/code&gt; =  &lt;code&gt;3&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; BobSkills = &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// var BobSkills = 0b_0011; // C + PHP&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;當 &lt;strong&gt;查詢&lt;/strong&gt; 的時候，就將 Bob 的數值和目標數值做 &lt;strong&gt;&lt;code&gt;AND&lt;/code&gt;&lt;/strong&gt; 運算。例如說我們想知道 Bob 會不會 C，就可以將 &lt;code&gt;3&lt;/code&gt;（二進位 &lt;code&gt;0011&lt;/code&gt;） 和代表 C 的 &lt;code&gt;1&lt;/code&gt; （二進位 &lt;code&gt;0001&lt;/code&gt;） 做 &lt;code&gt;&amp;amp;&lt;/code&gt;，即可知道 Bob 會不會 C。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    J S P C
    0 0 1 1 Bob
AND 0 0 0 1 SkillEnum.C
-----------
    0 0 0 1 =&amp;gt; 1 &amp;gt; 0 =&amp;gt; True
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    J S P C
    0 0 1 1 Bob
AND 1 0 0 0 SkillEnum.Java
-----------
    0 0 0 0 =&amp;gt; 0 =&amp;gt; False
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也就是必須要 &lt;strong&gt;同個位置的值都是 1&lt;/strong&gt;，在這邊就是指 Bob 的技能中 Java 的欄位，和 SkillEnum 中對應的欄位都要是 1 的時候，才會有數值。否則就會是 0：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; BobSkills = &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// var BobSkills = 0b_0011; // C + PHP&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 確認是否有某個 Flag，使用 And(&amp;amp;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; isBobKnowC = BobSkills &amp;amp; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)SkillEnum.C;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;Bob 會使用 C 嗎？{Convert.ToBoolean(isBobKnowC)}&amp;#34;&lt;/span&gt;.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// True&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; isBobKnowJava = BobSkills &amp;amp; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)SkillEnum.Java;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;Bob 會使用 Java 嗎？{Convert.ToBoolean(isBobKnowJava)}&amp;#34;&lt;/span&gt;.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;賦予--or&#34;&gt;賦予 =&amp;gt; OR&lt;/h2&gt;
&lt;p&gt;那假設 Bob 經過一番苦練，又掌握了 SQL 這門語言呢？當我們要 &lt;strong&gt;賦予&lt;/strong&gt; 的時候，就需要用 &lt;strong&gt;&lt;code&gt;OR&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;也就是當 &lt;strong&gt;兩者之間任一為 1&lt;/strong&gt; 的時候，在這邊也就是當 Bob 的技能和我們要求給他的 SkillEnum 同位置只要有一個是 1，那就會有數值：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    J S P C
    0 0 1 1 Bob
 OR 0 1 0 0 SkillEnum.SQL
-----------
    0 1 1 1 =&amp;gt; New Bob
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如說原本 Bob 不會 SQL，所以 SQL 那一欄就會是 0 。而我們把它和 SkillEnum.SQL（也就是只有 SQL 那一欄是 1 ）做 OR 運算後，接著我們只要將運算好的結果再賦值給 Bob，這樣 Bob 的 SQL 欄位就會變成 1 了，同時也不會影響到其他欄位。&lt;/p&gt;
&lt;p&gt;現在我們就可以用 &lt;code&gt;OR&lt;/code&gt; 把 SQL 的技能傳授給 Bob：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; isBobKnowSQL = BobSkills &amp;amp; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)SkillEnum.SQL;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;Bob 會使用 SQL 嗎？{Convert.ToBoolean(isBobKnowSQL)}&amp;#34;&lt;/span&gt;.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 賦予某個 Flag，使用 OR (|)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BobSkills = BobSkills | (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)SkillEnum.SQL;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;（Bob 學習 SQL 中）&amp;#34;&lt;/span&gt;.Dump();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;isBobKnowSQL = BobSkills &amp;amp; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)SkillEnum.SQL;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;Bob 會使用 SQL 嗎？{Convert.ToBoolean(isBobKnowSQL)}&amp;#34;&lt;/span&gt;.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// True&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;移除--xor&#34;&gt;移除 =&amp;gt; XOR&lt;/h2&gt;
&lt;p&gt;經過了很久很久以後，Bob 已經忘記當年學的 SQL 怎麼寫了。我們又要怎麼把他的 SQL 這項技能給拿掉呢？&lt;/p&gt;
&lt;p&gt;當我們要 &lt;strong&gt;移除&lt;/strong&gt; 某一項旗標的時候，只需要使用 &lt;strong&gt;&lt;code&gt;XOR&lt;/code&gt;&lt;/strong&gt; 就行了。&lt;strong&gt;&lt;code&gt;XOR&lt;/code&gt; 是指互斥，就像磁碟兩極一樣。當兩者不同為 1，若相同時則為 0&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因此當 Bob 代表 SQL 的欄位為 1 的時候，我們再將 SQL 為 1 的 的數值丟進去做 XOR，就可以把&lt;strong&gt;兩者同時為 &lt;code&gt;1&lt;/code&gt; 的欄位給變回 0&lt;/strong&gt;，並且讓原本為 1 的欄位持續為 1，原本為 0 的欄位持續為 0，達到移除指定目標的效果。&lt;/p&gt;
&lt;p&gt;但在使用上要注意，必須&lt;strong&gt;先確認目標欄位的確有數值&lt;/strong&gt;，也就是 Bob 是真的已經會 SQL，&lt;strong&gt;否則&lt;/strong&gt;若原本不會 (0) 的將不小心學會 (0 XOR 1 =&amp;gt; 1)。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    J S P C
    0 1 1 1 Bob
XOR 0 1 0 0 SkillEnum.SQL
-----------
    0 0 1 1 =&amp;gt; New Bob

// 警告：使用 XOR 之前一定要先檢查，若原本是關閉 (0) 的將會被打開 (0 XOR 1 =&amp;gt; 1)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;現在我們就讓 Bob 忘記他曾經學過的 SQL：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;isBobKnowSQL = BobSkills &amp;amp; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)SkillEnum.SQL;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;Bob 會使用 SQL 嗎？{Convert.ToBoolean(isBobKnowSQL)}&amp;#34;&lt;/span&gt;.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// True&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 挪除某個 Flag，使用 XOR (^)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BobSkills = BobSkills ^ (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)SkillEnum.SQL;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;（Bob ... 忘記了SQL！）&amp;#34;&lt;/span&gt;.Dump();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;isBobKnowSQL = BobSkills &amp;amp; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)SkillEnum.SQL;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;Bob 會使用 SQL 嗎？{Convert.ToBoolean(isBobKnowSQL)}&amp;#34;&lt;/span&gt;.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;多項賦予--or-or-or&#34;&gt;多項賦予 =&amp;gt; OR, OR, OR&lt;/h2&gt;
&lt;p&gt;隨著 Bob 逐漸老去，公司也招來了新員工。如今換成 Bob 來幫他維護技能表了，那我們要怎麼用 SkillEnum 給這個菜雞&lt;strong&gt;預設值&lt;/strong&gt;呢？&lt;/p&gt;
&lt;p&gt;聰明的你應該能猜出其實這也就是賦值！只要把&lt;strong&gt;有的項目全部 OR 起來&lt;/strong&gt;就可以了，這位新菜雞他會 C, SQL, Java：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    J S P C
    0 0 0 0 Newbie
 OR 0 0 0 1 SkillEnum.C
 OR 0 1 0 0 SkillEnum.SQL
 OR 1 0 0 0 SkillEnum.Java
-----------
    1 1 0 1 =&amp;gt; 13 =&amp;gt; Newbie&amp;#39;s Skills
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那麼現在就讓我們用 C# 實作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 賦與多個值 ＝ 一路 OR 下去&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; NewbieSkills =    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)SkillEnum.C |   
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)SkillEnum.SQL |     
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)SkillEnum.Java; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;Bob 技能欄的十進位為：{NewbieSkills}&amp;#34;&lt;/span&gt;.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// 13&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;Bob 技能欄的二進位為：{Convert.ToString(NewbieSkills, 2)}&amp;#34;&lt;/span&gt;.Dump(); &lt;span style=&#34;color:#75715e&#34;&gt;// 1101&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;列出內容--foreach-flags&#34;&gt;列出內容 =&amp;gt; Foreach, Flags&lt;/h2&gt;
&lt;p&gt;那如果我想要確認現在有哪些欄位是開啟的呢？例如說，當我們要確認 Bob 會哪些程式語言的時候怎麼做呢？&lt;/p&gt;
&lt;p&gt;既然用 AND 可以查詢其中一個位置，那麼只要將列舉和位元用迴圈逐一 AND 出來，就可以還原 Bob 的列表囉&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; enumCount = Enum.GetNames(&lt;span style=&#34;color:#66d9ef&#34;&gt;typeof&lt;/span&gt;(SkillEnum)).Count();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; NewbieSkillsList = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; List&amp;lt;&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;&amp;gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; i = &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &amp;lt; enumCount; i++)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(Convert.ToBoolean(Bob2Skills &amp;amp; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)Math.Pow(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, i))) &lt;span style=&#34;color:#75715e&#34;&gt;// AND 運算&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        NewbieSkillsList.Add(((SkillEnum)Math.Pow(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, i)).ToString());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;Newbie 會的語言有：{String.Join(&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;, NewbieSkillsList)}&amp;#34;&lt;/span&gt;.Dump();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// C, SQL, Java&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;不過上面這個依序列印的方式還是太麻煩了。如果有像前半段提到的，&lt;strong&gt;替 Enum 加上 &lt;code&gt;[Flags]&lt;/code&gt; 標籤&lt;/strong&gt;的話，用起來就更簡單了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;$&amp;#34;Newbie 掌握的技能為：{(SkillEnum)NewbieSkills}&amp;#34;&lt;/span&gt;.Dump(); 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// C, SQL, Java&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最後再總結一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;檢查的時候用 &lt;code&gt;AND&lt;/code&gt; 找出目標的位置是否為 1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;賦予內容時則用 &lt;code&gt;OR&lt;/code&gt; 讓指定的位置變成 1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;移除的時候則用 &lt;code&gt;XOR&lt;/code&gt; 讓目標位置的 1 抵銷為 0&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整理來說概念並不困難，只是一個位元對應一個對象，再視情況進行運算而已。但能應用的範圍相當廣泛，除了最常用的權限管理，其他諸如活動月份、門鎖狀況等等只要符合條件的情形都可以借這個方法來處理。這邊稍作紀錄，希望以後能派上用場。&lt;/p&gt;
&lt;h2 id=&#34;延伸閱讀及參考資料&#34;&gt;延伸閱讀及參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@kazafchen/%E4%B8%80%E4%BB%B6intent%E6%95%99%E6%88%91%E7%9A%84%E4%BA%8B-bitwise-operation-dd3a388ae34e&#34;&gt;一件Intent教我的事： Bitwise Operation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/700165/&#34;&gt;JavaScript中的位運算和權限設計&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;補一下原出處： &lt;a href=&#34;https://juejin.im/post/5dc36f39e51d4529ed292910&#34;&gt;JavaScript 中的位运算和权限设计 - 掘金&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://shunnien.github.io/2017/06/27/byte-operator-auth/&#34;&gt;位元運算與權限控制 - ShunNien&amp;rsquo;s Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://matthung0807.blogspot.com/2019/02/java-bit-flag.html&#34;&gt;Java bit flag - 菜鳥工程師肉豬&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/34021773&#34;&gt;在写代码的过程中使用位运算的好处？ - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/262652908eb8&#34;&gt;位运算和权限管理系统 - 簡書&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blogs.uuu.com.tw/Articles/post/2017/06/14/%E4%BD%BF%E7%94%A8%E5%88%97%E8%88%89%E8%88%87%E6%97%97%E6%A8%99%E8%A8%AD%E8%A8%88%E5%A4%9A%E9%81%B8.aspx&#34;&gt;使用列舉與旗標設計多選 - ProgrammerXDB Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/Chmod&#34;&gt;Chmod - 維基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.podkalicki.com/bit-level-operations-bit-flags-and-bit-masks/&#34;&gt;Bit-level operations – bit flags and bit masks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>WakaTime —— 我 Coding 了多久？</title>
      <link>https://igouist.github.io/post/2020/06/wakatime/</link>
      <pubDate>Sun, 07 Jun 2020 22:10:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/06/wakatime/</guid>
      <description>&lt;p&gt;這一周又是 &lt;del&gt;偷懶週&lt;/del&gt; 繁忙週，因此就跟大家分享一個有趣的網站：&lt;a href=&#34;https://wakatime.com/&#34;&gt;WakaTime&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;WakaTime 能夠幫你自動記錄寫程式的時間、常用語言及專案，只要簡單地在常用的 IDE 設定好擴充套件就可以達成。 WakaTime 支援的 IDE 可以參閱 &lt;a href=&#34;https://wakatime.com/plugins&#34;&gt;WakaTime - Plugin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;註冊相當簡單，此處就不贅述。稍微介紹一下儀表板的各區塊的功能：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/wd1LZLr.png&#34; alt=&#34;&#34;&gt;
左上會有最近的專案及花費時間，每個色塊都是一個專案，滑鼠移上去就會顯示專案名稱。&lt;/p&gt;
&lt;p&gt;點擊其中一天更會顯示當天的時間軸，可說是無所遁形。至於它判斷專案名稱的方法是看你編輯的檔案所在的資料夾名稱。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/2icNzlL.png&#34; alt=&#34;&#34;&gt;
右上是編寫和測試的所佔時間，不過我在使用的時候常常抓不到測試和建置的時間，因此沒在意過。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ic7NGAE.png&#34; alt=&#34;&#34;&gt;
正左則是當天的時間軸和某幾段時間正在處理的專案，可以清楚看到大概哪個時段在認真 Coding（因為都是公司專案，這邊就先碼一下）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Qzu0ucB.png&#34; alt=&#34;&#34;&gt;
正右則是達到目標的比例，WakaTime 可以到左側選單的 &lt;code&gt;Goal&lt;/code&gt; 設定個人目標，例如每週幾個小時，就可以在這邊看自己當天的達成率如何。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/nu640EP.png&#34; alt=&#34;&#34;&gt;
左下則是最近常使用的語言和比例，主要是抓取編輯中檔案的副檔名自動判定。另外也能到 &lt;code&gt;Settings -&amp;gt; Custom Rules&lt;/code&gt; 去設定個人化的規則，例如我個人就會將 .ipynb 計時到 Python 中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Bu5df8N.png&#34; alt=&#34;&#34;&gt;
右下就很直覺，就是紀錄常用的 IDE 的時間，像我個人挺偏食的，就不常看到這裡。不過一些用瀏覽器的 Coding 方式就不太適用，像我常用的 Jupyter notebook 基本上就是抓不到，許願希望之後的 Chrome 能支援。&lt;/p&gt;
&lt;p&gt;除了上面這些區塊，往下拉也可以看到最近的專案耗費的時間，可以看看最近耗費比較多的專案有哪些。&lt;/p&gt;
&lt;h2 id=&#34;環境設定&#34;&gt;環境設定&lt;/h2&gt;
&lt;p&gt;WakaTime 主打的就是輕便、自動計時。因此設定步驟也相當簡單，各 IDE 的設定步驟可以從 &lt;a href=&#34;https://wakatime.com/plugins&#34;&gt;WakaTime - Plugin&lt;/a&gt; 裡點選自己用的 IDE 進去看安裝介紹。這邊就以我最常用的 Visual Studio 做示範。&lt;/p&gt;
&lt;p&gt;首先點選 Wakatime 右上角的 個人頭像，進入 Settings，確認左側在 Account，這時應該能看到自己的 API Key，點選顯示之後先複製下來。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/pvbaKAT.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;之後打開你的 Visual Studio，上方工具列點選 &lt;code&gt;延伸模組 -&amp;gt; 管理延伸模組&lt;/code&gt;，開啟模組管理員之後選擇 線上，搜尋 Wakatime 並安裝。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Aj6q2XL.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;重啟 Visual studio 並安裝完畢後，再度打開時應該會自動跳出設定畫面；如果沒有跳出來，也可以從上方工具列點選 &lt;code&gt;工具 -&amp;gt; WakaTime -&amp;gt; Settings&lt;/code&gt; 進入設定畫面&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Agrd4QS.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;設定畫面如下，將剛剛複製的 API Key 貼上。如果是在公司或是有需要設定 Proxy 的地方記得也順便填一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/eFCfNv4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;這樣就設定完囉！是不是很簡單呢？之後當使用 Visual Studio 寫程式的時候，就會自動記下 時間、程式類型、資料夾名稱並傳到 Wakatime 做統計囉&lt;/p&gt;
&lt;p&gt;當然，對於背景紀錄資料有疑慮的朋友，也可以直接翻 &lt;a href=&#34;https://github.com/wakatime&#34;&gt;WakaTime 的 Github&lt;/a&gt;。這個套件是完全開源的。如果嫌使用擴充太無聊或是想自己開發個比較好看的儀表板的朋友，也可以參閱 &lt;a href=&#34;https://wakatime.com/developers&#34;&gt;Wakatime 的開發者頁面&lt;/a&gt;呦。&lt;/p&gt;
&lt;p&gt;最後關於紀錄的部分，之前有看到實測說單純掛網走人是不會算時數的。不過會這樣做的人，本來也就沒什麼動機去用這類時間記錄的工具吧！&lt;/p&gt;
&lt;h2 id=&#34;後記&#34;&gt;後記&lt;/h2&gt;
&lt;p&gt;要注意，免費用戶只能看最近 14 天的紀錄，要看完整紀錄就必須 &lt;a href=&#34;https://wakatime.com/pricing?utm_source=magic-panda-engineer&#34;&gt;付費&lt;/a&gt;，我個人因為是看心情愉快的，因此免費版已經很符合我的需求。若是使用多個 IDE 或想當成時數管理的朋友，又或者是想戰 &lt;a href=&#34;https://wakatime.com/leaders&#34;&gt;排行榜&lt;/a&gt; 的朋友，可以使用一陣子再考慮囉。但要強調，紀錄時間只是做為參考使用，並非工作的標準喲！畢竟弄文件跟查 Bug 更花時間嘛。&lt;/p&gt;
&lt;p&gt;雖然又水了一篇，不過也是挺想把這東西介紹給大家用用看。雖然我個人做時間紀錄大多是使用 &lt;a href=&#34;https://www.playpcesor.com/2016/11/toggl-time-track.html&#34;&gt;Toggl&lt;/a&gt; 來計時，不過偶而開 WakaTime 看看自己最近花多少時間在 Coding？都在寫什麼？專案之間的時間分配得如何？就有種更能掌握自己最近都在忙些什麼的感覺。有時看到柱狀圖一排高聳，或是連續幾周達成目標，就會更有戰鬥力的感覺；若是發現最近時數低落，也會心虛想要彌補一點。如此也是挺有一番趣味，共勉之。&lt;/p&gt;
&lt;h2 id=&#34;延伸閱讀&#34;&gt;延伸閱讀&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/code-and-me/%E7%94%A8-wakatime-%E8%87%AA%E6%88%91%E7%9B%A3%E6%8E%A7-f59599144e28&#34;&gt;用 WakaTime 自我監控&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://magic-panda-engineer.github.io/tools/wakatime-for-time-management&#34;&gt;利用 Wakatime 來掌握寫程式的時間&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://demo.tc/post/visual%20studio%20%E5%B7%A5%E4%BD%9C%E6%99%82%E9%96%93%E8%A8%98%E9%8C%84%E5%A5%97%E4%BB%B6%20-%20codealike&#34;&gt;Visual Studio 工作時間記錄套件 - Codealike&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.playpcesor.com/2018/11/rescuetime.html&#34;&gt;RescueTime 拯救時間利器上手教學，自動時間記錄與生產力評分&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>我要訂便當 (5): Heroku 填坑小記</title>
      <link>https://igouist.github.io/post/2020/05/bandon-5-heroku-debug/</link>
      <pubDate>Sun, 31 May 2020 23:24:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/05/bandon-5-heroku-debug/</guid>
      <description>&lt;p&gt;在上一集的 &lt;a href=&#34;https://igouist.github.io/post/2020/05/bandon-4-heroku/&#34;&gt;將 Python 腳本部署上 Heroku&lt;/a&gt; 中，記錄了將 Python 腳本放上 Heroku 的過程，但仍然沒有將我們的 &lt;a href=&#34;https://igouist.github.io/tags/bandon/&#34;&gt;訂便當小幫手&lt;/a&gt; 給放上去。之前有稍微提到是因為過程中遇到了一些問題，最後決定將這些問題和找到的前人解決文記錄在這一篇，將來再遇到的時候就可以參考。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SQLite 要改成用 PostgreSQL&lt;/li&gt;
&lt;li&gt;在 Heroku 上執行 Selenium&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;一sqlite-要改成用-postgresql&#34;&gt;一、SQLite 要改成用 PostgreSQL&lt;/h2&gt;
&lt;p&gt;在之前的 &lt;a href=&#34;https://igouist.github.io/post/2020/03/bandon-2-sqlite/&#34;&gt;我要訂便當(2) —— 用 Python + Sqlite 儲存訂單&lt;/a&gt; 中，為了方便及簡單性，選擇了較輕便的 SQLite 來儲存我們爬回來的訂單資訊。然而，SQLite 將資料儲存在小檔案以便於攜帶的做法，在 Heroku 上將會遭遇像是各個 dyno 的資料不同步等許多問題，因此 Heroku 是不建議使用 SQLite 的。&lt;/p&gt;
&lt;p&gt;在 Heroku 的開發文件中的 &lt;a href=&#34;https://devcenter.heroku.com/articles/sqlite3&#34;&gt;SQLite on Heroku&lt;/a&gt; 有關於這部分的詳細說明，並直接提到「&lt;em&gt;If you were to use SQLite on Heroku, you would lose your entire database at least once every 24 hours.&lt;/em&gt;」同時，官方也提供了他們的建議：&lt;strong&gt;PostgreSQL&lt;/strong&gt;。相較於輕便但只能同時單一寫入而且還會在 dyno 炸掉的 SQLite，PostgreSQL 的完整性更符合 Heroku 對服務的要求。&lt;/p&gt;
&lt;p&gt;關於在 Heroku 上使用 PostgreSQL 的做法，這篇 &lt;a href=&#34;https://swf.com.tw/?p=1327&#34;&gt;佈署 Python Flask 網站留言板應用程式到 Heroku + PostgreSQL 資料庫系統&lt;/a&gt; 說明得相當詳細。&lt;/p&gt;
&lt;p&gt;這邊簡述一下操作過程（當然，還是建議進入上面推薦的網頁直接照圖操作）&lt;/p&gt;
&lt;p&gt;首先，先進到專案的頁面，選擇 Resources 分頁並往下到 Add-on，擴充套件基本上都從這裡開始安裝，事實上遇到的許多問題都會到這裡用擴充套件解決。在此就先輸入 Postgres 並安裝 Heroku Postgres，並且選擇免費方案。&lt;/p&gt;
&lt;p&gt;安裝完畢之後，可以點選 Heroku Postgres 進入擴充套件管理的頁面，這邊進去 Setting 就可以進行相關的設定，也能從這邊取得帳號、密碼及資料庫URL。&lt;/p&gt;
&lt;p&gt;Heroku 部分設定完畢之後，就要回來改我們便當的程式碼。相對於當初 SQLite 時使用的 sqlite3 包，這次要操作 PostgreSQL 則是要使用 python-psycopg2 這個包。&lt;/p&gt;
&lt;p&gt;相關的操作可以參考 Gitbook.net 的這篇 &lt;a href=&#34;http://tw.gitbook.net/postgresql/2013080998.html&#34;&gt;PostgreSQL 連接 Python&lt;/a&gt;。可以發現整體的操作方式和之前使用 sqlite3 並沒有什麼太大的不同，因此略做修改之後就可以使用囉。&lt;/p&gt;
&lt;h3 id=&#34;本區段的參考資料&#34;&gt;本區段的參考資料&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://swf.com.tw/?p=1327&#34;&gt;佈署 Python Flask 網站留言板應用程式到 Heroku + PostgreSQL 資料庫系統&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10199016&#34;&gt;[Ting&amp;rsquo;s筆記Day5] 在部署到Heroku之前，將Rails專案從SQLite設定為PostgreSQL - iT邦幫忙&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tw.gitbook.net/postgresql/2013080998.html&#34;&gt;PostgreSQL 連接 Pytho - Gitbook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://devcenter.heroku.com/articles/sqlite3&#34;&gt;SQLite on Heroku - Heroku Dev Center&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二在-heroku-上執行-selenium&#34;&gt;二、在 Heroku 上執行 Selenium&lt;/h2&gt;
&lt;p&gt;前面的 &lt;a href=&#34;https://igouist.github.io/post/2020/03/bandon-1-selenium/&#34;&gt;我要訂便當(1) —— 用 Python + Selenium 控制瀏覽器取得訂單&lt;/a&gt; 中，能取得訂單內容主要都是依賴於 Selenium 控 chrome 上。然而我們丟上 Heroku 後… 哪來的瀏覽器啊！因此遭遇到了這整個專案最大的存在危機（？）&lt;/p&gt;
&lt;p&gt;幸好後來有找到這篇 &lt;a href=&#34;https://medium.com/@mikelcbrowne/running-chromedriver-with-python-selenium-on-heroku-acc1566d161c&#34;&gt;Running ChromeDriver with Python Selenium on Heroku&lt;/a&gt;，裡面有說明如何順利在 Heroku 上跑 Selenium，實在是相當感謝，這邊也記錄一下。&lt;/p&gt;
&lt;p&gt;我們在前面 &lt;a href=&#34;https://igouist.github.io/post/2020/05/bandon-4-heroku/&#34;&gt;我要訂便當(4-1) —— 將 Python 腳本部署上 Heroku&lt;/a&gt; 有提到，Heroku 有建置包這東西來協助建置專案，也提到 Python 是 heroku-buildpack-python。這邊就是建置包去建出 webdriver，因此使用 &lt;code&gt;heroku buildpacks:add&lt;/code&gt; 的指令去加入 &lt;code&gt;heroku-buildpack-chromedriver heroku buildpa&lt;/code&gt; 這個建置包。&lt;/p&gt;
&lt;p&gt;加入完畢之後，要設定 heroku 的 config 去指定 chrome 和 chrome driver 的路徑&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;heroku config:set GOOGLE_CHROME_BIN=/app/.apt/usr/bin/google_chrome
heroku config:set CHROMEDRIVER_PATH=/app/.chromedriver/bin/chromedriver
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最後只要修改程式就可以囉，一樣先指定好路徑&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;GOOGLE_CHROME_PATH &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/app/.apt/usr/bin/google_chrome&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CHROMEDRIVER_PATH &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/app/.chromedriver/bin/chromedriver&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;並且在設定 selenium 的部份加上一些 chrome 的參數&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;chrome_options&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add_argument(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;--disable-gpu&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;chrome_options&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add_argument(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;--no-sandbox&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;chrome_options&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;binary_location &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GOOGLE_CHROME_PATH
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在初始化 &lt;code&gt;webdriver.Chrome&lt;/code&gt; 一併傳入就可以囉！說起來之前 chrome 被我改壞時，也是靠 -no-sandbox 才開起來的，關於 sandbox ，可以看 Google 的 &lt;a href=&#34;https://www.google.com/googlebooks/chrome/med_26.html&#34;&gt;這篇漫畫&lt;/a&gt;，或是這篇 &lt;a href=&#34;https://www.inside.com.tw/article/14031-google-chrome-browser-10-years-history&#34;&gt;Inside 的簡單介紹&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;本區段的參考資料-1&#34;&gt;本區段的參考資料&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@mikelcbrowne/running-chromedriver-with-python-selenium-on-heroku-acc1566d161c&#34;&gt;Running ChromeDriver with Python Selenium on Heroku - Michael Browne - Medium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://b0212066.pixnet.net/blog/post/213602412-heroku-%E4%BD%BF%E7%94%A8-selenium-%E7%9A%84-webdriver&#34;&gt;Heroku 上使用 webdriver 爬蟲抓資料 - Kevin的部落格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/41059144/running-chromedriver-with-python-selenium-on-heroku&#34;&gt;Running ChromeDriver with Python selenium on Heroku - Stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;結語&#34;&gt;結語&lt;/h2&gt;
&lt;p&gt;訂便當系列到這邊也告一段落了。事實上到了中後期，為了配合公司環境已經把爬蟲放在公司跑，並改成拿去接公司指定的通訊軟體，Line notify 這邊就比較少繼續碰了。中間遇到的一些問題也是有空加減解的程度，因此暫時沒有繼續更新訂便當的打算了。&lt;/p&gt;
&lt;p&gt;但 Heroku 實在是挺方便，之後應該還是會嘗試把其他東西丟上來跑看看，也因此還是覺得要把這些小問題記錄下來，之後如果遇到別的相關問題，也比較方便集中起來，因此就有了這兩篇的紀錄。&lt;/p&gt;
&lt;p&gt;那麼本週就到這裡，之後還會找新的坑來跳，畢竟菜雞就是不斷地踩坑嘛！感謝收看～&lt;/p&gt;
&lt;h2 id=&#34;我要訂便當系列&#34;&gt;我要訂便當系列&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/03/bandon-1-selenium/&#34;&gt;我要訂便當(1) —— 用 Python + Selenium 控制瀏覽器取得訂單&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/03/bandon-2-sqlite/&#34;&gt;我要訂便當(2) —— 用 Python + Sqlite 儲存訂單&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/04/bandon-3-line-notify/&#34;&gt;我要訂便當(3) —— 用 Python + Line Notify 傳送通知&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/05/bandon-4-heroku/&#34;&gt;我要訂便當(4) —— 將 Python 腳本部署上 Heroku&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/05/bandon-5-heroku-debug/&#34;&gt;我要訂便當(5) —— Heroku 填坑小記&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Json View —— 用 Chrome 打開 Json 的正確方式</title>
      <link>https://igouist.github.io/post/2020/05/jsonview/</link>
      <pubDate>Sun, 17 May 2020 15:39:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/05/jsonview/</guid>
      <description>&lt;p&gt;本來這週已經沒梗了，不過同學來問了個接 API 的問題還附了照片，頓時決定順手推一下好用的瀏覽器插件：&lt;a href=&#34;https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc&#34;&gt;Json View&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Json View 是一款 Chrome 的擴充套件，能幫忙把 Json 格式的資料重新排版，保護妳我的眼睛。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;備註：關於 JSON 可以參閱 &lt;a href=&#34;http://miniaspreading.github.io/guide-to-json/1-what-is-json.html&#34;&gt;JSON精要讀書紀錄&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;照慣例來張效果圖鎮樓
&lt;img src=&#34;https://i.imgur.com/VYg1Siy.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;該同學傳來的圖片是長這樣的（示意圖，非當事 API，用 UBike 開放資源臨演）
&lt;img src=&#34;https://i.imgur.com/kaoOwTt.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;突然還以為咱們要玩威利在哪裡，這不是欺負我眼睛不好嘛。&lt;/p&gt;
&lt;p&gt;但畢竟只是小問題，不能開口就要人家給 Swagger 或用個 Postman（API測試神器，之後也來推薦一篇），用圖片描述也是無可厚非，但還是必須顧眼睛。因此現場直接就推薦同學安裝這款 chrome 插件：&lt;a href=&#34;https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc&#34;&gt;Json View&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安裝之後再度使用瀏覽器打開 API，就會是長這樣的：
&lt;img src=&#34;https://i.imgur.com/TgKKIUK.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;經過自動排版之後，這不是好看多了！&lt;/p&gt;
&lt;p&gt;這邊真心推薦用 Chrome 的朋友，就先裝下來吧；至於火狐似乎原本就會幫忙整理排版了；用 IE 的話，就當我沒說。另外也要感謝親愛的同學，&lt;del&gt;又讓我水了一篇&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;ps: 最後效果跟鎮樓圖有差別？因為我是黑色主題的愛好者，所以這就再推一個擴充套件囉：&lt;a href=&#34;https://chrome.google.com/webstore/detail/dark-reader/eimadpbcbfnmbkopoojfekhnkhdbieeh&#34;&gt;Dark Reader&lt;/a&gt;。謝謝觀看，咱們下次見～&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Carbon —— 把程式碼片段截成有質感的圖片吧</title>
      <link>https://igouist.github.io/post/2020/05/carbon/</link>
      <pubDate>Sun, 10 May 2020 23:57:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/05/carbon/</guid>
      <description>&lt;p&gt;開始挑戰每週寫文之後，發現最大的敵人根本不是寫文這件事，而是自己的惰性啊。像這次母親節假期過太爽，差點兒就忘記發文…… 所以這週就還是 &lt;del&gt;偷懶&lt;/del&gt; 工具介紹囉。&lt;/p&gt;
&lt;p&gt;今天要分享的是 &lt;a href=&#34;https://carbon.now.sh/&#34;&gt;Carbon&lt;/a&gt; 這個工具，它能夠&lt;strong&gt;將貼上的程式碼輸出成圖片，並且支援程式碼上色&lt;/strong&gt;，還可以自選字型、背景色等等，產出的圖可以說相當有質感。&lt;/p&gt;
&lt;p&gt;當傳送圖片比較快或排版比較好的場合（例如Line, Facebook..），或是在部落格和文件中想直接放漂亮圖片，以及&lt;strong&gt;需要示範給對方看可是又不想要對方直接複製貼上&lt;/strong&gt;的時候可謂是相當實用。&lt;/p&gt;
&lt;p&gt;先來一張成果圖鎮樓
&lt;img src=&#34;https://i.imgur.com/jM07HAC.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Carbon 的操作相當直覺且簡單，進入 &lt;a href=&#34;https://carbon.now.sh/&#34;&gt;Carbon 的頁面&lt;/a&gt; 後，中央的程式碼區塊可以自由編輯，通常會直接將要做成圖片的程式碼貼於此處。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/RT4XIqZ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;而程式碼區塊的上方的兩個下拉選單分別是&lt;strong&gt;程式碼區塊的配色主題&lt;/strong&gt;和&lt;strong&gt;程式語言&lt;/strong&gt;，主要的樣式（例如程式碼上色）會以這兩個為主。&lt;/p&gt;
&lt;p&gt;接著的調色盤則是&lt;strong&gt;背景色&lt;/strong&gt;，即程式碼區塊外的顏色，也支援透明度。像我要將圖片放在部落格時，就可以讓背景色和部落格一致，使中央的程式碼區塊更強烈。&lt;/p&gt;
&lt;p&gt;最後的齒輪則是&lt;strong&gt;設定，字型和陰影等都可以從裡面做調整&lt;/strong&gt;。不過選項挺多的，建議可以自己都調看看，像我個人就固定會把上方的狀態列關閉。&lt;/p&gt;
&lt;p&gt;而右側就是&lt;strong&gt;匯出&lt;/strong&gt;的部分了，有發推特（真的有人會這樣發？我很懷疑）以及下載的選項，下載可以直接點選，或是下拉式輸入檔名和變更圖片大小格式等等。&lt;/p&gt;
&lt;p&gt;這邊就直接拿上一篇的 &lt;a href=&#34;https://igouist.github.io/post/2020/05/bandon-4-heroku/&#34;&gt;Line Notify 範例&lt;/a&gt; 的程式碼來試試吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/JvWVrjQ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;而製作出來的效果就會像這樣子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/jM07HAC.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;這工具對我個人來說挺喜歡的，有時候要傳程式碼給同學都會直接截圖，有了這個之後就可以傳得優雅一點（對我就是想叫你自己打）&lt;/p&gt;
&lt;p&gt;但還沒有用在部落格的打算，畢竟我身邊問過的人都表示：如果他們找到的網頁不給複製就會直接關掉。這… 我選擇妥協，真香。&lt;/p&gt;
&lt;p&gt;那麼今天的工具推薦就到這邊，歡迎立馬用你的同學 or 同事來試試看，保證能促進友誼、增加互動呦！&lt;/p&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://free.com.tw/carbon/&#34;&gt;Carbon 將程式碼轉為美麗圖片，在社群分享更引人注目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mnya.tw/cc/word/1088.html&#34;&gt;Carbon：將程式碼轉換成美觀的圖片&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;其他相似工具&#34;&gt;其他相似工具&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://free.com.tw/codeimg-io/&#34;&gt;Codeimg 程式碼轉圖片，可自訂視窗陰影效果更適合分享社群網站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://free.com.tw/codezen/&#34;&gt;CodeZen 將程式碼轉為 JPG、PNG 圖片，上色後加入視窗及陰影效果&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>我要訂便當 (4): 將 Python 腳本部署上 Heroku</title>
      <link>https://igouist.github.io/post/2020/05/bandon-4-heroku/</link>
      <pubDate>Sun, 03 May 2020 23:55:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/05/bandon-4-heroku/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;2024.10 更新: Line Notify 將於 2025 年 3 月停止服務（&lt;a href=&#34;https://notify-bot.line.me/closing-announce&#34;&gt;LINE Notify 結束服務公告&lt;/a&gt;），有看到這篇的朋朋請選擇一組新的通知服務來串吧 QQ&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;目標：紀錄一下如何將 Python 寫好的東西丟上 &lt;a href=&#34;https://www.heroku.com/home&#34;&gt;Heroku&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在先前的 &lt;a href=&#34;https://igouist.github.io/post/2020/03/bandon-1-selenium/&#34;&gt;訂便當系列&lt;/a&gt; 中已經建立了一個替我們去爬便當網並通知我們的小工具，但還存在一個相當大的問題：要在哪跑？總不能就只放在家裡電腦有開機就跑、沒開機就算了吧？因此我們必須找個主機把它放上去。而在上一篇做 Line Notify 的時候所參考的 &lt;a href=&#34;https://www.evanlin.com/go-line-notify/&#34;&gt;如何快速建置一個 LINE Notify 的服務&lt;/a&gt; 中提到了將服務放上 Heroku 的部分，因此馬上嘗試看看。&lt;/p&gt;
&lt;p&gt;結果過程中碰了不少壁，因此特地紀錄下來。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Heroku 是一個雲端平台&lt;/strong&gt;，讓使用者可以把服務丟上去跑，&lt;del&gt;同時最讚的部分是，免費用戶就提供了每月 450 小時可以使用（但有每半小時會進入休眠的限制）&lt;/del&gt;，詳情可以參閱 &lt;a href=&#34;https://www.heroku.com/pricing&#34;&gt;Heroku 的計費頁面&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;更新：Heroku 已經改為收費方案了 QQ&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本系列最後一階段的目標就是要將訂便當爬蟲整套丟上去雲端上運行，達到被動接收通知的效果。但由於訂便當爬蟲還牽涉到用 Selenium 開瀏覽器互動，以及使用 Sqlite 儲存的部分，轉移到 Heroku 的環境上還需要進行一些調整。因此&lt;strong&gt;這一階段將會分成兩篇（或以上）文章進行，上篇會先簡單地紀錄如何將服務放上 Heroku，下篇開始則著重於紀錄將訂便當系統放上 Heroku 時遇到的問題和解決過程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本篇主要的參考來源來自於 &lt;a href=&#34;https://medium.com/enjoy-life-enjoy-coding/heroku-%E6%90%AD%E9%85%8D-git-%E5%9C%A8-heroku-%E4%B8%8A%E9%83%A8%E7%BD%B2%E7%B6%B2%E7%AB%99%E7%9A%84%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E5%AD%B8-bf4fd6f998b8&#34;&gt;搭配 Git 在 Heroku 上部署網站的手把手教學&lt;/a&gt;、&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10196129&#34;&gt;發布網站到 Heroku&lt;/a&gt; 以及 &lt;a href=&#34;https://railsbook.tw/chapters/32-deployment-with-heroku.html&#34;&gt;網站部署（使用 Heroku）&lt;/a&gt; 這幾篇，其餘參考將附於文末，感謝各位前人大大留下的優質文。&lt;/p&gt;
&lt;h2 id=&#34;註冊及安裝&#34;&gt;註冊及安裝&lt;/h2&gt;
&lt;p&gt;Heroku 的 &lt;a href=&#34;https://signup.heroku.com/login&#34;&gt;註冊&lt;/a&gt; 相當簡單，這邊就略過不提，需要說明可以參考 &lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10196129&#34;&gt;這篇&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;註冊完畢就會回到個人頁面，底部有 Heroku Dev Center，也能選自己慣用的程式語言進去教學說明，有興趣的可以逛個一圈。
&lt;img src=&#34;https://i.imgur.com/2Q02pgx.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;這邊我們就先新增一個應用程式，點選畫面中間左側的 &lt;code&gt;Create a new app&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/BhCYXCY.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接著輸入應用程式名稱，注意只能使用小寫，並且不能重複。如果已經使用後續會提到的 CLI 的朋友，也可以直接使用 &lt;code&gt;heroku create&lt;/code&gt; 的指令來建立應用程式。&lt;/p&gt;
&lt;p&gt;建立完成之後就會進到專案的頁面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/OR5Sf14.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看見 Heroku 提供了幾種方法來將應用程式推送到 Heroku 上，例如連接到 Github。我們這邊用 Heroku CLI 試試，頁面上也已經提供了步驟說明。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://devcenter.heroku.com/articles/heroku-cli&#34;&gt;Heroku CLI 的安裝說明頁面&lt;/a&gt;，在這邊挑選自己的系統下載並安裝。&lt;/p&gt;
&lt;p&gt;安裝過程也相當簡易，會有將 Heroku 加到環境變數和路徑等選項，一路下一步即可。&lt;/p&gt;
&lt;p&gt;裝完之後，打開命令列輸入 Heroku，如果有跳出指令列表就代表安裝已經成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/nGlmGiJ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;連接至-heroku&#34;&gt;連接至 Heroku&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;備註：由於 Heroku 傳送檔案的方式是使用 Git 進行，因此在後續的操作之前，&lt;strong&gt;必須先確保電腦中已經安裝 Git&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接著我們就按照上面 Heroku CLI 說明頁面的步驟開始操作。&lt;/p&gt;
&lt;p&gt;首先要先登入，輸入 &lt;code&gt;heroku login&lt;/code&gt; 之後，便會開啟瀏覽器進行登入驗證，如果成功會看見登入訊息&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/fOifmbs.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接著就可以移到專案的資料夾，將專案和 Heroku 做連接&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 先移動到專案的資料夾
$ cd my-project/

# Git 初始化
$ git init

# 和 Heroku 專案連接
$ heroku git:remote -a Heroku的APP名稱
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/TumTYwP.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;環境設定及測試&#34;&gt;環境設定及測試&lt;/h2&gt;
&lt;p&gt;這邊由於前面提到訂便當系統有部分要調整的關係，因此只使用 &lt;a href=&#34;https://igouist.github.io/post/2020/04/bandon-3-line-notify/&#34;&gt;我要訂便當(3) 的 Lint Notify 測試版&lt;/a&gt; 的 Line Notify 上去試試看。上一集的簡單 Line Notify 程式碼如下，這邊命名為 &lt;code&gt;myApp.py&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; requests
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lineNotifyMessage&lt;/span&gt;(token, msg):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    headers &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Authorization&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Bearer &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; token,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Content-Type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;application/x-www-form-urlencoded&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    payload &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;message&amp;#39;&lt;/span&gt;: msg}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; requests&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;post(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;https://notify-api.line.me/api/notify&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        headers&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;headers,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        params&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;payload)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; r&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;status_code
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;message &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Line Notify + Heroku 測試&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;token &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;YOUR TOKEN&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lineNotifyMessage(token, message)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接著除了主要的 py 檔以外，還需要一些檔案去告訴 Heroku 怎麼處理我們的服務。&lt;/p&gt;
&lt;p&gt;事實上我第一次是直接就把 py 傳上去 Heroku 然後建置大失敗，還好 Google 了一陣有前人指點，這邊的設定部份參照自 &lt;a href=&#34;https://blog.techbridge.cc/2020/03/08/how-to-use-heroku-to-deploy-clear-mysql-db-web-app-tutorial/&#34;&gt;如何使用 Heroku 部屬一個 Web App 網頁應用程式&lt;/a&gt;，特此感謝。&lt;/p&gt;
&lt;p&gt;不過 Heroku 還不知道怎麼建我們的服務，因此這邊還需要新增幾個設定的檔案：&lt;/p&gt;
&lt;h3 id=&#34;procfile&#34;&gt;Procfile&lt;/h3&gt;
&lt;p&gt;用來告訴 Heroku 怎麼運行我們的服務&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;worker: python myApp.py
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這行的意思是：&lt;code&gt;worker&lt;/code&gt; 的運行方式是 &lt;code&gt;python myApp.py&lt;/code&gt; 這行命令，&lt;strong&gt;Heroku 會根據這個文件的內容去建 dynos 容器來運行我們的應用服務&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;像上面的參考文章在建置 Flask 時，就將運行 &lt;code&gt;web&lt;/code&gt; 的命令設定為 &lt;code&gt;gunicorn flask_app:app&lt;/code&gt; 讓 &lt;a href=&#34;https://www.jianshu.com/p/52d8e3deaa16&#34;&gt;Gunicorn&lt;/a&gt; 去起網站來跑。&lt;/p&gt;
&lt;p&gt;由於這次的示範組只是個小腳本，因此我們宣告個 worker 而不是網站方便之後處理。當宣告的運行是 &lt;code&gt;web&lt;/code&gt; 時，Heroku 還會幫忙接 HTTP 的內容，當然想包裝成 Web APP 的朋友，也可以參考上面的文章將腳本包裝成簡單的 Flask。&lt;/p&gt;
&lt;p&gt;關於 Procfile 和 dynos，可以參見 &lt;a href=&#34;https://andyyou.github.io/2016/10/31/process-types-and-profile/&#34;&gt;Heroku 運行類別、 Procfile、常用指令筆記&lt;/a&gt; 以及 Heroku 官方的 &lt;a href=&#34;https://devcenter.heroku.com/categories/dynos&#34;&gt;Dynos (app containers)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這邊另外要注意的地方有兩個：這個檔案是不需要副檔名的，而且大小寫請正確。我在碰壁的過程中有遇到本機測試可以但推送上去就不行的情況，後來發現是打成全小寫了，改成字首大寫就正常，因此這邊提醒一下大家。&lt;/p&gt;
&lt;h3 id=&#34;requirementstxt&#34;&gt;requirements.txt&lt;/h3&gt;
&lt;p&gt;用來標示需要安裝的套件，逐行列出套件即可，也可以用 &lt;code&gt;套件名稱==版本號&lt;/code&gt; 的方式指定套件版本。由於測試的程式碼只用到 requests，因此這邊列上 requests 就可以了。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;requests
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;runtimetxt&#34;&gt;runtime.txt&lt;/h3&gt;
&lt;p&gt;用來標示 Python 的版本，這篇文當下的版本為&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;python-3.7.6
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;本機測試&#34;&gt;本機測試&lt;/h3&gt;
&lt;p&gt;到目前為止沒意外的話應該會包含這些東西
&lt;img src=&#34;https://i.imgur.com/cinuyWc.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;這邊可以嘗試在本機測試看看，打開命令列輸入 &lt;code&gt;heroku local worker&lt;/code&gt; 就可以在 localhost Run 起來看看囉。注意這是在本機啟動 worker 這個 dynos 的意思，所以如果前面的 &lt;code&gt;Procfile&lt;/code&gt; 是使用 web 的朋友，這邊就要輸入 &lt;code&gt;heroku local web&lt;/code&gt; 囉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/7nfsEB0.png&#34; alt=&#34;&#34;&gt;
&lt;img src=&#34;https://i.imgur.com/UOfqN2J.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;想要全面啟動，可以直接輸入 &lt;code&gt;heroku local&lt;/code&gt;；想要指定 Port 的也可使用 &lt;code&gt;heroku local -p 7000&lt;/code&gt; 等等，可以參見 &lt;a href=&#34;https://andyyou.github.io/2016/10/31/process-types-and-profile/&#34;&gt;Heroku 運行類別、 Procfile、常用指令筆記&lt;/a&gt; 的啟動段落有比較常用的用法。&lt;/p&gt;
&lt;p&gt;如果一切安好，就可以開始嘗試部署囉&lt;/p&gt;
&lt;h2 id=&#34;部署至-heroku&#34;&gt;部署至 Heroku&lt;/h2&gt;
&lt;p&gt;Heroku 的部署只需要用 Git 推送上去就可以了，也就是只需要&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 把所有檔案都加到這次變更
$ git add .

# Commit 所有變動（記得標註解，養成好習慣）
$ git commit -am &amp;#34;這是Commit註解&amp;#34;

# 推送
$ git push heroku master
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就可以發到 Heroku 進行部署了，推送時也能看見建置的過程，如安裝的包和建置是否成功等資訊都會顯示&lt;/p&gt;
&lt;p&gt;如果前面架上去的是網站，也就是 &lt;code&gt;Procfile&lt;/code&gt; 使用 Web 的朋友，Heroku 應該會幫忙把服務建起來。&lt;strong&gt;而像我是另外定義 &lt;code&gt;worker&lt;/code&gt; 的朋友，這邊還需要多一個把 dynos 建起來的動作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;命令列中輸入 &lt;code&gt;heroku ps&lt;/code&gt; 就可以看到現在正在運行的服務，如果沒有任何服務運行，或是想擴展服務，可以使用 &lt;code&gt;heroku ps:scale Procfile裡定義的服務=服務數&lt;/code&gt; 來操作。&lt;/p&gt;
&lt;p&gt;例如我是使用 worker，這邊就輸入 &lt;code&gt;heroku ps:scale worker=1&lt;/code&gt; 就會開啟一個 worker 來運行；反過來說，輸入 &lt;code&gt;heroku ps:scale worker=0&lt;/code&gt; 就可以停止 worker 的服務囉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/04TWfuB.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果這邊部屬和運行有問題的朋友，可以查看 Heroku 的 Log：在命令列輸入 &lt;code&gt;Heroku log&lt;/code&gt; 就會顯示了（建議搭配 &lt;code&gt;--tail&lt;/code&gt; 等方法使用，詳請可見 &lt;a href=&#34;https://devcenter.heroku.com/articles/logging#view-logs&#34;&gt;官方文檔&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;此外，若是跟我初嘗試一樣跑出 &lt;code&gt;Couldn&#39;t find that process type&lt;/code&gt; 請參照 &lt;a href=&#34;https://help.heroku.com/W23OAFGK/why-am-i-seeing-couldn-t-find-that-process-type-when-trying-to-scale-dynos&#34;&gt;這篇&lt;/a&gt;，我個人是修改 &lt;code&gt;Procfile&lt;/code&gt; 檔名的大小寫就解決了&lt;/p&gt;
&lt;p&gt;若是建置時無法成功的朋友，可能是沒抓到你的服務的語言（例如 Python），需要自己去拉一下 buildpacks，例如 Python 的建置包就是 &lt;a href=&#34;https://elements.heroku.com/buildpacks/heroku/heroku-buildpack-python&#34;&gt;heroku-buildpack-python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最後我們回來看一下 Heroku 的 APP 頁面&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/9aJyKLQ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Activity&lt;/code&gt; 可以看見最近的活動，例如部署失敗也會顯示在這；而 &lt;code&gt;Settings&lt;/code&gt; 則是一些專案設定，例如名稱和建置包都要到這裡調整&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/p9ZAWei.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中可以從 &lt;code&gt;Domains&lt;/code&gt; 這裡連到你的服務，如果你放的是網頁或 API 的話就可以從這裡進入。不過更快進入自己服務的方法，是在命令列中直接下 &lt;code&gt;Heroku open&lt;/code&gt; 就行啦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/XhqJvxH.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;後記&#34;&gt;後記&lt;/h2&gt;
&lt;p&gt;其實原本打算部署的部分一篇解決的，沒想到牆就這樣撞了上來，將便當放到 Heroku 上時實在遇到挺多問題，例如第一次使用時直接把整坨檔案直接推上去也沒設定結果建置失敗，或是發現 Heroku 不給用 Sqlite，或是 Selenium 要另外找建置包等等，因此最後決定切成兩篇，一篇好好記 Heroku 的流程，剩下的部份再按照問題做紀錄。&lt;/p&gt;
&lt;p&gt;同時因為原本的訂便當已經在家裡電腦跑著了，部屬上雲似乎是額外再戰的部份。待到剩下問題解決了，抓緊下班時間再寫上來記著，希望以後能派上用場吧。&lt;/p&gt;
&lt;h2 id=&#34;我要訂便當系列&#34;&gt;我要訂便當系列&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/03/bandon-1-selenium/&#34;&gt;我要訂便當(1) —— 用 Python + Selenium 控制瀏覽器取得訂單&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/03/bandon-2-sqlite/&#34;&gt;我要訂便當(2) —— 用 Python + Sqlite 儲存訂單&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/04/bandon-3-line-notify/&#34;&gt;我要訂便當(3) —— 用 Python + Line Notify 傳送通知&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/05/bandon-4-heroku/&#34;&gt;我要訂便當(4) —— 將 Python 腳本部署上 Heroku&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/05/bandon-5-heroku-debug/&#34;&gt;我要訂便當(5) —— Heroku 填坑小記&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/enjoy-life-enjoy-coding/heroku-%E6%90%AD%E9%85%8D-git-%E5%9C%A8-heroku-%E4%B8%8A%E9%83%A8%E7%BD%B2%E7%B6%B2%E7%AB%99%E7%9A%84%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E5%AD%B8-bf4fd6f998b8&#34;&gt;搭配 Git 在 Heroku 上部署網站的手把手教學 - 神Q超人&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10196129&#34;&gt;第十八天：發布網站到 Heroku - 只要有心，人人都可以做卡米狗&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://railsbook.tw/chapters/32-deployment-with-heroku.html&#34;&gt;網站部署（使用 Heroku） - 為你自己學 Ruby on Rails&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.techbridge.cc/2020/03/08/how-to-use-heroku-to-deploy-clear-mysql-db-web-app-tutorial/&#34;&gt;如何使用 Heroku 部屬一個 Web App 網頁應用程式 - TechBridge 技術共筆部落格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.evanlin.com/go-line-notify/&#34;&gt;[Golang][LINE][教學] 如何快速建置一個 LINE Notify 的服務 - KKDAI.GITHUB.IO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ivanjo39191.pixnet.net/blog/post/179102363-python-django-%E5%AD%B8%E7%BF%92%E7%B4%80%E9%8C%84%28%E4%B9%9D%29-%E9%83%A8%E5%B1%AC%E7%B6%B2%E7%AB%99%E5%88%B0-heroku&#34;&gt;Python Django 學習紀錄(九) 部屬網站到 Heroku - IvanKao的部落格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://djangogirlstaipei.herokuapp.com/tutorials/deploy-to-heroku/?os=windows&#34;&gt;用 Heroku 部署網站 - Django Girls Taipei&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://andyyou.github.io/2016/10/31/process-types-and-profile/&#34;&gt;Heroku 運行類別、 Procfile、常用指令筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.longwin.com.tw/2019/03/python-pip-requirements-txt-management-package-2019/&#34;&gt;Python PIP 使用 requirements.txt 管理套件相依性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://elements.heroku.com/buildpacks/heroku/heroku-buildpack-python&#34;&gt;Heroku-buildpack-python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://devcenter.heroku.com/categories/heroku-architecture&#34;&gt;Heroku Dev Center&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://devcenter.heroku.com/articles/getting-started-with-python&#34;&gt;Heroku Dev Center: Getting Started on Heroku with Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/michaelkrukov/heroku-python-script&#34;&gt;Template for hosting python scripts and applications on Heroku - Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>CSS: 變數 (Variables)</title>
      <link>https://igouist.github.io/post/2020/04/css-variables/</link>
      <pubDate>Sun, 26 Apr 2020 23:09:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/04/css-variables/</guid>
      <description>&lt;p&gt;這禮拜忙了些，只好先偷懶打張安牌。這邊就記一下前陣子同學弄主題切換時用到的 CSS 變數（Variables）功能用法&lt;/p&gt;
&lt;p&gt;原本使用 CSS 時就會有許多重複使用的部分，例如說網站的主色彩和副色彩等，然而在管理上，或是要修改的時候就會很麻煩，通常都要另外借助工具來處理。然而 CSS 其實原生就有變數可以使用，大大地增加了改動時的方便性。用法上也相當簡單。&lt;/p&gt;
&lt;p&gt;在 CSS 宣告變數時，建議放在 &lt;code&gt;:root&lt;/code&gt; 裡，並使用 &lt;code&gt;--變數名&lt;/code&gt; 的方式宣告。例如&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-css&#34; data-lang=&#34;css&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;:&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    --color: &lt;span style=&#34;color:#ae81ff&#34;&gt;#000000&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而使用的時候只要 &lt;code&gt;var(--變數名)&lt;/code&gt; 就可以囉。例如&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-css&#34; data-lang=&#34;css&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;background&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;var&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;color&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;平時使用也常搭配 CSS 的 clac 及 JS 的 document.documentElement.style.setProperty 來處理，這部分就直接看範例吧。
以下附上調色盤 Codepen 作為範例，用法主要參考 &lt;a href=&#34;https://pjchender.dev/js30/js30-day03/&#34;&gt;CSS Variables&lt;/a&gt; 這篇。&lt;/p&gt;
&lt;p class=&#34;codepen&#34; data-height=&#34;265&#34; data-theme-id=&#34;dark&#34; data-default-tab=&#34;css,result&#34; data-user=&#34;igouist&#34; data-slug-hash=&#34;NWPBMwP&#34; style=&#34;height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;&#34; data-pen-title=&#34;CSS 變數測試：調色盤&#34;&gt;
  &lt;span&gt;See the Pen &lt;a href=&#34;https://codepen.io/igouist/pen/NWPBMwP&#34;&gt;
  CSS 變數測試：調色盤&lt;/a&gt; by IGOU (&lt;a href=&#34;https://codepen.io/igouist&#34;&gt;@igouist&lt;/a&gt;)
  on &lt;a href=&#34;https://codepen.io&#34;&gt;CodePen&lt;/a&gt;.&lt;/span&gt;
&lt;/p&gt;
&lt;script async src=&#34;https://static.codepen.io/assets/embed/ei.js&#34;&gt;&lt;/script&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pjchender.dev/js30/js30-day03/&#34;&gt;CSS Variables - PJCHENder私房菜&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://muki.tw/tech/native-css-variables/&#34;&gt;SASS, LESS 退散，原生 CSS 可以使用變數啦！ - MUKI space*&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mnya.tw/cc/word/1340.html&#34;&gt;CSS 原生變數（Variables）介紹與使用教學 - 萌芽綜合天地&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://w3c.hexschool.com/blog/21985acb&#34;&gt;原生 CSS 變數運用技巧（CSS Variables）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Feedly —— 用 RSS 訂閱來主動篩選資訊吧</title>
      <link>https://igouist.github.io/post/2020/04/feedly/</link>
      <pubDate>Sun, 19 Apr 2020 23:56:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/04/feedly/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;「你看，我認為人的腦子本來就像一間空空的小閣樓，應該有選擇地把傢俱放進去，傻瓜才會把他見到的所有破爛一古腦兒的裝進去。這樣一來，那些對他有用的知識反而被擠了出來；或者，最多不過是和許多其他的東西摻雜在一起，在取用的時候也會很困難。所以一個會工作的人，在要把一些東西裝進他那間小閣樓似的頭腦中的時候，確實是非常小心謹慎的。」&lt;/p&gt;
&lt;p&gt;　　——《福爾摩斯探案記：血字的研究》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在咱們寫程式這行中，幾乎所有人都必須要在網路上找尋資料；而就算非這一行的朋友們，也會在網路上多方攝取資源。隨著時間的累積，都會開始有一份列表，諸如一些崇拜的大神或是固定追蹤的部落格，又或是文風比較喜歡、素質感覺比較高的新聞或評論等等。&lt;/p&gt;
&lt;p&gt;然而列表越來越長，就算加到書籤也總不能沒事就逛一大圈，也常常逛到不知道到底在幹嘛囧。因此把多個資訊來源集中起來整理就成了面對資訊爆炸的關鍵一步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://feedly.com/&#34;&gt;Feedly&lt;/a&gt; 就是一個協助資訊來源管理的工具，可以很方便地把不同訂閱來源整理在一起&lt;/strong&gt;，例如你可能追隨了五六個大神的部落格，只要這些大神都有提供 RSS 訂閱，Feedly 就會將大神更新的文章收集到平台上。&lt;/p&gt;
&lt;p&gt;每天只需要上去 Feedly 看一下有沒有哪位大神更新，就可以化主動為被動，穩定接收新資訊。並且由於集中管理的關係，也可以檢視是否有哪個資料來源，如新聞網站，實際上更新的文章並不太合你胃口，或是哪些已經停止更新了，就可以進行剪枝的動作，建立自己的篩選機制。&lt;/p&gt;
&lt;p&gt;Feedly 使用的是 RSS，是一種自古以來就存在(?)的訂閱方式。主要是&lt;strong&gt;將網站裡文章的標題和簡介等資訊整理成 XML 的文字格式&lt;/strong&gt;（例如本站的&lt;a href=&#34;https://igouist.github.io/index.xml&#34;&gt;RSS頁面&lt;/a&gt;）&lt;strong&gt;，使訂閱服務只需要去各個網站抓取輕便的文字檔就能夠得知網站是否更新、現在有哪些文章等資訊&lt;/strong&gt;。因此本身可以說是相當輕量簡單的服務。&lt;/p&gt;
&lt;p&gt;而我們就可以用 Feedly 定期去取得我們列好的 RSS 資訊，省下我們在網站間奔波的時間。類似的服務還有 Inoreader 等等，本質上並沒有太大的差別，可以挑喜歡的試用看看。&lt;/p&gt;
&lt;h2 id=&#34;開始使用如何訂閱&#34;&gt;開始使用＋如何訂閱&lt;/h2&gt;
&lt;p&gt;到 &lt;a href=&#34;https://feedly.com/&#34;&gt;Feedly&lt;/a&gt; 的首頁進行註冊之後，會先導到添加資訊來源的頁面如下（我的頁面是黑色的，是因為左側選單有黑暗模式可以開，點一下月亮就可以囉）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/XbpJvdz.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;搜尋框裡面可以輸入 文字、網址和 RSS 網址 來進行搜尋，以本網站為例，貼上網址之後，Feedly 就會去找是否提供 RSS，有的話就會像這樣搜尋到，便可以按下 Follow；可以從圖片中看見現在只有我一個人追蹤我自己（泣）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/S71J7dM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;按下追隨之後，可以按 + New Feed，&lt;strong&gt;這個 Feed 可以把它看作是一種分類&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/WUrdijS.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;由於本站大多分享程式相關的部分，因此我們這邊建立程式設計的分類&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/qxPHVg0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;加完之後，就可以在左側看見剛剛建好的分類已經來源囉，分類及來源旁邊的數字則是這個分類下的新文章的篇數&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/DIftHjN.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;為了之後說明方便，再多加幾個來源。下面是我一個挺喜歡的部落格&lt;a href=&#34;https://www.playpcesor.com/&#34;&gt;電腦玩物&lt;/a&gt;，分享挺多時間管理和生活流程等等的工具和技巧。像這種大神級只需要輸入名字搜尋就可以追蹤囉&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/29VwdC6.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在這一步就可以把平常會看的技術部落格、週刊之類的都加進來，並且予以分類。&lt;/p&gt;
&lt;p&gt;往後&lt;strong&gt;如果需要訂閱新的來源，在左側選單的 &lt;code&gt;＋&lt;/code&gt; 就可以再回到增加來源的頁面囉！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;基本操作&#34;&gt;基本操作&lt;/h2&gt;
&lt;p&gt;訂閱了一些來源之後，就可以嘗試使用。我個人每天會來到 Feedly 從 Today 的部分挑選幾篇標題讓人感興趣的文章來看。可以從左上角點選 Today 就可以回到訂閱文的頁面。&lt;/p&gt;
&lt;p&gt;右上角可以選擇文章排列的模式，例如很像信箱的顯示標題，和我較喜歡的標題內文，另外也還有像卡片格狀排列的模式可以選，建議先選個喜歡的版面會提高每天閱讀的意願。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/GBsnQU3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;因此&lt;strong&gt;最主要的活動範圍就會在這個 Today 進行&lt;/strong&gt;，邊滑動邊選擇不同來源的文章來閱讀，也可以從左側選擇某個分類、甚至某個來源的文章來看。若是網站可以擷取的，&lt;strong&gt;點選文章之後就會從右側彈出文章的簡介，全文仍然要回到來源網頁閱讀&lt;/strong&gt;，為了排版舒適以及支持寫手的流量來看這是相當好的做法。故打開文章之後往下拉，可以看見 &lt;strong&gt;VISIT WEBSITE&lt;/strong&gt; 按下去就會到目標文章囉&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ER63IbJ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;此外也可以看見上面一排工具列，&lt;strong&gt;若是有購買付費服務，就可以和其他像是 Evernote 的工具連動，把文章傳送過去&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而上方工具列最左側的&lt;strong&gt;書籤圖案則是稍後閱讀 Read Later&lt;/strong&gt;，在這邊選取之後或是在 Today 文章列表有選取的話，&lt;strong&gt;就會記錄到左側選單的 Read Later&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/7GVCm8l.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接下來最重要的就是已讀功能，除了閱讀完單篇文章標示為已讀，以及在列表對某邊文章打勾以外，當 Today 或某個分類捲動到底時，會有一個 全部標示為已讀 的按鈕可以使用。或是上圖的右側也可以看到一個標著數字的打勾，也是全部已讀的意思。已讀之後就會收到過往已讀的清單中。靠著分類和已讀就可以將每天的資訊整個流動過去。&lt;/p&gt;
&lt;p&gt;此外，如果跟我一樣&lt;strong&gt;一開始就加上一堆來源的，文章的數量就會爆炸多，左邊的數字也會超級大&lt;/strong&gt;。但這並不用擔心，在資訊爆炸的年代，資訊本身就是看不完的，有些人會因此感到焦慮，但其實篩選比起暴飲暴食更為重要，因此我個人是建議&lt;strong&gt;排定文章分類的優先順序，並且懂得取捨&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我個人現在是分成 程式設計、知識、科技新聞、一般新聞 等類別，這也代表我個人對這些資訊的優先順序；時間少的時候就從優先順序高的開始看，例如技術大神的新文章，並直接捨棄新聞等較不重要的部分；時間充裕的時候才考慮大致瀏覽過一次去挑想看的來看。&lt;strong&gt;知識類的東西，看了也許有賺，但如果沒有時間看了，不看也不虧，因此並不要太過執著，必要的時候直接全部已讀也是合適的做法&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;來源管理&#34;&gt;來源管理&lt;/h2&gt;
&lt;p&gt;如果只是訂閱各網站集中起來，那麼和月刊和報紙等也沒什麼太大的差異。Feedly 最吸引我的一點就是對來源管理的方便度。在每個分類右上角的選單會有個管理來源&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/lXgrTi2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;或是左下角的頭像中也可以進入&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/HKnJ8pH.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;進入之後就會到資源管理的頁面&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/tB4w9J9.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;上面會告訴你訂閱了幾個來源，有哪些來源已經有一段時間沒更新（有睡了跟死了兩個程度），&lt;strong&gt;每個來源也可以確認每個月的貼文數量，以及實際上每個月有點進去閱讀的數量&lt;/strong&gt;。藉此就可以掌握那些媒體可能過於嘈雜，或是哪些來源的文章其實並沒有興趣等等，可以按照自己的需求去管理資訊的來源。經過不斷的篩選和添加，就能夠讓整個頁面成為你的形狀。&lt;/p&gt;
&lt;h2 id=&#34;心得&#34;&gt;心得&lt;/h2&gt;
&lt;p&gt;這幾天和女友及同事聊到都逛哪些部落格之類的話題時，發現大多都還是有空的時候主動去巡查一遍，最多就到信箱訂閱或是 FB 按讚然後佛系看到這樣，讓我覺得應該推廣一下 Feedly 這股神器。雖然這篇和技術沒什麼直接關係，幸好六角的鼠年全馬有八篇心得文的扣打，就直接選擇用在這裡。&lt;/p&gt;
&lt;p&gt;有看過前幾篇文章的應該能夠了解，對我而言&lt;strong&gt;比起主動去做這些事情，不如建立一個自動化的機制被動去接收訊息，省去過程這段不必要的時間&lt;/strong&gt;；例如比起常常上去便當網或 PTT 找我要的東西出現了沒，我更喜歡讓電腦替我代勞並在出現之後提醒我的做法。因此想看的文章想追的網站多了，Feedly 對我來說就是一件神兵利器，節省了許多功夫。&lt;/p&gt;
&lt;p&gt;我曾聽過一句話：資訊不等於知識。我相信資訊的來源是需要主動去選擇的，這也就是開頭引用福爾摩斯的這句名言的原因。若是&lt;strong&gt;不管什麼東西都直接吃下肚，甚至不管多少都堅持吃完，那只會得到無邊的痛苦&lt;/strong&gt;。經過有系統的整理和篩選，最終才能建立方便又有效的流程。&lt;/p&gt;
&lt;p&gt;然而各大社群平台的演算法實在太謎，大多部落格也不會有月刊或信箱發送，因此還是要主動出擊去做篩選，不斷檢視過程和品質，留下自己想看並且素質值得期待的資訊來源，才能建立高品質的資訊閱讀，看得健康又有用。就像電腦玩物在 Feedly 的介紹文中說的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;「只有在自己為自己訂閱、整理資訊管道的過程中，你才能逐漸建立起自己的知識世界觀，開始思考自己需要什麼資訊，而這時候的資訊閱讀才是有效的。」&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;共勉之。&lt;/p&gt;
&lt;h2 id=&#34;延伸閱讀參考資料&#34;&gt;延伸閱讀、參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.playpcesor.com/2018/04/rss-facebook.html&#34;&gt;RSS 不是臉書演算法解藥，我們真正需要的是垂直閱讀與實踐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bnext.com.tw/article/48743/can-rss-revival&#34;&gt;被演算法「毀掉」的閱讀習慣，用RSS救得回來嗎？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.playpcesor.com/2017/08/feedly.html&#34;&gt;Feedly 新功能找回高品質資訊閱讀，自動過濾無效與噪音網站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.playpcesor.com/2013/03/feedly-google-reader.html&#34;&gt;Feedly 完全上手教學，延續 Google Reader 閱讀器體驗 - 電腦玩物&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://iamfugue.net/news-aggregator/&#34;&gt;【工具】RSS 訂閱初體驗 - 微 GEEK 百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.thelaziest.net/2019/12/rss-feedly.html&#34;&gt;免費 RSS 閱讀器 Feedly ，選擇真正需要的資訊，不再被演算法餵食垃圾內容&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>EPPlus —— 輕鬆處理 Excel</title>
      <link>https://igouist.github.io/post/2020/04/epplus/</link>
      <pubDate>Sun, 12 Apr 2020 10:19:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/04/epplus/</guid>
      <description>&lt;p&gt;前陣子工作需要匯出一些資料表，因此用到了 &lt;a href=&#34;https://github.com/EPPlusSoftware/EPPlus&#34;&gt;EPPlus&lt;/a&gt; 這套工具來把資料匯出成 Excel。由於這需求似乎會挺常遇到的，決定記一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目標：稍微紀錄一下這次碰到 EPPlus 的用法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;EPPlus 是在 .NET Framework 或 .NET Core 上提供控制 Excel 的元件，操作簡單好懂&lt;/strong&gt;，當有需要在網頁上讓人將表格資料下載成 Excel 的功能時就可以試著使用。常常一併被提起的還有另一個一樣老牌的相似功能元件 NPOI，不過我個人只用過 EPPlus 便不再贅述。關於更詳細的介紹，可以參閱黑暗執行緒的這篇 &lt;a href=&#34;https://blog.darkthread.net/blog/epplus/&#34;&gt;比 NPOI 更討喜的 Excel 元件 - EPPlus!&lt;/a&gt;，儘管是有些久遠的文章但仍能迅速了解 EEplus 的賣點和差異。&lt;/p&gt;
&lt;p&gt;我在使用 EPPlus 時主要的參考來自於 &lt;a href=&#34;https://github.com/EPPlusSoftware/EPPlus/wiki&#34;&gt;EPPlus 的 Wiki&lt;/a&gt;，每個功能都有說明及範例，同時也有範例專案可以下載，寫得相當詳細。另外還找了如 &lt;a href=&#34;https://www.cnblogs.com/rumeng/p/3785748.html&#34;&gt;導出 Excel 之 Epplus 使用教程 - Wico&amp;rsquo;s Blog&lt;/a&gt;、&lt;a href=&#34;https://dotblogs.com.tw/malonestudyrecord/2018/03/21/103124&#34;&gt;使用 EPPLUS 操控 Excel - 碼農的學習日誌&lt;/a&gt; 這些有逐步說明的文章，在此感謝。&lt;/p&gt;
&lt;h2 id=&#34;建立-excel&#34;&gt;建立 Excel&lt;/h2&gt;
&lt;p&gt;首先從建立一個 Excel 開始；要注意的是開啟檔案之後也要記得建分頁出來。後續的寫入資料等都是對分頁去做動作。&lt;/p&gt;
&lt;p&gt;我們使用 &lt;code&gt;new ExcelPackage()&lt;/code&gt; 來開一個新的 Excel 的處理工作，而結束之後一定要記得 &lt;code&gt;SaveAs&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;備註 (2020/4/12):&lt;/p&gt;
&lt;p&gt;由於 EPPlus 升版和授權上的一些改變，如果直接使用會跳出 &lt;code&gt;LicenseException&lt;/code&gt; 用來通知你這件事。&lt;/p&gt;
&lt;p&gt;因此現在需要先加上這行：&lt;br/&gt;
&lt;code&gt;ExcelPackage.LicenseContext = LicenseContext.NonCommercial;&lt;/code&gt; &lt;br/&gt;
來叫它閉嘴。&lt;/p&gt;
&lt;p&gt;另外也有在 &lt;code&gt;App.config&lt;/code&gt; 中設定的作法，可參閱 &lt;a href=&#34;https://epplussoftware.com/developers/licenseexception&#34;&gt;LicenseException - EPPlus&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;備註 (2022/3/13):&lt;/p&gt;
&lt;p&gt;因緣際會發現 EPPlus 的授權說明網頁現在已經有翻譯了，有遇到這個 LicenseException 的朋友可以去看一下：&lt;a href=&#34;https://epplussoftware.com/zh/Developers/LicenseException&#34;&gt;LicenseException - EPPlus Software&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外關於一些授權的部分，也可以參照小朱大大的這篇：&lt;a href=&#34;https://dotblogs.com.tw/regionbbs/2018/09/23/light-discussions-oss-licenses&#34;&gt;淺談軟體開源的授權條款&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ExcelPackage.LicenseContext = LicenseContext.NonCommercial; &lt;span style=&#34;color:#75715e&#34;&gt;// 關閉新許可模式通知&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 沒設置的話會跳出 Please set the excelpackage.licensecontext property&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; file = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; FileInfo(&lt;span style=&#34;color:#e6db74&#34;&gt;@&amp;#34;D:\ExampleExcel.xlsx&amp;#34;&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 檔案路徑&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; excel = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ExcelPackage())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 建立分頁&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; ws = excel.Workbook.Worksheets.Add(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;MySheet&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 寫入資料試試&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ws.Cells[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;].Value = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;測試測試&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 儲存 Excel&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    excel.SaveAs(file);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;執行之後就可以看到檔案已經被建立囉
&lt;img src=&#34;https://i.imgur.com/gHEE7OZ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;並且也出現了測試用的內容
&lt;img src=&#34;https://i.imgur.com/LObC4zj.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;從這邊也可以認出 &lt;code&gt;ws.Cells[2, 1].Value&lt;/code&gt; 的第一個數字是&lt;code&gt;從 ↓ 數下來&lt;/code&gt;的，第二個是&lt;code&gt;往 → 數過去&lt;/code&gt;的（很抱歉這樣表示，因為我常弄反行跟列，這樣之後參考比較好理解）&lt;/p&gt;
&lt;p&gt;另外眼尖的朋友也可以察覺到一個重點，&lt;strong&gt;儲存格是從 1 開始數的：不是 0 ！&lt;/strong&gt; 也就是說 &lt;code&gt;A1&lt;/code&gt; 這一格是 &lt;code&gt;[1, 1]&lt;/code&gt;，不要打成 &lt;code&gt;[0, 0]&lt;/code&gt; 了。當然，對於困擾的朋友，EEPlus 也提供了 &lt;code&gt;ws.Cells[&amp;quot;B1&amp;quot;]&lt;/code&gt; 的寫法，可以用字串傳入的方式直接指定在 Excel 的儲存格位置，比起數格子方便多了，後續也會在示範標註。&lt;/p&gt;
&lt;h2 id=&#34;編輯-excel&#34;&gt;編輯 Excel&lt;/h2&gt;
&lt;p&gt;編輯時和建立一樣，從 &lt;code&gt;ExcelPackage()&lt;/code&gt; 開始動作，這次我們將檔案直接傳入，如此 Save 的時候就可以不用再傳一次。關於各種操作直接在程式碼上的註解進行說明。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 特別注意，頁籤和儲存格等操作 是由 1 開始而非 0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 打開存在的 Excel 檔案&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; excelFile = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; FileInfo(&lt;span style=&#34;color:#e6db74&#34;&gt;@&amp;#34;D:\ExampleExcel.xlsx&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; excel = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ExcelPackage(excelFile))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 指定頁籤&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//ExcelWorksheet sheet1 = excel.Workbook.Worksheets[1]; // 這邊用是 1 在 Core 用是 0 = =&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ExcelWorksheet sheet1 = excel.Workbook.Worksheets[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;MySheet&amp;#34;&lt;/span&gt;]; &lt;span style=&#34;color:#75715e&#34;&gt;// 可以使用頁籤名稱&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;#region -- 儲存格讀寫 --&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 寫入資料，[行－，列｜] 或直接指定 [&amp;#34;儲存格&amp;#34;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sheet1.Cells[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;].Value = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;開啟測試&amp;#34;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 嚴謹一點可以用 GetValue 和 SetValue 來操作&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//sheet1.Cells[&amp;#34;B1&amp;#34;].Value = &amp;#34;開啟測試&amp;#34;; // 此兩行等價&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sheet1.Cells[&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;].Value = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;多格操作測試&amp;#34;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 從 (3, 3) 一路框到 (5, 5)，包含頭尾&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//sheet1.Cells[&amp;#34;C3:E5&amp;#34;].Value = &amp;#34;多格操作測試&amp;#34;; // 此兩行等價&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sheet1.Cells[&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;].LoadFromText(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;LoadFromText Test&amp;#34;&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 從字串讀入資料，可用於寫入 CSV 之類的場合&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; coll = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; List&amp;lt;&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;&amp;gt; { &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;LoadFromCollTest1&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;LoadFromCollTest2&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;LoadFromCollTest3&amp;#34;&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sheet1.Cells[&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;].LoadFromCollection(coll); &lt;span style=&#34;color:#75715e&#34;&gt;// 從集合類型的參數讀入資料，會按照行（＝ D1 E1 F1...）依序排列&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 可從 LoadFromCollection 推測 LoadFromDataReader, LoadFromDataTable, LoadFromArrays 等函式的行為，故省略&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;#endregion -- 儲存格讀寫 --&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;#region -- 儲存格樣式 --&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 可以用宣告的方式一併操作指定區域內的儲存格&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; range = sheet1.Cells[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;])  &lt;span style=&#34;color:#75715e&#34;&gt;// 直接選取 A1 到 A5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        range.Value = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;樣式測試&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        range.Style.Font.Bold = &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 粗體&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        range.Style.Font.Color.SetColor(Color.White); &lt;span style=&#34;color:#75715e&#34;&gt;// 字體顏色&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        range.Style.Fill.PatternType = ExcelFillStyle.Solid; &lt;span style=&#34;color:#75715e&#34;&gt;// 設定背景填色方法，沒有這一行就上背景色會報錯&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                                             &lt;span style=&#34;color:#75715e&#34;&gt;// Solid = 填滿；另外還有斜線、交叉線、條紋等&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        range.Style.Fill.BackgroundColor.SetColor(Color.DarkBlue); &lt;span style=&#34;color:#75715e&#34;&gt;// 儲存格顏色&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;#endregion -- 儲存格樣式 --&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    excel.Save(); &lt;span style=&#34;color:#75715e&#34;&gt;// 儲存變更&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;執行完的結果會像這樣，可以和上面的程式碼對照看是哪一部份的效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/dENLdol.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;以上部份嘗試了 資料的讀寫（如寫入單格的資料內容、寫入一個串列等）以及樣式的設定（字體顏色、儲存格顏色等）等。由於其中的操作能&lt;strong&gt;選擇的樣式相當繁多&lt;/strong&gt;，例如背景填色就有好幾種，因此列出來並不是明智的做法，先知道基本的語法之後再自己開編譯器看有哪些選項、或是將對應的操作拿到官方文檔找看有哪些會是比較實際的做法。&lt;/p&gt;
&lt;p&gt;這篇只示範資料的寫入，當然 Excel 的處理沒有那麼簡單，可以參照 官方Wiki 的這兩個部份：&lt;a href=&#34;https://github.com/EPPlusSoftware/EPPlus/wiki/Formula-Calculation&#34;&gt;公式的計算&lt;/a&gt; 及 &lt;a href=&#34;https://github.com/EPPlusSoftware/EPPlus/wiki/Shapes,-Pictures,-Controls-and-Charts&#34;&gt;圖表的處理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Epplus 的官方文檔範例寫得挺不錯的，有更進一步需求的朋友可以翻一下範例，抓下來跑跑看，可以解決大部分的問題。&lt;/p&gt;
&lt;h2 id=&#34;泛型串列匯出-excel&#34;&gt;泛型串列匯出 Excel&lt;/h2&gt;
&lt;p&gt;這邊紀錄一下工作需求時用到的做法，由於匯出資料的型別繁多，唯一的共通點就是都很多筆。為了方便寫了一個針對多筆的泛型匯出函式，特別在這裡記錄下來。
其實這篇也是為了把這個部份記錄下來方便以後可以回來抄才開的坑…&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; data = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; List&amp;lt;testClass&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; testClass{ name = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;香蕉&amp;#34;&lt;/span&gt; },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; testClass{ name = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;番茄&amp;#34;&lt;/span&gt; },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; testClass{ name = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;蘋果&amp;#34;&lt;/span&gt; },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; testClass{ name = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;鳳梨&amp;#34;&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; excel = ExportExcel(data);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	excel.Dump();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; FileInfo ExportExcel&amp;lt;T&amp;gt;(IEnumerable&amp;lt;T&amp;gt; data) &lt;span style=&#34;color:#66d9ef&#34;&gt;where&lt;/span&gt; T: &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;//var output = new MemoryStream();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; output = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; FileInfo(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;D:\\ExportExcelTest-&amp;#34;&lt;/span&gt; + DateTime.Now.ToString(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;yyyy-MM-dd-hh-mm-ss&amp;#34;&lt;/span&gt;) + &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;.xlsx&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; excel = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ExcelPackage(output))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; ws = excel.Workbook.Worksheets.Add(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Sheet1&amp;#34;&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 建立分頁&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// 用反射拿出有 DisplayName 的屬性&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; properties = &lt;span style=&#34;color:#66d9ef&#34;&gt;typeof&lt;/span&gt;(T)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            .GetProperties()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            .Where(prop =&amp;gt; prop.IsDefined(&lt;span style=&#34;color:#66d9ef&#34;&gt;typeof&lt;/span&gt;(DisplayNameAttribute)));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; rows = data.Count() + &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;   &lt;span style=&#34;color:#75715e&#34;&gt;// 直：資料筆數（記得加標題列）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; cols = properties.Count(); &lt;span style=&#34;color:#75715e&#34;&gt;// 橫：類別中有別名的屬性數量&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(rows &amp;gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; cols &amp;gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			ws.Cells[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;].LoadFromCollection(data, &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 寫入資料&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#75715e&#34;&gt;// 儲存格格式&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; colNumber = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;foreach&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; prop &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; properties)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#75715e&#34;&gt;// 時間處理，如果沒指定儲存格格式會變成 通用格式，就會以 int＝時間戳 的方式顯示&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (prop.PropertyType.Equals(&lt;span style=&#34;color:#66d9ef&#34;&gt;typeof&lt;/span&gt;(DateTime)) ||
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				   prop.PropertyType.Equals(&lt;span style=&#34;color:#66d9ef&#34;&gt;typeof&lt;/span&gt;(DateTime?)))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;					ws.Cells[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, colNumber, rows, colNumber].Style.Numberformat.Format = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;mm-dd-yy hh:mm:ss&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				colNumber += &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#75715e&#34;&gt;// 樣式準備&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; range = ws.Cells[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, rows, cols])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				ws.Cells.Style.Font.Name = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;新細明體&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				ws.Cells.Style.Font.Size = &lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				ws.Cells.Style.HorizontalAlignment = ExcelHorizontalAlignment.Center; &lt;span style=&#34;color:#75715e&#34;&gt;// 置中&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				ws.Cells.AutoFitColumns(); &lt;span style=&#34;color:#75715e&#34;&gt;// 欄寬&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#75715e&#34;&gt;// 框線&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				range.Style.Border.Top.Style = ExcelBorderStyle.Thin;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				range.Style.Border.Left.Style = ExcelBorderStyle.Thin;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				range.Style.Border.Right.Style = ExcelBorderStyle.Thin;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				range.Style.Border.Bottom.Style = ExcelBorderStyle.Thin;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#75715e&#34;&gt;// 標題列&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; title = ws.Cells[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, cols];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				title.Style.Fill.PatternType = ExcelFillStyle.Solid; &lt;span style=&#34;color:#75715e&#34;&gt;// 設定背景填色方法&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				title.Style.Fill.BackgroundColor.SetColor(Color.LightGray);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			Debug.WriteLine(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;未列印資料，請檢查是否傳入資料為空，或指定類別未具有公開且加上 DisplayName 的屬性。&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		excel.Save(); &lt;span style=&#34;color:#75715e&#34;&gt;// 儲存 Excel&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;//output.Position = 0; // 如果是使用 stream 的方式讓人下載，請記得將指標移回資料起始&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; output;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;testClass&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;	[DisplayName(&amp;#34;編號&amp;#34;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Guid id { &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;; } = Guid.NewGuid();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;	[DisplayName(&amp;#34;名稱&amp;#34;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; name { &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;結語&#34;&gt;結語&lt;/h2&gt;
&lt;p&gt;這次是為了把小工具記下來，方便以後在外可以直接開網站起來左手抄右手所以硬是丟了一篇出來；關於基本操作的部份說明實在有點偷懶，以後有機會再進行補充和功能示範。現在還請海涵，幸虧官方的 Github 頁面 Wiki 實在相當完善，對操作有疑問的朋友可以先按照官方 Wiki 跑一次，相信可以非常快上手。&lt;/p&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/EPPlusSoftware/EPPlus/wiki&#34;&gt;EPPlus Wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.darkthread.net/blog/epplus/&#34;&gt;比 NPOI 更討喜的 Excel 元件 - EPPlus! - 黑暗執行緒&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/rumeng/p/3785748.html&#34;&gt;導出 Excel 之 Epplus 使用教程 - Wico&amp;rsquo;s Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/malonestudyrecord/2018/03/21/103124&#34;&gt;使用 EPPLUS 操控 Excel - 碼農的學習日誌&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.itread01.com/content/1543037183.html&#34;&gt;.Net Excel 匯出圖表Demo(柱狀圖，多標籤頁) - IT閱讀&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>我要訂便當 (3): 用 Python &#43; Line Notify 傳送通知</title>
      <link>https://igouist.github.io/post/2020/04/bandon-3-line-notify/</link>
      <pubDate>Sun, 05 Apr 2020 19:36:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/04/bandon-3-line-notify/</guid>
      <description>&lt;p&gt;前情提要：&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&#34;https://igouist.github.io/post/2020/03/bandon-1-selenium/&#34;&gt;我要訂便當(1) —— 用 Python + Selenium 控制瀏覽器取得訂單&lt;/a&gt; 中，我們嘗試了用 Selenium 控制瀏覽器去取回訂便當團購網的訂單內容&lt;/p&gt;
&lt;p&gt;而在 &lt;a href=&#34;https://igouist.github.io/post/2020/03/bandon-2-sqlite/&#34;&gt;我要訂便當(2) —— 用 Python + Sqlite 儲存訂單&lt;/a&gt; 中，我們使用 Sqlite 達到將訂單儲存起來以判斷是否有新的訂單，因此這邊的下一步就是需要進行通知。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目標：&lt;strong&gt;使用 Line Notify，當有新訂單的時候就發送通知&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://notify-bot.line.me/zh_TW/&#34;&gt;Line Notify&lt;/a&gt;&lt;/strong&gt; 是 Line 上面的通知服務，不像 Line@ 一樣可以有品牌有互動等等，Line Notify 純粹就是訊息通知；但同時對比 Line@ 最近吵得沸沸揚揚的收費和大量跳槽，Line Notify 則是免費的服務。&lt;/p&gt;
&lt;p&gt;Line Notify 的運作上分為發送訊息和接受訊息。當我們使用 Line 帳號申請 Line Notify 的服務後就可以得到一個 Access Token，藉由這組 Access Token 就能夠讓我們的程式和服務去發送通知。這些通知會由一個叫做 LINE Notify 的官方帳號發送給有訂閱這個通知的人。&lt;/p&gt;
&lt;p&gt;基於這個工作原理，像是需要經營品牌的服務就不太適合 Line Notify，反之像是&lt;strong&gt;伺服器斷線、設備超載等等這些個人通知性質比較高的服務就很適合使用 Line Notify&lt;/strong&gt;。這點從 &lt;a href=&#34;https://notify-bot.line.me/zh_TW/&#34;&gt;Line Notify 網頁&lt;/a&gt; 下方的示意圖也可以略知一二。&lt;/p&gt;
&lt;p&gt;當然像我們這次的需求是「如果有新的團購便當 就 通知我」，相當符合使用場景，因此這邊就嘗試使用看看並記錄下來。&lt;/p&gt;
&lt;p&gt;如果需要更多 Line Notify 的說明，保哥的這篇 &lt;a href=&#34;https://blog.miniasp.com/post/2020/02/17/Go-Through-LINE-Notify-Without-Any-Code&#34;&gt;上手 LINE Notify 不求人：一行代碼都不用寫的推播通知方法&lt;/a&gt; 介紹的更為完整，推薦參閱。當然，也可以閱讀 &lt;a href=&#34;https://notify-bot.line.me/doc/en/&#34;&gt;Line Notify 官方文件&lt;/a&gt;。那麼，我們開始吧～&lt;/p&gt;
&lt;h2 id=&#34;申請-line-notify&#34;&gt;申請 Line Notify&lt;/h2&gt;
&lt;p&gt;首先先到 &lt;a href=&#34;https://notify-bot.line.me/zh_TW/&#34;&gt;Line Notify&lt;/a&gt; 的頁面右上角登入&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/VAJV0X1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;登入之後，從右上角選擇 個人頁面&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Rizyl5e.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接著可以看到下面這個畫面：如果已經有申請過權杖或服務，就會顯示在上半部分的「已連動的服務」
而我們現在需要的是下方的發行權杖
&lt;img src=&#34;https://i.imgur.com/zNivpLD.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接著進到選擇通知視窗的畫面，在這邊可以選擇是直接通知你自己 或是將通知傳送到某個群組
&lt;img src=&#34;https://i.imgur.com/zt2JUrI.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;選擇通知對象之後，就會顯示存取用的 Token。由於&lt;strong&gt;這組 Token 只會顯示一次，請自己複製下來存好！&lt;/strong&gt;
&lt;img src=&#34;https://i.imgur.com/Mob0tR6.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;存取完畢後就可以看到這次申請的服務已經加到已連動的服務囉
&lt;img src=&#34;https://i.imgur.com/cT5omou.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;並且 Line 也會跳出已連動的通知
&lt;img src=&#34;https://i.imgur.com/NegLeh6.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;到這邊就算是申請完畢了，接下來就要來測試一下是否能發送。&lt;/p&gt;
&lt;h2 id=&#34;發送-line-notify&#34;&gt;發送 Line Notify&lt;/h2&gt;
&lt;p&gt;這邊測試的 Code 主要參考 &lt;a href=&#34;https://bustlec.github.io/note/2018/07/10/line-notify-using-python/&#34;&gt;使用 Python 實作發送 LINE Notify 訊息 - Bustle C.&lt;/a&gt;，感謝前人的足跡。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; requests
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lineNotifyMessage&lt;/span&gt;(token, msg):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    headers &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Authorization&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Bearer &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; token, &lt;span style=&#34;color:#75715e&#34;&gt;# 權杖，Bearer 的空格不要刪掉呦&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Content-Type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;application/x-www-form-urlencoded&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    payload &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;message&amp;#39;&lt;/span&gt;: msg}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# Post 封包出去給 Line Notify&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; requests&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;post(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;https://notify-api.line.me/api/notify&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        headers&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;headers, 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        params&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;payload)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; r&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;status_code
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;message &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Line Notify 測試&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;token &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;把你的 Token 放在這&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lineNotifyMessage(token, message)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(result) &lt;span style=&#34;color:#75715e&#34;&gt;# 印一下回傳代碼&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;執行 py 檔之後就可以收到訊息囉！
&lt;img src=&#34;https://i.imgur.com/v32rItf.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果回傳成功，&lt;code&gt;r.status_code&lt;/code&gt; 就會顯示 &lt;code&gt;200&lt;/code&gt;；而如果像是 Token 已經被撤銷等，則會得到 &lt;code&gt;401&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;關於 200, 401.. 這些回傳的狀態碼，可以參閱 &lt;a href=&#34;https://igouist.github.io/post/2021/05/newbie-2-webapi/#%E9%97%9C%E6%96%BC-http-status-code&#34;&gt;HTTP Status&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外當然也可以傳送圖片或貼圖，請參閱 &lt;a href=&#34;https://www.oxxostudio.tw/articles/201806/line-notify.html&#34;&gt;自建 LINE Notify 訊息通知 - Oxxo studio&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;和訂便當腳本結合&#34;&gt;和訂便當腳本結合&lt;/h2&gt;
&lt;p&gt;接著我們就將這個寄發 Line Notify 的 Function 給放回我們之前的訂便當腳本中。並在發現訂單異動的部分去呼叫 &lt;code&gt;lineNotifyMessage&lt;/code&gt; 來通知我們&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-python=47&#34; data-lang=&#34;python=47&#34;&gt;# ...
print(&amp;#34;偵測到訂單變動！&amp;#34;)
# 做點通知的事
message = &amp;#34;訂單已變動，請到 https://dinbendon.net/ 確認！&amp;#34;
result = lineNotifyMessage(token, message)
print_order(order)
# ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/j6bkIHg.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;打完收工！接著不管是要 比對新舊訂單並發送這次新的訂單資訊；或者是要順便發送目前的訂單數量等等，都是只差在訊息內容的修改而已（我是直接發送 &lt;code&gt;&amp;quot;,&amp;quot;.join(orderList)&lt;/code&gt; 來看目前有哪些訂單）屆此已經可以宣告收工囉。&lt;/p&gt;
&lt;h2 id=&#34;心得&#34;&gt;心得&lt;/h2&gt;
&lt;p&gt;在像這種單純通知的場合中，Line Notify 有架設簡單、即時方便的特性。並且也已經提供了和 Github 等連接的服務，因此像是伺服器斷線或是有新的提取要求、甚至是爬蟲去看手遊有沒有新活動時，都可以考慮建立一個群組並用 Line Notify 來達到低成本推播的要求，可謂相當方便！希望將來能再回來抄自己這篇把各種推播提醒都拉到 Line Notify 集中管理，&lt;del&gt;不然除了機器人也不會有人 Line 我…&lt;/del&gt;&lt;/p&gt;
&lt;h2 id=&#34;我要訂便當系列&#34;&gt;我要訂便當系列&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/03/bandon-1-selenium/&#34;&gt;我要訂便當(1) —— 用 Python + Selenium 控制瀏覽器取得訂單&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/03/bandon-2-sqlite/&#34;&gt;我要訂便當(2) —— 用 Python + Sqlite 儲存訂單&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/04/bandon-3-line-notify/&#34;&gt;我要訂便當(3) —— 用 Python + Line Notify 傳送通知&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/05/bandon-4-heroku/&#34;&gt;我要訂便當(4) —— 將 Python 腳本部署上 Heroku&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/05/bandon-5-heroku-debug/&#34;&gt;我要訂便當(5) —— Heroku 填坑小記&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.miniasp.com/post/2020/02/17/Go-Through-LINE-Notify-Without-Any-Code&#34;&gt;上手 LINE Notify 不求人：一行代碼都不用寫的推播通知方法 - The Will Will Web&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.oxxostudio.tw/articles/201806/line-notify.html&#34;&gt;自建 LINE Notify 訊息通知 - Oxxo studio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blogger.jackkuo.org/2019/01/line-notify.html&#34;&gt;LINE Notify 初嚐心得 - JackKuo&amp;rsquo;s Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.evanlin.com/go-line-notify/&#34;&gt;[Golang][LINE][教學] 如何快速建置一個 LINE Notify 的服務 - KKDAI.GITHUB.IO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bustlec.github.io/note/2018/07/10/line-notify-using-python/&#34;&gt;使用 Python 實作發送 LINE Notify 訊息 - Bustle C.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10223413&#34;&gt;Day15-Python Line 整合應用 &amp;ndash; Line Notify&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Visual studio 環境設定 —— 字型、套件、快捷鍵</title>
      <link>https://igouist.github.io/post/2020/03/visualstudio/</link>
      <pubDate>Sat, 28 Mar 2020 00:11:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/03/visualstudio/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;目標：整理一下自己用的&lt;strong&gt;字型、插件和快捷鍵&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天在工作時寫到一半突然藍屏，重開機之後俺的地表最強編譯器 Visual Studio 整個就開始鬧脾氣，打開專案整排都是 Error，連 System.Object 都找不到，差點往生。還好用了修復功能之後一切恢復正常，但是載入的插件和一些個人設定就這樣重置了……&lt;/p&gt;
&lt;p&gt;為了之後可能還會遇到相同的事情，這邊就先將平常的 Visual Studio 環境用到的設定做一份紀錄，之後遇到新插件或是什麼功能也可以回來更新這篇文，如此一來下次又被洗白的時候就可以回來參考了。&lt;/p&gt;
&lt;p&gt;這邊主要會記錄三個部分，並隨時可能更新。主要是字型、使用的插件以及常用的快捷鍵。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;不過我的 Visual Studio 也被洗白了所以這篇會跟著找回失落插件的歷程慢慢補上QQ&lt;/del&gt;&lt;/p&gt;
&lt;h2 id=&#34;字型&#34;&gt;字型&lt;/h2&gt;
&lt;p&gt;字型部分必定、絕對要使用&lt;strong&gt;等寬字型&lt;/strong&gt;，這是必要的前提也是絕對的共識，畢竟你不會希望有什麼神秘空白，或是推個版就排版大炸裂之類的。&lt;/p&gt;
&lt;p&gt;推薦先參閱 &lt;a href=&#34;https://kevintsengtw.blogspot.com/2014/08/blog-post.html&#34;&gt;換個好字型讓程式開發有效率&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(2021/1/27) 補充：字型也可以看 &lt;a href=&#34;https://devfonts.gafi.dev/&#34;&gt;devfonts&lt;/a&gt; 。裡面直接放了超多 Coding 常用字型，也可以貼上 Code 直接進行比較，相當貼心。想逛一下挑個順眼字型的朋友直接試試唄。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;consolas&#34;&gt;Consolas&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/az9u0B3.png&#34; alt=&#34;&#34;&gt;
內建就有的字體，個人認為在不想另外下載字體的時候是相當優質的選擇。&lt;/p&gt;
&lt;p&gt;看起來粗粗圓圓的很放鬆。&lt;/p&gt;
&lt;h3 id=&#34;firacode&#34;&gt;FiraCode&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/9OJpMXL.png&#34; alt=&#34;&#34;&gt;
&lt;a href=&#34;https://github.com/tonsky/FiraCode&#34;&gt;FiraCode&lt;/a&gt;，整體看起來就是乾淨優雅，尤其是連字能使得整個 Code 更有滑順的感覺，十分推薦。&lt;/p&gt;
&lt;p&gt;然而，FiraCode 雖然陪伴我一段不短的時間，但還是有一個致命的缺陷：不支援中文！&lt;/p&gt;
&lt;p&gt;於是後來我基本上都使用下面介紹的這款&lt;/p&gt;
&lt;h3 id=&#34;更紗黑體&#34;&gt;更紗黑體&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/yVMe5wC.png&#34; alt=&#34;&#34;&gt;
&lt;a href=&#34;https://github.com/be5invis/Sarasa-Gothic&#34;&gt;更紗黑體&lt;/a&gt; 除了同樣支援連字以外，更支援多國語系。例如繁中就是有標註 TC 的字形，看見中英文都套用上去就是一陣舒服。是現在我的主力。&lt;/p&gt;
&lt;p&gt;至於不想用等寬字體的朋友，都看到這裡了，沒關係。下面這套推薦給你們&lt;/p&gt;
&lt;h3 id=&#34;ink-free&#34;&gt;Ink Free&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/EShjvS5.png&#34; alt=&#34;&#34;&gt;
就是這麼直接！這麼舒服！如果你的同事要過來 Code Review，不要猶豫字體直接換下去！&lt;/p&gt;
&lt;h2 id=&#34;變更環境字體&#34;&gt;變更環境字體&lt;/h2&gt;
&lt;p&gt;前面介紹了一些好用的字體，以及 &lt;a href=&#34;https://devfonts.gafi.dev/&#34;&gt;devfonts&lt;/a&gt; 這個超讚網站。接著就讓我們來設定 Visual Studio 的字體吧。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;工具 &amp;gt; 選項 &amp;gt; 環境 &amp;gt; 字型與色彩&lt;/code&gt; 中，能設定當前使用的字型。其中顯示設定可以選擇要變更哪個區塊的字型，最常用的應該就是改程式碼字型的「文字編輯器」了。&lt;/p&gt;
&lt;p&gt;這邊推薦一下我個人還會調整的部份：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CodeLens&lt;/li&gt;
&lt;li&gt;陳述式完成&lt;/li&gt;
&lt;li&gt;編譯器工具提示&lt;/li&gt;
&lt;li&gt;環境&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/m2zfp6K.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;影響到的範圍會有&lt;/p&gt;
&lt;p&gt;環境相關的字體，例如上方的工具列&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/H5t6Jun.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/9hYcnfn.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;按下 &lt;code&gt;Alt + Enter&lt;/code&gt; 的小提示、方法上方的 CodeLen 小提示（N 個參考那個）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/lHf3SHe.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;自動補完和註解說明等等&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/SaMzVkA.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;另外我個人還會把清單裡任何加上 &lt;code&gt;[]&lt;/code&gt; 的部份的字型也改掉：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有文具工具&lt;/li&gt;
&lt;li&gt;監看式、區域變數及自動變數工具視窗&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果再搭配上&lt;a href=&#34;#%E9%85%8D%E8%89%B2%E4%B8%BB%E9%A1%8C&#34;&gt;配色主題&lt;/a&gt;就可以把整個 IDE 弄得更賞心悅目囉！&lt;/p&gt;
&lt;h2 id=&#34;擴充套件&#34;&gt;擴充套件&lt;/h2&gt;
&lt;h3 id=&#34;codemaid&#34;&gt;CodeMaid&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;市集頁面：&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=SteveCadwallader.CodeMaid&#34;&gt;CodeMaid&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;極實用，我平常主要用到的功能是看&lt;strong&gt;複雜度&lt;/strong&gt;和&lt;strong&gt;自動排版&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/pf897N7.png&#34; alt=&#34;&#34;&gt;
安裝之後可以開啟 CodeMaid Spade，其中函式右側的就是該函式的複雜度，複雜度指得就是該函式中各種不同狀況的路徑數量，例如一個 IF 就會有兩條路徑。&lt;/p&gt;
&lt;p&gt;而複雜度相當高的時候 CodeMaid Spade 的字體會變成紅色，屆時就應該思考這個函式是否做了太多事情，也就是有太多&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;職責&lt;/a&gt;？是否應該把部分功能抽出來？平常可以迅速地提供參考。關於複雜度相關的工具也可以參閱：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kevintsengtw.blogspot.com/2015/09/visual-studio-microsoft-codelens-code.html&#34;&gt;Visual Studio - Microsoft CodeLens Code Health Indicator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kevintsengtw.blogspot.com/2015/02/visual-studio-code-metrics-viewer-2013.html&#34;&gt;Visual Studio 計算程式碼度量 - Code Metrics Viewer 2013&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/sb2440G.png&#34; alt=&#34;&#34;&gt;
除了看見複雜度以外，這個插件的主要功能就在於程式碼的排版和整理，甚至可以設定成每當儲存時自動排版一次。對我這種懶人來說可是一大福音。但要小心跟其他人協作的時候如果全部重新排版可能動到人家的 Code 而且推送時的變更會爆炸多，要稍微注意。平常就養成順手 &lt;code&gt;Ctrl + K&lt;/code&gt;、&lt;code&gt;Ctrl + D&lt;/code&gt; 的習慣會更好。&lt;/p&gt;
&lt;h3 id=&#34;codemaintainibility&#34;&gt;CodeMaintainibility&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;市集頁面： &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=ognjen-babic.code-maintainibility&#34;&gt;Code Maintainibility&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提到複雜度，也可以安裝這套 Code Maintainibility，在看複雜度的時候能夠更快更方便！&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/90Ox0rF.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;一樣在「管理擴充功能」直接搜尋就可以了，但這個套件似乎有改版過。我更新了 Visual Studio 才搜尋得到，如果找不到的朋友可以先嘗試更新看看。&lt;/p&gt;
&lt;p&gt;安裝之後就可以直接在各個 Function 上方的 CodeLens 直接看到複雜度指標囉！&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/No3C6yH.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;點開來也會顯示各項指標，包括可維護性、霍爾斯特德複雜度等等&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/aOCbIp1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;也可以在設定之中調整預設顯示的指標&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/amDpQtp.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;這樣在撰寫和重構程式碼的時候就可以迅速又清楚看見複雜度指標，&lt;s&gt;心裡也至少有個底&lt;/s&gt;，可以說是方便不少呢&lt;/p&gt;
&lt;h3 id=&#34;editor-guidelines&#34;&gt;Editor Guidelines&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;市集頁面：&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=PaulHarrington.EditorGuidelines&#34;&gt;Editor Guidelines&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在指定字數位置&lt;strong&gt;劃出直的輔助線&lt;/strong&gt;，我都用來標示出 100 字元 和 120 字元的位置，用來提醒自己要換行，以保持程式碼可以直直地閱讀下去，而不會為了往右滾動或是因為自動斷行在奇怪地方而中斷。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/yBffyf3.png&#34; alt=&#34;&#34;&gt;
可以看見右側有輔助線，通常只要長到碰到該線我就會將該行程式碼做斷行的調整。&lt;/p&gt;
&lt;p&gt;安裝之後可以在編輯器的任何位置按下右鍵，就可以增加和移除輔助線。
&lt;img src=&#34;https://i.imgur.com/0YqkYFI.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果想要在確切字元位置（如 100 字元），則可以在 &lt;code&gt;檢視 → 其他視窗 → 命令視窗&lt;/code&gt; 裡面輸入指令來加入輔助線&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Edit.AddGuideline 100 // 添加輔助線
Edit.RemoveAllGuidelines // 移除輔助線
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;關於換行的重要性，這篇 &lt;a href=&#34;https://kevintsengtw.blogspot.com/2015/02/visual-studio-part1.html&#34;&gt;調整你的 Visual Studio - Part.1&lt;/a&gt; 說明得很仔細，並且也有上面 CodeMaid 的介紹，我之所以打算紀錄我的套件等也是基於這幾篇，推薦閱讀。&lt;/p&gt;
&lt;h3 id=&#34;codeblockendtag&#34;&gt;CodeBlockEndTag&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;市集頁面：&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=KhaosPrinz.CodeBlockEndTag&#34;&gt;CodeBlockEndTag&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主要是在&lt;strong&gt;括弧的結束部分會顯示出這個括弧所屬的區塊&lt;/strong&gt;（如附圖）。我有看見許多同事都使用替括弧上色的作法，不過我個人不喜歡太過五彩繽紛的感覺，因此強烈推薦這款插件。&lt;/p&gt;
&lt;p&gt;下載之後可以在 &lt;code&gt;工具 → 選項 → KC Extensions&lt;/code&gt; 裡面調整，有 當上括弧在畫面外時才顯示下括弧的文字，以及一律顯示（我個人都是使用一律顯示）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/sRCndm3.png&#34; alt=&#34;&#34;&gt;
可以看見 IF 跟函式結束的地方都有標示出括弧對應的區塊，在多層巢狀的時候相當有幫助。（雖然說更重要的是應該避免做出多層巢狀就是了）&lt;/p&gt;
&lt;h3 id=&#34;smartpaster&#34;&gt;SmartPaster&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;市集頁面：&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=martinw.SmartPaster2013&#34;&gt;SmartPaster2019&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;貼上的時候可以&lt;strong&gt;選擇貼上的格式&lt;/strong&gt;，在插件介紹頁的示意圖就能夠一目瞭然。&lt;/p&gt;
&lt;h3 id=&#34;time-savers&#34;&gt;Time Savers&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;市集頁面：&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=YannDuran.VisualStudioTimeSavers&#34;&gt;Time Savers&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;單純的省時小工具，可以&lt;strong&gt;在上方的工具列幫你長出一些 建置、以管理員重開等按鍵&lt;/strong&gt;。畢竟和建置那些可以直接快捷鍵的動作不一樣，有時候沒有以系統管理員身分開 Visual Studio 的時候會遇到一些神秘錯誤，重開又挺麻煩，因此直接放顆按鈕在上面是真的省了不少時間，要記得遵守工程師的美德：懶惰。能省時就省時！&lt;/p&gt;
&lt;h3 id=&#34;claudiaide&#34;&gt;ClaudiaIDE&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;市集頁面：&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=kbuchi.ClaudiaIDE&#34;&gt;ClaudiaIDE&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這個跟效率就沒啥太大關係了，所以特別放在壓軸哈，這插件主要是用來&lt;strong&gt;修改編譯區塊的背景&lt;/strong&gt;使用的。&lt;/p&gt;
&lt;p&gt;剛安裝下來之後打開 Visual Studio 就會看到一個妹子。
&lt;img src=&#34;https://i.imgur.com/op0y1wf.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;當然這個背景圖是可以自由變更的，打開 &lt;code&gt;工具 → 選項 → ClaudiaIDE&lt;/code&gt; 就會看到以下的設置畫面
&lt;img src=&#34;https://i.imgur.com/O3KAm0N.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;主要會變動的地方會有 Opacity 透明度、File Path 圖片路徑 以及 Image Stretch 圖片填滿或是延展 這些設定，根據個人經驗，盡量用深色背景圖加上透明會比較順眼，主要還是要以不干擾閱讀程式碼為主&lt;/p&gt;
&lt;p&gt;像我這麼低調的換個藍底的 VS Logo 就足夠竊喜好一陣子了
&lt;img src=&#34;https://i.imgur.com/gjlxy52.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;順帶一提我同事的背景圖是用這張，嗯……
&lt;img src=&#34;https://i.imgur.com/YER0385.png&#34; alt=&#34;&#34;&gt;
（載下來示範截圖之後立馬換回來，實在過於微妙）&lt;/p&gt;
&lt;h3 id=&#34;visual-studio-iconizer&#34;&gt;Visual Studio Iconizer&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;市集頁面：&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=OlegTarasov.VisualStudioIconizerforVisualStudio15&#34;&gt;Visual Studio Iconizer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這個則是讓你的 Visual Studio 質感飛升的關鍵：它會替你的工具欄加上 icon！&lt;/p&gt;
&lt;p&gt;先來看看原本的工具視窗釘選之後長怎樣：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/s0zVMsN.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;安裝後：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/004mjQq.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;當然如果怕找不到的話，也可以圖文並行（&lt;code&gt;工具 → 選項 → iconizer&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ScUCjeU.png&#34; alt=&#34;Image&#34;&gt;&lt;img src=&#34;https://i.imgur.com/WjLE5Tf.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;output-enhancer--metaoutput&#34;&gt;Output enhancer &amp;amp; MetaOutput&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;市集頁面：&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=NikolayBalakin.Outputenhancer&#34;&gt;Output enhancer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最後來介紹個實用的 Output enhancer：替你的輸出視窗上色&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/KGW1DrK.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;警告跟錯誤等等就會更顯眼囉！&lt;/p&gt;
&lt;p&gt;如果想要更進一步也可以使用他們的另一款整合過的 &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=ViacheslavLozinskyi.MetaOutput-2019&#34;&gt;MetaOutput&lt;/a&gt;（&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=ViacheslavLozinskyi.MetaOutput-2022&#34;&gt;2022&lt;/a&gt;），輸出視窗就會變為條列式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/IRBlGGv.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;除了會折疊輸出訊息以外，也能調整哪部分訊息可以省略：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/KQutBi1.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;也可以進行搜尋：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/0lNna9g.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;個人覺得挺方便的。雖然日常狀況還是等紅字跳出來再說 XD&lt;/p&gt;
&lt;h2 id=&#34;設定&#34;&gt;設定&lt;/h2&gt;
&lt;h3 id=&#34;變更-visual-studio-程式碼的配色為新版本-2019&#34;&gt;變更 Visual Studio 程式碼的配色為新版本 (2019)&lt;/h3&gt;
&lt;p&gt;Visual Studio 2019 預設的程式碼配色會是 2017 版本的，因此可以先調整更改成 2019 版本。&lt;/p&gt;
&lt;p&gt;更改的位置在 &lt;code&gt;工具 &amp;gt; 選項 &amp;gt; 文字編輯器 &amp;gt; C# (看個人使用語言) &amp;gt; 進階&lt;/code&gt; 接著拉至最底找到 &lt;code&gt;編輯器色彩配置&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/lbUP19r.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;把它更改成 2019 版本的就可以囉&lt;/p&gt;
&lt;p&gt;變更前：
&lt;img src=&#34;https://i.imgur.com/IMr2ViF.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;變更後：
&lt;img src=&#34;https://i.imgur.com/s0zYjmu.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到變數、方法都有上色了，在整排 Linq 連發的 Code 裡面可是相當實用呢&lt;/p&gt;
&lt;h3 id=&#34;開啟內嵌提示&#34;&gt;開啟內嵌提示&lt;/h3&gt;
&lt;p&gt;這邊推薦把「內嵌提示」這個實驗性功能打開，可以大大增加程式碼的可讀性。&lt;/p&gt;
&lt;p&gt;首先讓我們先到 &lt;code&gt;選項 &amp;gt; 文字編輯器 &amp;gt; C# &amp;gt; 進階&lt;/code&gt;，並且往下拉就可以看到內嵌提示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/FMERRDD.png&#34; alt=&#34;image-20210830065440439&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中「&lt;strong&gt;顯示內嵌參數名稱&lt;/strong&gt;」勾選起來的話，就會在呼叫方法時顯示該參數的名稱，如下圖的 &lt;code&gt;startIndex&lt;/code&gt; 和 &lt;code&gt;length&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/7QCEEkY.png&#34; alt=&#34;image-20210830065736932&#34;&gt;&lt;/p&gt;
&lt;p&gt;像這種呼叫方法時傳遞的常數，例如 &lt;code&gt;0&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt; 等等，加上參數名稱就能大大提升可讀性。&lt;/p&gt;
&lt;p&gt;但當我們是傳遞變數的時候，常常都已經針對該物件做好妥善的命名了，所以可以把子項的「當參數名稱符合方法的意圖時，不出現提示」也勾選起來，避免命名已經足夠描述內容時反而造成干擾。&lt;/p&gt;
&lt;p&gt;接著「&lt;strong&gt;顯示內嵌類型提示&lt;/strong&gt;」也可以勾選起來，顧名思義就是會在洽當的時候提醒你「這東西是這個型別呦！」的小助手。&lt;/p&gt;
&lt;p&gt;其中我會關閉第一項「顯示有推斷類型之變數的提示」，它的效果就是每當你使用 &lt;code&gt;var&lt;/code&gt; 的時候就會顯示推測的型別，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/nGyRm6J.png&#34; alt=&#34;image-20210830071205401&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到 &lt;code&gt;var&lt;/code&gt; 的後面會補上型別。&lt;del&gt;不過這樣我排版就亂掉了，而且我就是打算把型別丟給 C# 處理才用 var 的所以掰掰&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;而第二項「&lt;strong&gt;顯示 Lambda 參數類型的提示&lt;/strong&gt;」這個就相當推薦打開了，作用的方式會像這樣：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/RVqvtcJ.png&#34; alt=&#34;image-20210830071404915&#34;&gt;&lt;/p&gt;
&lt;p&gt;當你在使用 Linq 的時候，就能更清楚知道現在自己在操作的是哪個型別、哪個部分。在 &lt;code&gt;Join&lt;/code&gt;、&lt;code&gt;Groupby&lt;/code&gt; 等等需要對串列連續地進行處理的時候，能夠發揮莫大的功效，特別強烈推薦要打開。&lt;/p&gt;
&lt;h3 id=&#34;對目前所在行醒目提示&#34;&gt;對目前所在行醒目提示&lt;/h3&gt;
&lt;p&gt;這段其實是發完文之後才補充的啦，這邊要推薦一個好用的設定：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;工具 &amp;gt; 選項 &amp;gt; 環境 &amp;gt; 字型與色彩&lt;/code&gt; 然後在下拉式選單找到 &lt;code&gt;反白顯示目前的行&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;就可以對游標所在的那行做醒目提示囉！&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/qvh8i8l.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;圖中的綠色就是醒目提示。&lt;/p&gt;
&lt;p&gt;之前和大前輩聊到這個反白行，前輩表示他很討厭，因為他不太需要一條會干擾的色塊告訴他正在這&lt;/p&gt;
&lt;p&gt;但像我這種菜雞，按著 Ctrl + G 就不知道自己飛哪裡去了，還是標記一下好哈哈。&lt;/p&gt;
&lt;h3 id=&#34;調整索引標籤設定&#34;&gt;調整索引標籤設定&lt;/h3&gt;
&lt;p&gt;個人習慣將索引標籤放在右側，如此一來就可以更清楚地看到檔案名稱，而且條列式地由上往下看還是比較符合平時看 Code 的習慣。&lt;/p&gt;
&lt;p&gt;索引標籤的位置可以在 &lt;code&gt;工具 &amp;gt; 選項 &amp;gt; 環境 &amp;gt; 索引標籤和視窗&lt;/code&gt; 裡進行調整：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/sIRwNBz.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;這邊也強烈建議將 專案/路徑 分組勾選開來，可以幫助我們更快找到開啟的索引：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/urbQnTd.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;在 Visual Studio 2022 時，可以更進一步打開依專案著色索引的功能：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/4mmuJqs.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/5fVIZlL.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;這樣開一堆索引要找的時候就更快了！&lt;/p&gt;
&lt;p&gt;&lt;del&gt;如果從來不用索引標籤，就是無情的 &lt;code&gt;Ctrl T&lt;/code&gt; 或是 &lt;code&gt;Ctrl Tab&lt;/code&gt; 打全場的也可以不用上色沒關係就是了…&lt;/del&gt;&lt;/p&gt;
&lt;h2 id=&#34;配色主題&#34;&gt;配色主題&lt;/h2&gt;
&lt;h3 id=&#34;one-dark-pro&#34;&gt;One Dark Pro&lt;/h3&gt;
&lt;p&gt;這邊推薦我在 Visual Studio Code 也很愛用的主題：&lt;strong&gt;One Dark Pro&lt;/strong&gt;，前陣子才發現居然在 Visual Studio 上也能看到熟悉的配色，馬上就安裝下來了。&lt;/p&gt;
&lt;p&gt;因為它也是擴充套件之一，所以一樣讓我們打開 &lt;code&gt;延伸模組 &amp;gt; 管理延伸模組&lt;/code&gt;，並搜尋 &lt;code&gt;One Dark Pro&lt;/code&gt;，找到並安裝下來：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/pXGqoqd.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;下載好之後需要關閉 Visual Studio 安裝一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/CGuQ6ge.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;安裝好了之後重新開啟 Visual Studio，並前往 &lt;code&gt;工具 &amp;gt; 選項&lt;/code&gt;，在左邊找到 &lt;code&gt;環境&lt;/code&gt;，就可以從色彩佈景主題裡選擇 One Dark Pro 囉：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ZrtztVV.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/4oBef8K.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;果然還是熟悉的配色最對味～大家也可以嘗試安裝看看配色主題呦！會有一番新滋味呢。&lt;/p&gt;
&lt;h2 id=&#34;快捷鍵&#34;&gt;快捷鍵&lt;/h2&gt;
&lt;p&gt;最後大概整理一下平常會按到的快捷鍵，方便上班在外可以直接回來偷看。（希望有朝一日能夠寫起來時雙手不離鍵盤 XD）&lt;/p&gt;
&lt;h3 id=&#34;偵錯&#34;&gt;偵錯&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;執行(debug)：F5&lt;/li&gt;
&lt;li&gt;執行(non debug)：Ctrl + F5&lt;/li&gt;
&lt;li&gt;全部儲存：Ctrl + Shift + S&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;單步執行：F11 (F10)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;切換斷點：F9&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;啟用/停用斷點：Ctrl + F9&lt;/li&gt;
&lt;li&gt;刪除所有斷點：Ctrl + Shift + F9&lt;/li&gt;
&lt;li&gt;（單元測試）對全部測試：Ctrl + R, A&lt;/li&gt;
&lt;li&gt;（單元測試）對全部偵錯：Ctrl + R, Ctrl + A&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;檢視&#34;&gt;檢視&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;程式碼編輯器分頁切換 ：Ctrl+TAB&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;顯示屬性窗口：F4&lt;/li&gt;
&lt;li&gt;關閉目前視窗：Ctrl + F4&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;移至定義：F12&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;列出參考：Shift + F12&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;移至目標：Ctrl + T =&amp;gt; 輸入目標&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;巡覽列：Ctrl + F2 =&amp;gt; Tab&lt;/li&gt;
&lt;li&gt;工具列：Alt + (對應鍵)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;線上搜尋微軟官方文件：F1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;回到編輯器區塊：F7&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/03/visual-studio-bookmark/&#34;&gt;書籤&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;在指定行號上新增書籤：Ctrl + K, Ctrl + K&lt;/li&gt;
&lt;li&gt;開啟書籤視窗：Ctrl + K, Ctrl + W&lt;/li&gt;
&lt;li&gt;移動到上一個書籤：Ctrl + K, Ctrl + P&lt;/li&gt;
&lt;li&gt;移動到下一個書籤：Ctrl + K, Ctrl + N&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;編輯&#34;&gt;編輯&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;選取目前文字：Ctrl + W&lt;/li&gt;
&lt;li&gt;選取同個變數：Shift + Ctrl + ↑/↓&lt;/li&gt;
&lt;li&gt;選取目標區塊：Shift + Ctrl + }&lt;/li&gt;
&lt;li&gt;註解選取範圍：Ctrl + K,C&lt;/li&gt;
&lt;li&gt;取消註解選取範圍：Ctrl + K,U&lt;/li&gt;
&lt;li&gt;選取文字改小寫：Ctrl + U&lt;/li&gt;
&lt;li&gt;選取文字改大寫：Ctrl + Shift + U&lt;/li&gt;
&lt;li&gt;呼叫出類別成員：Ctrl + J (編到一半時 tips 突然不見很好用)&lt;/li&gt;
&lt;li&gt;收攏原始碼：Ctrl + M, O&lt;/li&gt;
&lt;li&gt;展開原始碼：Ctrl + M, L&lt;/li&gt;
&lt;li&gt;收攏／展開當前區塊：Ctrl + M, Ctrl + M&lt;/li&gt;
&lt;li&gt;刪除目前這行：Ctrl + Shift + L&lt;/li&gt;
&lt;li&gt;刪除目前往後：Ctrl + Delete&lt;/li&gt;
&lt;li&gt;檔案最前面：Shift + Home&lt;/li&gt;
&lt;li&gt;檔案最後面：Shift + End&lt;/li&gt;
&lt;li&gt;選到最前面：Ctrl + Shift + Home&lt;/li&gt;
&lt;li&gt;選到最後面：Ctrl + Shift + End&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跳至行號：Ctrl + G&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在上面插入一行： Ctrl + Enter&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多行選取：Shift + Alt + ↑ or ↓&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;打開右鍵選單：Shift + F10&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kevintsengtw.blogspot.com/2014/08/blog-post.html&#34;&gt;換個好字型讓程式開發有效率&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kevintsengtw.blogspot.com/2015/02/visual-studio-part1.html&#34;&gt;調整你的 Visual Studio - Part.1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kevintsengtw.blogspot.com/2015/02/visual-studio-part2.html&#34;&gt;調整你的 Visual Studio - Part.2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kevintsengtw.blogspot.com/2015/09/visual-studio-microsoft-codelens-code.html&#34;&gt;Visual Studio - Microsoft CodeLens Code Health Indicator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kevintsengtw.blogspot.com/2015/02/visual-studio-code-metrics-viewer-2013.html&#34;&gt;Visual Studio 計算程式碼度量 - Code Metrics Viewer 2013&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/HW140701/article/details/85162678?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&#34;&gt;Visual Studio 增加每行最多字符数限制参考线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;各位整理快捷鍵的大大們，族繁不及備載&lt;/li&gt;
&lt;li&gt;感謝辦公室門口旁邊的不知名同事，讓我發現可以放 &lt;del&gt;妹子&lt;/del&gt; 圖片在 Visual Studio 裡&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>SikuliX —— 針對圖形介面寫自動化腳本的小幫手</title>
      <link>https://igouist.github.io/post/2020/03/sikulix/</link>
      <pubDate>Sun, 22 Mar 2020 13:11:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/03/sikulix/</guid>
      <description>&lt;p&gt;最近因緣際會下開始玩一些自動化測試的小工具，發現即使不是用在正規的測試時也相當實用，畢竟我們這行能讓電腦自動幫我們省事就是一種樂趣嘛。正巧這禮拜比較忙，無法準時推出訂便當系列的續集，因此決定直接紀錄一下試玩 Sikulix 的過程，以後有需要自動化的時候也方便回來參考。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sikulix 是一款針對圖形介面編寫腳本達到自動操作&lt;/strong&gt;的軟體，操作上相當方便。主要是將目標的圖示等畫面擷取下來，再編寫程式對目標進行操作。它編寫腳本時使用的語言是 &lt;a href=&#34;https://www.jython.org/&#34;&gt;Jython&lt;/a&gt; —— 用 Java 實現的 Python，關於 Jython 的基本操作可以參見 &lt;a href=&#34;https://iowiki.com/jython/jython_overview.html&#34;&gt;Wiki 教程：Jyhton&lt;/a&gt;，對於「實現 Python？」這句話感到疑惑的朋友可以參見 &lt;a href=&#34;https://zhuanlan.zhihu.com/p/58492338&#34;&gt;知乎：各種 Python 實現的簡單介绍與比較&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此外，本篇對於 Sikulix 的參考主要來自於&lt;a href=&#34;https://ypwalter.blogspot.com/2018/06/sikuli-sikulix.html?view=classic&#34;&gt;【測試】圖形化的自動測試 Sikuli / SikuliX 的相關技巧&lt;/a&gt;以及 &lt;a href=&#34;https://www.tpisoftware.com/tpu/articleDetails/876&#34;&gt;Sikulix 圖形辨識自動化測試開發工具&lt;/a&gt;兩篇，特此感謝。&lt;/p&gt;
&lt;h2 id=&#34;下載與安裝&#34;&gt;下載與安裝&lt;/h2&gt;
&lt;p&gt;首先必須先到 &lt;a href=&#34;http://sikulix.com/&#34;&gt;Sikulix.com&lt;/a&gt; 下載；進去後直接點選 Latest stable version 就會進到下載頁面，接著直接下載 IDE 來使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/d3LGYpJ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果沒有準備 Jython 環境，就需要再下載 &lt;a href=&#34;https://repo1.maven.org/maven2/org/python/jython-standalone/2.7.1/jython-standalone-2.7.1.jar&#34;&gt;Jython 獨立包&lt;/a&gt;。並放置在和 Sikulix 的 IDE 同個資料夾中。如果需要別的載入方式，可以參閱 &lt;a href=&#34;https://github.com/RaiMan/SikuliX1/wiki/How-to-make-Jython-ready-in-the-IDE&#34;&gt;How to make Jython ready in the IDE&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;準備完畢之後，直接打開 IDE 應該就能看到操作介面囉！&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/0ciX1Ur.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;實作一個小測試&#34;&gt;實作一個小測試&lt;/h2&gt;
&lt;p&gt;開啟 IDE 之後，可以看見左邊的程式區，右邊的輸出訊息，以及上面一排操作選單。我們先前提過 Sikulix 是一款以圖形操作的自動化工具，因此我們最常用到的會是上方的 螢幕截圖 和 插入圖片 這兩個能把圖放進去的功能。&lt;/p&gt;
&lt;p&gt;為了做基本的測試，這邊我打開 Windows 內建的小算盤，並且使用上方工具列的螢幕截圖功能。&lt;strong&gt;按下左上角的螢幕截圖後就可以圈選目標&lt;/strong&gt;，這邊我嘗試將計算機的按鈕框選起來。一框選起來之後它就會幫我們把圖放到左邊的程式區準備讓我們使用。（註：如果不想看見圖片的影像，而想要直接看圖的檔名，如圖片是使用插入圖片要以顯示檔案名稱為主的時候，可以從上面工具列的「檢視」中做切換。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/exsTGph.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接著讓我們先存檔一次（養成好習慣！不過即使尚未存檔，在執行腳本前也會要求存檔），會跳出存檔畫面，這邊示範就先隨便取個名字試試。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/tY2CcDr.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接著該路徑就可以看見 .sikuli 資料夾。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/vWYj0Ou.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看見裡面包含我們剛剛的圖片以及一個 py 檔，我們實際在 IDE 左側撰寫的腳本就是這個 py 檔。&lt;/p&gt;
&lt;p&gt;接著測試最簡單的 &lt;code&gt;click()&lt;/code&gt; 方法，我們嘗試讓他按下按鈕試試。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/s4TliuU.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;click()&lt;/code&gt; 將目標按鈕包起來之後按下執行，些微的停頓後就可以看見滑鼠直接滑向目標並按下去囉！整體的流程相當簡單，只需要目標的截圖和採用需要的方法就可以完成一個簡單的腳本。&lt;/p&gt;
&lt;p&gt;一些比較常用到的指令如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;click&lt;/code&gt;：點擊&lt;/li&gt;
&lt;li&gt;&lt;code&gt;doubleClick&lt;/code&gt;：點兩下&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rightClick&lt;/code&gt;：點右鍵&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dragDrop&lt;/code&gt;：拖曳&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hover&lt;/code&gt;：懸浮&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wait&lt;/code&gt;：等到指定圖樣出現&lt;/li&gt;
&lt;li&gt;&lt;code&gt;waitVanish&lt;/code&gt;：等到指定圖樣消失&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exist&lt;/code&gt;：指定圖樣是否存在&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt;：輸入文字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;paste&lt;/code&gt;：貼上文字&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，也能使用上方的工具列來圈選範圍，例如 &lt;code&gt;Show&lt;/code&gt; 就能顯示指令將抓取的位置，藉此校正腳本內容。大多把滑鼠移上去會有說明，這邊補充一下，感謝&lt;a href=&#34;https://qiita.com/mima_ita/items/8f653042ac9140e5023f&#34;&gt;這篇&lt;/a&gt;的示範：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Region&lt;/code&gt;：限制尋找範圍的區域&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Location&lt;/code&gt;：指定座標&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Offset&lt;/code&gt;：偏移量，平移找東西的時候好用，可參見&lt;a href=&#34;https://answers.launchpad.net/sikuli/+question/446476&#34;&gt;這篇&lt;/a&gt;的「Offset」&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Show&lt;/code&gt;：顯示該指令在螢幕上會找到的區域，可參見&lt;a href=&#34;http://wyj-learning.blogspot.com/2018/06/sikuli_30.html&#34;&gt;這篇&lt;/a&gt;的「Show &amp;amp; Show in 作用」&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ShowIn&lt;/code&gt;：有時候 Show 會抓到多個符合條件的區域而選了第一個，但那又不是我們要的目標時，用 ShowIn 就能指定該在螢幕上尋找目標的區域&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些指令的組合已經足夠完成大部分的日常工作了，但其實 Sikulix 的潛力仍然還有許多，參考資料將附於本段末。&lt;/p&gt;
&lt;p&gt;我之所以體會到其強大處，是在前陣子在幫同學安裝 Python 環境時，就遇到需要說明「如何加入環境變數」的場合。像這種時候，我們就可以做一個自動打開環境變數設定頁面的腳本。（備註：系統操作需要用系統管理員身分執行 Sikulix 才能執行）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/hpZ48n3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;之後就可以丟給強者我同學讓他跑一次省得說明鬼撞牆。平常都丟影片，偶偶丟腳本也挺有工程師的感覺，哈。&lt;/p&gt;
&lt;p&gt;關於可以使用的方法和更深的進階操作，請參閱 &lt;a href=&#34;https://blog.csdn.net/sinat_27980131/article/details/51684001&#34;&gt;sikuli入门到进阶&lt;/a&gt;、&lt;a href=&#34;http://wyj-learning.blogspot.com/2018/06/sikuli_30.html&#34;&gt;半工室：Sikuli 使用 - 重點教學&lt;/a&gt; 以及 &lt;a href=&#34;https://sikulix-2014.readthedocs.io/en/latest/toc.html&#34;&gt;SikuliX 官方文件&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;關於一些進一步會遇到的問題，例如怎麼傳值進來腳本，請參閱&lt;a href=&#34;https://ypwalter.blogspot.com/2018/06/sikuli-sikulix.html?view=classic&#34;&gt;【測試】圖形化的自動測試 Sikuli / SikuliX 的相關技巧&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;心得&#34;&gt;心得&lt;/h2&gt;
&lt;p&gt;之前在看自動化操作的時候，關於網頁這種能看見原始碼找到操作點的可以直接使用 &lt;a href=&#34;https://igouist.github.io/post/2020/03/bandon-1-selenium&#34;&gt;Selenium&lt;/a&gt;，而像 APP 也可以用工具抓到 Layout 去執行 Appium。然而像操作 Windows 或是一些應用程式等等就無法仰賴前兩者，這時候就是 Sikulix 出場的時候了。由於其是使用辨識圖像的方式進行的，因此只要有圖形化介面的東西都難不倒他，可以說相當實用，尤其是像我偶而會重灌的，就可以把每次會需要經歷的系統經歷錄成腳本，縮短每次環境佈署的時間，像是 &lt;a href=&#34;https://www.youtube.com/watch?v=FxDOlhysFcM&#34;&gt;2010 年 Sikuli 的示範影片&lt;/a&gt; 就是以設定 IP 為範例去操作呢。實際想一想，能用到的地方真的很多呢，例如&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/gr9DgeP.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;「你的遊戲怎麼自己在動？」&lt;/p&gt;
&lt;p&gt;「這、這是為了學術用途！」&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;順便一提，原本的操作範例我是打算跑一次台鐵訂票等整個流程的操作介面，但是驗證碼的時候就卡關了，既然有了上次實作 Selenium 時看到 &lt;a href=&#34;https://www.largitdata.com/course/37/&#34;&gt;驗證碼的相關文章&lt;/a&gt;，也許這種時候就是機器學習出場的時機吧！這樣想著，希望之後能有機會可以嘗試看看，屆時再將記錄放上來。&lt;/p&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tpisoftware.com/tpu/articleDetails/876&#34;&gt;Sikulix圖形辨識自動化測試開發工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ypwalter.blogspot.com/2018/06/sikuli-sikulix.html?view=classic&#34;&gt;【測試】圖形化的自動測試 Sikuli / SikuliX 的相關技巧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://wyj-learning.blogspot.com/2018/06/sikuli_30.html&#34;&gt;半工室：Sikuli 使用 - 重點教學&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/sinat_27980131/article/details/51684001&#34;&gt;sikuli入门到进阶&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://sportingmobile.blogspot.com/2016/06/sikuli.html&#34;&gt;相見恨晚的自動化測試開發工具 Sikuli&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://answers.launchpad.net/sikuli/+question/446476&#34;&gt;Sikulix1.1.4を使って画面の自動操作をする&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>我要訂便當 (2): 用 Python &#43; Sqlite 儲存訂單</title>
      <link>https://igouist.github.io/post/2020/03/bandon-2-sqlite/</link>
      <pubDate>Sun, 15 Mar 2020 20:49:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/03/bandon-2-sqlite/</guid>
      <description>&lt;p&gt;前情回顧：上一集在 &lt;a href=&#34;https://igouist.github.io/post/2020/03/bandon-1-selenium/&#34;&gt;我要訂便當(1) —— 用 Python + Selenium 控制瀏覽器取得訂單&lt;/a&gt; 中，我們藉由自動化套件 Selenium 控制 Chrome 成功從訂便當網站裡取得訂單資訊了。但只能夠取得現在的訂單，和原本有新訂單的時候才通知的目標仍然有點差距，那麼，如何判斷有沒有新訂單呢？只要和上一次讀取時的訂單相比就能知道了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目標：將訂單儲存起來，判斷有沒有新訂單。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這一篇主要的做法主要參考自 &lt;a href=&#34;https://www.youtube.com/watch?v=pI3FDACJFAs&#34;&gt;大數軟體 - 如何透過 Line 發送最新一集的漫畫&lt;/a&gt; 中，關於如何判斷是否有最新一集漫畫的部分。這系列的影片步驟明瞭，說明直接，同時標題也很對我胃口（我就喜歡把工具拿來生活周遭玩的感覺），因此這邊也推薦一下，有興趣的可以去看看。&lt;/p&gt;
&lt;p&gt;回歸正題，這篇的第一部分就是要使用 Sqlite 將抓到的訂單儲存起來。Sqlite 顧名思義就是 SQL + Lite 的感覺，主打小巧輕便。它會將資料儲存在一個檔案中，並且支援精簡的 SQL 指令，可以說是相當方便。&lt;/p&gt;
&lt;p&gt;在 Python 要對 Sqlite 做操作主要是藉由 sqlite3 這個包，因此在接下來的步驟前，請先安裝這個包。關於 Sqlite3 的基本操作，可以參閱 &lt;a href=&#34;https://www.runoob.com/sqlite/sqlite-python.html&#34;&gt;菜鳥教程的 SQLite - Python&lt;/a&gt; 教學。&lt;/p&gt;
&lt;p&gt;基本上和一般資料庫的操作邏輯並無太多差異，主要也是以 &lt;code&gt;sqlite3.connect&lt;/code&gt; 先連線到資料庫中，再使用如 &lt;code&gt;connection.execute&lt;/code&gt; 等的執行語法來進行操作。同時連線之後也可以使用其他資料框架提供的儲存和讀取等方法來處理，上方的菜鳥教程已有完整的教學流程，因此這邊就不多做說明，以下將會直接寫出操作資料庫動作的函式。&lt;/p&gt;
&lt;h2 id=&#34;儲存與讀取訂單&#34;&gt;儲存與讀取訂單&lt;/h2&gt;
&lt;p&gt;由於我們的情境相對簡單，只需要儲存和讀取。因此我們直接建立這兩個方法來操作。且因為我們在上一集讀回來的資料已經轉成 DataFrame，因此可以直接調用相關的方法進行操作。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Python&#34; data-lang=&#34;Python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;saveToDb&lt;/span&gt;(data, dbname, tablename):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&amp;#39; 將資料表存放到 sqlLite 資料庫 &amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; lite&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;connect(dbname) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; db:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        data&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;to_sql(tablename, con &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; db, if_exists &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;replace&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;readFromDb&lt;/span&gt;(dbname, tablename):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&amp;#39; 從資料庫取出上次資料表 &amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; lite&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;connect(dbname) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; db:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; pandas&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;read_sql_query(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;SELECT * FROM &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{tablename}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;format(tablename &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tablename), db)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;delDataInDb&lt;/span&gt;(dbname, tablename):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&amp;#39; 將指定資料表的資料刪除 &amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; lite&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;connect(dbname) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; db:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cursor &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; db&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;cursor()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cursor&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;execute(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;SELECT * FROM &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{tablename}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;format(tablename&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;tablename))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        db&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;commit()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cursor&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;close()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外也要考慮到可能是第一次連接到資料庫，若是指定的資料表不存在可能會報錯，因此加上一個檢查有沒有資料表的方法。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Python&#34; data-lang=&#34;Python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;IsDbTableExist&lt;/span&gt;(dbname, tablename):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&amp;#39; 確認是否有資料表 &amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; lite&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;connect(dbname) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; db:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; db&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;cursor()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        c&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;execute(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;SELECT count(*) FROM sqlite_master WHERE type=&amp;#39;table&amp;#39; AND name=&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{tablename}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;format(tablename &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tablename))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; c&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;fetchone()[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; : 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這些小零件完成之後，就可以把它們加到主要的流程裡。最簡單的順序應該是這樣的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 取得網路訂單資訊
- 和資料庫的訂單資訊比對
    - 如果有差異，且訂單變多代表有新訂單！ → 後續的通知等動作
    - 如果沒有差異，或是訂單變少了，代表沒有新訂單。 → 按兵不動
- 將新的資料存回資料庫
- 結束
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照這個流程加入之前的主程式後，就會變得如下（全程式將附於文末）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Python&#34; data-lang=&#34;Python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    url &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://dinbendon.net/do/login&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dbname &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;order.sqlite&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    tablename &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;bandon&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    order &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; fetch_bandon(url)  &lt;span style=&#34;color:#75715e&#34;&gt;# 連線到便當網取得訂單資訊&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; order &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; len(order) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;目前沒有進行中的訂單&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 如果資料庫沒資料表（＝第一次執行）先存一次建個環境&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; IsDbTableExist(dbname, tablename) &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;資料庫無過往訂單，即將儲存目前訂單並退出&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        saveToDb(order, dbname, tablename)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        print_order(order)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    oldOrder &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; readFromDb(dbname, tablename)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    orderList &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list(order[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;目標&amp;#39;&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    oldOrderList &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list(oldOrder[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;目標&amp;#39;&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;#print_order(order)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    delDataInDb(dbname, tablename)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    saveToDb(order, dbname, tablename)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 如果上次訂單是空的&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; oldOrder &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; len(oldOrder) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;資料庫無過往訂單，即將儲存目前訂單並退出&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; orderList &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; oldOrderList &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; len(orderList) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len(oldOrderList):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;訂單無變動，程式即將退出&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;偵測到訂單變動！&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 做點通知的事&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;尚未實作任何通知，程式即將終止…&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print_order(order)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;完成之後，接著進行測試，首先用顧客帳號登入便當網，確認一下目前的訂單內容&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/R1KEk0P.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接著先執行過一次&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/NvyBzsF.png&#34; alt=&#34;&#34;&gt;
&lt;img src=&#34;https://i.imgur.com/d9CS1eH.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看見有確實抓到訂單部分，並且在 py 檔所在的位置也多出了一個 sqlite 檔案存放我們的資料。&lt;/p&gt;
&lt;p&gt;那麼接著直接再執行一次，確認是不是會確認資料一致&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/phs8YTv.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接著登入便當網，自己發起一個團購試試&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/VIvjywx.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接著我們再執行試試能不能告訴我們有差異&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/GpQkhyv.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看見確實有抓到差異了！&lt;/p&gt;
&lt;p&gt;接著要實作任何通知都相當簡單了，只要將和之前不一樣的部分取出就可以取得新增的訂單，或是可以記錄每個訂單的開始和結束時間做管理，可以說能做的事相當多。&lt;/p&gt;
&lt;p&gt;屆此已經完成了預定將訂單做儲存和偵測有沒有變動的部分，故這篇就先到這裡打住。原本考慮到這部分相較之下篇幅比較短，是不是該跟下一段落合併成一篇，但考量之後還是作罷。&lt;/p&gt;
&lt;p&gt;畢竟大多時候也是做給自己往後參考用的，希望能把過程和看過的資料記錄下來，將來需要的時候可以自己抄自己，因此還是決定將不同套件的部份作切割，也是在這時候確定了這系列將會有四篇。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/04/bandon-3-line-notify/&#34;&gt;下一篇&lt;/a&gt; 將處理通知的部分，用到的技巧也在上面稍微提到過囉！那麼就下週再見～&lt;/p&gt;
&lt;h2 id=&#34;補充怎麼看-sqlite-裡的資料&#34;&gt;補充：怎麼看 Sqlite 裡的資料？&lt;/h2&gt;
&lt;p&gt;紀錄一下看 Sqlite 檔案裡資料的方法。&lt;/p&gt;
&lt;p&gt;由於 Sqlite 主打輕便可攜，因此平常的需求大多也是看資料而已。使用 &lt;a href=&#34;https://sqlitebrowser.org/&#34;&gt;DB Browser for SQLite&lt;/a&gt; 就足夠了&lt;/p&gt;
&lt;p&gt;不過我個人是比較偏好直接從 VS Code 裡就打開看，這時候就需要安裝擴充套件。&lt;/p&gt;
&lt;p&gt;我是採用 &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=alexcvzz.vscode-sqlite&#34;&gt;Sqlite 這個套件&lt;/a&gt;，該頁面就已經有操作示範了，使用相當簡單。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/qjHRK9z.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;只要先用 Ctrl + Shift + P 叫出命令提示區，輸入 Sqlite 之後，開啟資料庫就可以用簡單的操作來看內容或執行 SQL 指令，這邊強烈推薦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Ces9nxj.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;我要訂便當系列&#34;&gt;我要訂便當系列&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/03/bandon-1-selenium/&#34;&gt;我要訂便當(1) —— 用 Python + Selenium 控制瀏覽器取得訂單&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/03/bandon-2-sqlite/&#34;&gt;我要訂便當(2) —— 用 Python + Sqlite 儲存訂單&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/04/bandon-3-line-notify/&#34;&gt;我要訂便當(3) —— 用 Python + Line Notify 傳送通知&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/05/bandon-4-heroku/&#34;&gt;我要訂便當(4) —— 將 Python 腳本部署上 Heroku&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/05/bandon-5-heroku-debug/&#34;&gt;我要訂便當(5) —— Heroku 填坑小記&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=pI3FDACJFAs&#34;&gt;大數軟體 - 如何透過 Line 發送最新一集的漫畫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.runoob.com/sqlite/sqlite-python.html&#34;&gt;菜鳥教程 - SQLite Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.aaronlife.com/v1/teaching/android_sqlite.html&#34;&gt;SQLite 資料庫介紹 - Aaron Ho&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10204523&#34;&gt;DAY22 - 搞懂如何導入sqlite - iT邦幫忙&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://yhhuang1966.blogspot.com/2018/04/python-sqlite_28.html&#34;&gt;Python 學習筆記 : 資料庫存取測試 (一) SQLite - 小狐狸事務所&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;附錄目前程式碼&#34;&gt;附錄：目前程式碼&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Python&#34; data-lang=&#34;Python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; selenium &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; webdriver
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; re
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; time
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; pandas
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; sqlite3 &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; lite
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 自動檢查團購便當網&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    url &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://dinbendon.net/do/login&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dbname &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;order.sqlite&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    tablename &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;bandon&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    order &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; fetch_bandon(url)  &lt;span style=&#34;color:#75715e&#34;&gt;# 連線到便當網取得訂單資訊&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; order &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; len(order) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;目前沒有進行中的訂單&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 如果資料庫沒資料表（＝第一次執行）先存一次建個環境&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; IsDbTableExist(dbname, tablename) &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;資料庫無過往訂單，即將儲存目前訂單並退出&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        saveToDb(order, dbname, tablename)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        print_order(order)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    oldOrder &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; readFromDb(dbname, tablename)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    orderList &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list(order[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;目標&amp;#39;&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    oldOrderList &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list(oldOrder[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;目標&amp;#39;&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;#print_order(order)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    delDataInDb(dbname, tablename)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    saveToDb(order, dbname, tablename)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 如果上次訂單是空的&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; oldOrder &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; len(oldOrder) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;資料庫無過往訂單，即將儲存目前訂單並退出&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; orderList &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; oldOrderList &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; len(orderList) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len(oldOrderList):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;訂單無變動，程式即將退出&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;偵測到訂單變動！&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 做點通知的事&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;尚未實作任何通知，程式即將終止…&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print_order(order)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fetch_bandon&lt;/span&gt;(url, username&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;guest&amp;#34;&lt;/span&gt;, password&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;guest&amp;#34;&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&amp;#39; 開啟瀏覽器並連線到便當網取得資料 &amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    options &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; webdriver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ChromeOptions()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;#options.add_argument(&amp;#39;headless&amp;#39;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    driver &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; webdriver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Chrome(options&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;options)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(url)  &lt;span style=&#34;color:#75715e&#34;&gt;# 連線到訂便當頁面&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    time&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sleep(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;# 演一下&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 輸入帳密&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find_element_by_name(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;username&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;send_keys(username)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find_element_by_name(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;send_keys(password)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 輸入驗證碼&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ques &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find_elements_by_class_name(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;alignRight&amp;#34;&lt;/span&gt;)[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;text
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; re&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;findall(&lt;span style=&#34;color:#e6db74&#34;&gt;r&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\d+\.?\d*&amp;#34;&lt;/span&gt;, ques)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    answer &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(temp[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; int(temp[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find_element_by_name(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;result&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;send_keys(answer)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 提交表單&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find_element_by_name(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;submit&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;click()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;#time.sleep(1)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 取出訂單表格列&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    rows &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find_elements_by_css_selector(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;div#inProgressBox&amp;gt;table&amp;gt;tbody&amp;gt;tr&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(rows) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;close()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; list()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    bandons &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [list(map(getText, row&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find_elements_by_css_selector(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;td&amp;gt;div&amp;gt;a&amp;gt;span&amp;#34;&lt;/span&gt;))) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; row &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; rows]  &lt;span style=&#34;color:#75715e&#34;&gt;# 取出每一列資料的文字&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;close()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    tableHeader &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;人數&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;發起人&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;目標&amp;#39;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    bandons_df &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pandas&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;DataFrame(bandons, columns&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;tableHeader)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; bandons_df
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;print_order&lt;/span&gt;(data):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&amp;#39;列印訂單資料，看起來整齊一點&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; index, row &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;iterrows():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; row &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{hcount:&amp;gt;4s}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;) &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{orderer}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{order:&amp;lt;40s}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;format(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                orderer &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; str(row[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;發起人&amp;#39;&lt;/span&gt;]),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                order &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; str(row[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;目標&amp;#39;&lt;/span&gt;]),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                hcount &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; str(row[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;人數&amp;#39;&lt;/span&gt;])))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getText&lt;/span&gt;(x):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;text
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;saveToDb&lt;/span&gt;(data, dbname, tablename):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&amp;#39; 將資料表存放到 sqlLite 資料庫 &amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; lite&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;connect(dbname) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; db:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        data&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;to_sql(tablename, con&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;db, if_exists&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;replace&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;readFromDb&lt;/span&gt;(dbname, tablename):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&amp;#39; 從資料庫取出上次資料表 &amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; lite&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;connect(dbname) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; db:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; pandas&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;read_sql_query(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;SELECT * FROM &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{tablename}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;format(tablename&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;tablename), db)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;delDataInDb&lt;/span&gt;(dbname, tablename):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&amp;#39; 將指定資料表的資料刪除 &amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; lite&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;connect(dbname) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; db:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cursor &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; db&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;cursor()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cursor&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;execute(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;SELECT * FROM &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{tablename}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;format(tablename&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;tablename))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        db&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;commit()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cursor&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;close()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;IsDbTableExist&lt;/span&gt;(dbname, tablename):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&amp;#39; 確認是否有資料表 &amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; lite&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;connect(dbname) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; db:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; db&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;cursor()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        c&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;execute(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;SELECT count(*) FROM sqlite_master WHERE type=&amp;#39;table&amp;#39; AND name=&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{tablename}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;format(tablename&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;tablename))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; c&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;fetchone()[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; __name__ &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    main()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>我要訂便當 (1): 用 Python &#43; Selenium 控制瀏覽器取得訂單</title>
      <link>https://igouist.github.io/post/2020/03/bandon-1-selenium/</link>
      <pubDate>Sun, 08 Mar 2020 18:47:23 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/03/bandon-1-selenium/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;2024.10 更新: Line Notify 將於 2025 年 3 月停止服務（&lt;a href=&#34;https://notify-bot.line.me/closing-announce&#34;&gt;LINE Notify 結束服務公告&lt;/a&gt;），有看到這篇的朋朋請選擇一組新的通知服務來串吧 QQ&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;p&gt;這是參加&lt;a href=&#34;https://www.hexschool.com/2019/11/14/2019-11-14-w3Hexschool-2020-challenge/&#34;&gt;六角鼠年全馬&lt;/a&gt;的第一篇，主要是希望能夠養成寫部落格的習慣。由於我本身並沒有主要技能，因此這次參賽文章會以我最近玩的玩具、使用的套件或是遇到的問題做紀錄。&lt;/p&gt;
&lt;p&gt;希望能夠派上用場。&lt;/p&gt;
&lt;p&gt;目標：使用 &lt;strong&gt;Python&lt;/strong&gt; 及 &lt;strong&gt;Selenium&lt;/strong&gt; 連線到訂便當網站，自動輸入帳號密碼登入後，取回網站上的訂單資訊&lt;/p&gt;
&lt;p&gt;(2020/12/4) 更新: 由於訂便當網站改版，所以程式碼已經不能照抄了。但有興趣的朋友還是能自己摸索做點變動，也能夠照常進行喔，加油～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近在公司的時候有個莫大的煩惱，就是關於辦公室團購這回事兒。現在待著的公司主要是從 &lt;a href=&#34;https://dinbendon.net/&#34;&gt;Dinbendon&lt;/a&gt; 這套系統來揪團購，舉凡品客、火鍋等都在上面訂過，據我觀察最受歡迎出現最多次的當屬雞排了。煩惱就在於，每次都會錯過雞排的團購，光在辦公室聞著四面八方傳來的雞排香味，就令人無法忍受！因此趁著這個機會，來嘗試能不能像之前的 &lt;a href=&#34;https://igouist.github.io/post/2019/12/ptt-crawler-and-listener/&#34;&gt;PTT&lt;/a&gt; 一樣來弄出一個通知，順便玩玩最近看到的工具。這系列的文章會分成多個部分，主要是以使用的工具來分集。&lt;/p&gt;
&lt;p&gt;由於在從團購網取得訂單的過程中需要跟網頁進行互動，因此這次要使用的工具是 &lt;strong&gt;&lt;a href=&#34;https://www.selenium.dev/&#34;&gt;Selenium&lt;/a&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Selenium 是一個對網頁做自動化測試的工具&lt;/strong&gt;，但我個人比較常在爬蟲的時候用到XD。它能夠經由腳本或錄製的方式對瀏覽器進行操作，並且也支援相當多語言可以使用，例如我同事便使用 C# 和 Hangfire 來完成訂便當的目標（對，這麼無聊的人不只我一個），而我則用相對比較熟悉的 Python 來實作。&lt;/p&gt;
&lt;p&gt;關於本篇主要的操作和步驟，主要參考 &lt;a href=&#34;https://medium.com/@NorthBei/%E5%9C%A8windows%E4%B8%8A%E5%AE%89%E8%A3%9Dpython-selenium-%E7%B0%A1%E6%98%93%E6%95%99%E5%AD%B8-eade1cd2d12d&#34;&gt;在 Windows 上安裝 Python &amp;amp; Selenium 簡易教學&lt;/a&gt; 這篇文章，在此感謝；而各語言的語法等等，可以翻閱 &lt;a href=&#34;https://selenium-python-zh.readthedocs.io/en/latest/index.html&#34;&gt;教學文檔&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;準備工作&#34;&gt;準備工作&lt;/h2&gt;
&lt;p&gt;開始寫腳本之前，確保 Python 已經安裝完畢，並且先下載好 &lt;a href=&#34;https://pypi.org/project/selenium/&#34;&gt;Selenium 套件包&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另外 &lt;strong&gt;Selenium 是使用各個 Web Driver 來對瀏覽器做操作的&lt;/strong&gt;，因此這邊也需要先下載 Chrome 的 Driver 來使用。進入 &lt;a href=&#34;http://chromedriver.chromium.org/downloads&#34;&gt;ChromeDriver 的下載頁面&lt;/a&gt; ，通常挑選最新版的下載，如果 Chrome 版本有需求再選擇對應的版本即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/z0BGk4z.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(4/2) 補充：關於&lt;strong&gt;其他瀏覽器的 Driver&lt;/strong&gt;，可以參考 iT 邦幫忙的 &lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10229959/&#34;&gt;鼠年全馬鐵人挑戰 WEEK 06：Selenium 自動化測試工具&lt;/a&gt; 這篇，裡面有詳細的介紹以及各瀏覽器的 Driver 下載整理。&lt;/p&gt;
&lt;p&gt;此外除了用腳本控制 Driver 的用法以外，&lt;strong&gt;Selenium 也提供了 IDE&lt;/strong&gt; 可以直接使用，需要先安裝 Chrome 和 Firefox 的擴充套件，詳情可以參閱同系列的 &lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10230427&#34;&gt;鼠年全馬鐵人挑戰 WEEK 07：Selenium IDE&lt;/a&gt; 內有使用說明。&lt;/p&gt;
&lt;p&gt;發完之後才看到這個系列，對測試的種類和 Selenium 的操作說明得清楚多了，值得推薦，故在此補上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下載完解壓縮應該會有一個 chromedriver.exe 檔案，這個檔案的用法有兩種&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;放置於 Python.exe 所在的位置，即當初的安裝位置，如此所有的腳本都可以使用&lt;/li&gt;
&lt;li&gt;放置於現在專案的 py 檔同一個資料夾，就只有這個資料夾中的腳本可以使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;當然前者放一次就都可以用比較方便，不過這邊只打算迅速地讓這個腳本動起來，因此可以直接放置在等等要寫 Python 檔的資料夾就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/7m1RKc8.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;那麼準備工作完成之後，就可以開始來寫 Code 讓它動起來囉！&lt;/p&gt;
&lt;h2 id=&#34;取得訂單&#34;&gt;取得訂單&lt;/h2&gt;
&lt;p&gt;首先測試是否能夠順利連線上便當網，這邊先撰寫最簡單的連線。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; selenium &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; webdriver
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;url &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://dinbendon.net/do/login&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;driver &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; webdriver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Chrome()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(url)  &lt;span style=&#34;color:#75715e&#34;&gt;# 連線到訂便當頁面&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;執行之後應該就能看到 Chrome 自動開啟連線到指定的網頁，同時也可以注意到 Chrome 上有標明「正在受到自動測試軟體控制」&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/741auju.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接著想要看到訂單內容，還必須要輸入帳號密碼和驗證碼才行，這也就是前面提到的需要互動的部分。先使用 F12 的使用者工具觀察欄位的名稱，以利後續 Selenium 的抓取 &lt;del&gt;，爬蟲的基本就在於拆人家的房子&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/3SWOJtJ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;確認名稱之後就可以添加指令，讓 Selenium 幫我們輸入看看。這邊要注意我們加上了 &lt;code&gt;sleep()&lt;/code&gt; 來暫停一下，因為在 Selenium 的操作之間，建議要加上些許延遲，避免畫面動作都還沒完成，指令就一股腦丟完了囧。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;time&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sleep(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;# 演一下&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;username &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;password &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 輸入帳密&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find_element_by_name(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;username&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;send_keys(username)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find_element_by_name(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;send_keys(password)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到它會自動幫我們輸入內容，看著帳密自己跳出來實在是相當療癒&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/WvY9vco.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在這一步去抓取網頁上的元素時，可以看見我使用了 &lt;code&gt;driver.find_element_by_name&lt;/code&gt; 去按照網頁上 HTML 標籤的 name 去抓到目標的元件。這就是 &lt;strong&gt;Selenium 的定位器&lt;/strong&gt;，它提供了許多方法去取得目標元件，例如 Id、Name 等等。&lt;/p&gt;
&lt;p&gt;關於定位器的操作可以參閱 &lt;a href=&#34;https://matthung0807.blogspot.com/2017/12/selenium-html-element-locator.html&#34;&gt;Selenium HTML element locator 定位器&lt;/a&gt; 以及 &lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10194253&#34;&gt;Selenium webdriver 定位物件方法比較 xpath v.s. css selector&lt;/a&gt; 這兩篇。接下來的介紹會以使用為主。&lt;/p&gt;
&lt;p&gt;回到我們的便當網，這網頁的友善就在於它的驗證碼是顯示數字讓你計算，每次的變化只有中間的「+」可能會變成「加」和全形的「＋」。但這並不妨礙我們去把它的值剝取出來。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 輸入驗證碼&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ques &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find_elements_by_class_name(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;alignRight&amp;#34;&lt;/span&gt;)[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;text &lt;span style=&#34;color:#75715e&#34;&gt;# 有點強硬地拿到整串問題&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; re&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;findall(&lt;span style=&#34;color:#e6db74&#34;&gt;r&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\d+\.?\d*&amp;#34;&lt;/span&gt;, ques) &lt;span style=&#34;color:#75715e&#34;&gt;# 用正規表達式把數字取出&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(temp[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(temp[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find_element_by_name(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;result&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;send_keys(c)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看見它自動幫我們輸入了計算結果&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/J4IXXCx.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;題外話：如果遇到麻煩點的驗證碼怎麼辦？&lt;/p&gt;
&lt;p&gt;可以先用&lt;a href=&#34;https://www.youtube.com/watch?v=hF-dJj559ug&#34;&gt;大數軟體 - 如何使用 Selenium 抓取驗證碼?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再試試看&lt;a href=&#34;https://www.largitdata.com/course/37/&#34;&gt;大數學堂 - 如何透過 OpenCV 破解台灣證券交易所買賣日報表的驗證碼(Captcha)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;也許能有效，先記錄下來。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接著就可以測試是否能夠登入了，將帳號密碼設定為測試用的訪客帳號 guest，並在指令最後添加按下按鈕的動作&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 提交表單&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find_element_by_name(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;submit&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;click() 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;到這一步已經順利登入，並且可以看到訂單列表了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/PQyd9FW.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;整理及包裝&#34;&gt;整理及包裝&lt;/h2&gt;
&lt;p&gt;接著流程一如前部分，觀察網頁結構並且將目標取出。&lt;/p&gt;
&lt;p&gt;這邊先將左半部分的 Table 拿出來，接著針對表格的每一列取出該元素之後取文字。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 取出訂單表格列&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rows &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find_elements_by_css_selector(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;div#inProgressBox&amp;gt;table&amp;gt;tbody&amp;gt;tr&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(rows) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;close()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; list()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 取出每一列資料的文字&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;bandons &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [list(map(getText, row&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find_elements_by_css_selector(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;td&amp;gt;div&amp;gt;a&amp;gt;span&amp;#34;&lt;/span&gt;))) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; row &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; rows]  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;close()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 做成一張表&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;tableHeader &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;人數&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;發起人&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;目標&amp;#39;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;bandons_df &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pandas&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;DataFrame(bandons, columns&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;tableHeader)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;目前為止整體程式碼如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; selenium &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; webdriver
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; re
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; time
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; pandas
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 自動檢查團購便當網&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    url &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://dinbendon.net/do/login&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    order &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; fetch_bandon(url)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print_order(order)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fetch_bandon&lt;/span&gt;(url, username&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;guest&amp;#34;&lt;/span&gt;, password&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;guest&amp;#34;&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&amp;#39; 開啟瀏覽器並連線到便當網取得資料 &amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    driver &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; webdriver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Chrome()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(url)  &lt;span style=&#34;color:#75715e&#34;&gt;# 連線到訂便當頁面&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    time&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sleep(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;# 演一下&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 輸入帳密&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find_element_by_name(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;username&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;send_keys(username)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find_element_by_name(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;send_keys(password)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 輸入驗證碼&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ques &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find_elements_by_class_name(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;alignRight&amp;#34;&lt;/span&gt;)[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;text
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; re&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;findall(&lt;span style=&#34;color:#e6db74&#34;&gt;r&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\d+\.?\d*&amp;#34;&lt;/span&gt;, ques)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    answer &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(temp[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; int(temp[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find_element_by_name(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;result&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;send_keys(answer)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 提交表單&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find_element_by_name(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;submit&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;click()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    time&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sleep(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 取出訂單表格列&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    rows &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find_elements_by_css_selector(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;div#inProgressBox&amp;gt;table&amp;gt;tbody&amp;gt;tr&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(rows) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;close()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; list()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 取出每一列資料的文字&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    bandons &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [list(map(getText, row&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;find_elements_by_css_selector(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;td&amp;gt;div&amp;gt;a&amp;gt;span&amp;#34;&lt;/span&gt;))) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; row &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; rows]  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    driver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;close()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 做成一張表&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    tableHeader &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;人數&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;發起人&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;目標&amp;#39;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    bandons_df &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pandas&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;DataFrame(bandons, columns&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;tableHeader)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; bandons_df
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;print_order&lt;/span&gt;(data):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&amp;#39;列印訂單資料，看起來整齊一點&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; index, row &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;iterrows():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; row &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{hcount:&amp;gt;4s}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;) &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{orderer}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{order:&amp;lt;40s}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;format(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                orderer &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; str(row[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;發起人&amp;#39;&lt;/span&gt;]),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                order &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; str(row[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;目標&amp;#39;&lt;/span&gt;]),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                hcount &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; str(row[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;人數&amp;#39;&lt;/span&gt;])))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getText&lt;/span&gt;(x):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;text
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; __name__ &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    main()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;抓回來的樣子如下
&lt;img src=&#34;https://i.imgur.com/jp1lQlr.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;另外每次執行的時候都還會有瀏覽器跳出來操作，但我們在這邊已經確認可以成功取回資料了，因此瀏覽器的顯示也不是那麼必要。&lt;/p&gt;
&lt;p&gt;這邊就可以考慮加上無頭模式讓瀏覽器不要顯示，而是在背景執行。只需要在一開始宣告瀏覽器的部分加上選項，就可以不要跳視窗囉。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;options &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; webdriver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ChromeOptions()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;options&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add_argument(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;headless&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;driver &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; webdriver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Chrome(options&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;options)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;到此為止我們已經成功控制瀏覽器幫我們打開網頁，填帳號密碼登入，也取得了想要的訂單列表內容，完成了訂便當野心的第一步！&lt;/p&gt;
&lt;p&gt;然而，接著還有相當多的部分必須處理。如何判斷有沒有新訂單？又要怎麼通知我有新訂單呢？&lt;/p&gt;
&lt;p&gt;欲知後續如何，且待 &lt;a href=&#34;https://igouist.github.io/post/2020/03/bandon-2-sqlite/&#34;&gt;下回&lt;/a&gt; 分曉！&lt;/p&gt;
&lt;h2 id=&#34;我要訂便當系列&#34;&gt;我要訂便當系列&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/03/bandon-1-selenium/&#34;&gt;我要訂便當(1) —— 用 Python + Selenium 控制瀏覽器取得訂單&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/03/bandon-2-sqlite/&#34;&gt;我要訂便當(2) —— 用 Python + Sqlite 儲存訂單&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/04/bandon-3-line-notify/&#34;&gt;我要訂便當(3) —— 用 Python + Line Notify 傳送通知&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/05/bandon-4-heroku/&#34;&gt;我要訂便當(4) —— 將 Python 腳本部署上 Heroku&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/05/bandon-5-heroku-debug/&#34;&gt;我要訂便當(5) —— Heroku 填坑小記&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@NorthBei/%E5%9C%A8windows%E4%B8%8A%E5%AE%89%E8%A3%9Dpython-selenium-%E7%B0%A1%E6%98%93%E6%95%99%E5%AD%B8-eade1cd2d12d&#34;&gt;在Windows上安裝Python &amp;amp; Selenium + 簡易教學&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://selenium-python-zh.readthedocs.io/en/latest/index.html&#34;&gt;Selenium with Python中文翻译文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@bob800530/selenium-1-%E9%96%8B%E5%95%9Fchrome%E7%80%8F%E8%A6%BD%E5%99%A8-21448980dff9&#34;&gt;運用 Selenium 開啟 Chrome 瀏覽器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10229959/&#34;&gt;鼠年全馬鐵人挑戰 WEEK 06：Selenium 自動化測試工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10230427&#34;&gt;鼠年全馬鐵人挑戰 WEEK 07：Selenium IDE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://matthung0807.blogspot.com/2017/12/selenium-html-element-locator.html&#34;&gt;Selenium HTML element locator 定位器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10194253&#34;&gt;Selenium webdriver 定位物件方法比較 xpath v.s. css selector&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=grZi9j4HKvc&#34;&gt;大數軟體 - 如何使用 Selenium 自動下載漫畫?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=hF-dJj559ug&#34;&gt;大數軟體 - 如何使用 Selenium 抓取驗證碼?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.largitdata.com/course/37/&#34;&gt;大數學堂 - 如何透過 OpenCV 破解台灣證券交易所買賣日報表的驗證碼(Captcha)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>