<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>NewbieGuide on 伊果的沒人看筆記本</title>
    <link>https://igouist.github.io/tags/newbieguide/</link>
    <description>Recent content in NewbieGuide on 伊果的沒人看筆記本</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hant-TW</language>
    <lastBuildDate>Sun, 13 Mar 2022 20:03:00 +0800</lastBuildDate><atom:link href="https://igouist.github.io/tags/newbieguide/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>菜雞新訓記 (7): 使用 Fluent Validation 來驗證參數吧</title>
      <link>https://igouist.github.io/post/2022/03/newbie-7-fluent-validation/</link>
      <pubDate>Sun, 13 Mar 2022 20:03:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2022/03/newbie-7-fluent-validation/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/p6aSDH9.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;這是俺整理公司新訓內容的第七篇文章，目標是紀錄 Fluent Validation 這個好用套件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FluentValidation 可以幫我們將 Api 傳入的參數的檢查用更口語、更乾淨的方式去處理&lt;/strong&gt;，除了可以將檢查邏輯拆分成單獨的 Validator 類別，更提供了許多內建的檢查規則和自訂的彈性，相當方便。&lt;/p&gt;
&lt;p&gt;並且因為將參數的檢查邏輯整理出去，就可以和 Controller 本身的工作做簡單的拆分，達到關注點分離的目標。&lt;/p&gt;
&lt;p&gt;現在就讓我們來認識一下這個好用工具吧！首先要從很久很久以前開始說起…&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;西元前的某一天，憂心的皇帝在朝堂內繞著柱子走，突然大臣奪門而入。&lt;/p&gt;
&lt;p&gt;大臣：「陛下！敵軍已經攻到國境內啦！」&lt;/p&gt;
&lt;p&gt;皇帝大驚：『邊境的那些檢查站和關口難道都陷落了嗎？不可能！』&lt;/p&gt;
&lt;p&gt;大臣：「陛下，有內奸和敵國勾結，檢查站完全沒檢查！髒資料已經闖進來了！」&lt;/p&gt;
&lt;p&gt;皇帝喊了一聲：『怎麼可能！讓朕看看！』就打開 Controller 和前一個版本的 Git Log，這一看差點就昏了過去。&lt;/p&gt;
&lt;p&gt;原來 Controller 的舊程式碼就已經很亂了，檢查參數的條件 if/else 和其他呼叫的方法、組裝資料都雜在一起。結果這次專案改動時，某一行就被內奸改壞了，關鍵的參數竟然沒檢查到！&lt;/p&gt;
&lt;p&gt;『可，可惡！來人啊，把工程師推出午門斬首！』&lt;/p&gt;
&lt;p&gt;「皇上！他已經離職啦！」&lt;/p&gt;
&lt;p&gt;皇帝跌坐在地，懊悔地說：『如果當初有好好把檢查參數跟實際組資料的部份都拆開的話，也許就不會這樣了…』&lt;/p&gt;
&lt;p&gt;「是啊，如果我們有用 Fluent Validation…！」&lt;/p&gt;
&lt;h2 id=&#34;專案現況&#34;&gt;專案現況&lt;/h2&gt;
&lt;p&gt;大臣提到的 &lt;a href=&#34;https://fluentvalidation.net/&#34;&gt;FluentValidation&lt;/a&gt; 是一套能幫我們把傳入參數的分離出去、用更口語化的方式去撰寫的工具。&lt;/p&gt;
&lt;p&gt;……如果當時他們有使用 Fluent Validation 來把驗證的邏輯和規則跟原本很亂的 Controller 切分的話，說不定就能及時發現問題吧，大概。&lt;/p&gt;
&lt;p&gt;為了不要步上他們的後塵，就讓我們直接回到本系列的卡牌管理 API 服務來加上這個好用工具吧！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞新訓記 (6): 使用 依賴注入 (Dependency Injection) 來解除強耦合吧</title>
      <link>https://igouist.github.io/post/2021/11/newbie-6-dependency-injection/</link>
      <pubDate>Sun, 28 Nov 2021 20:13:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2021/11/newbie-6-dependency-injection/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/2XYv7X2.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;這是俺整理公司新訓內容的第六篇文章，目標是&lt;strong&gt;紀錄什麼是依賴注入（Dependency Injection）&lt;/strong&gt;。包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/11/newbie-6-dependency-injection#%E7%82%BA%E4%BB%80%E9%BA%BC%E9%9C%80%E8%A6%81%E4%BE%9D%E8%B3%B4%E6%B3%A8%E5%85%A5&#34;&gt;為什麼要依賴注入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/11/newbie-6-dependency-injection#%E4%BE%9D%E8%B3%B4%E6%B3%A8%E5%85%A5%E7%9A%84%E7%A8%AE%E9%A1%9E&#34;&gt;依賴注入的種類（建構式注入、屬性注入、方法注入）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/11/newbie-6-dependency-injection#%E4%BE%9D%E8%B3%B4%E6%B3%A8%E5%85%A5%E7%9A%84%E4%B8%89%E7%A8%AE%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F-transientscopedsingleton&#34;&gt;.net Core 中依賴注入的生命週期&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;並用 &lt;a href=&#34;https://igouist.github.io/post/2021/11/newbie-6-dependency-injection#%E5%AF%A6%E4%BD%9C&#34;&gt;.net Core 實際跑一次依賴注入&lt;/a&gt;，&lt;strong&gt;藉由將控制權轉移給注入容器，解除分層與分層間、類別與類別間的依賴和耦合關係，達到以介面分離實作的目標&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;西元前的某一天，憂心的皇帝在朝堂內繞著柱子走，正巧被路過的廷尉看見。&lt;/p&gt;
&lt;p&gt;廷尉：「敢問陛下在煩惱什麼呢？」&lt;/p&gt;
&lt;p&gt;皇帝：『朕這是在想封賞的事兒哪。前朝之所以覆滅，根本的原因就在於大肆封賞臣下，四處分封土地給他們做諸侯。&lt;/p&gt;
&lt;p&gt;這些諸侯呢，肆意起用自己喜歡的人擔任要職、結黨營私，心情好就 &lt;code&gt;new 將軍(&amp;quot;我ㄉ朋友&amp;quot;);&lt;/code&gt;，&lt;br/&gt;十天就封了十個將軍。這些人若犯了錯，要處理他們還得看諸侯面子；而諸侯一聲令下，這些人便群起造反。&lt;/p&gt;
&lt;p&gt;並且，這些諸侯之間彼此喜歡直接往來，動不動就在自家裡下命令給 &lt;code&gt;隔壁諸侯.借糧草(100)&lt;/code&gt;，哪天就變成 &lt;code&gt;隔壁諸侯.揪團造反()&lt;/code&gt;。彼此之間偷來暗去，實在難以掌握。&lt;/p&gt;
&lt;p&gt;最後呢，一個逆賊起來造反，若要將他給辦了，附近諸侯就一起響應，每個都一齊報錯，Exception 成千上百，國家也就這樣滅了，想到這朕就頭痛得很，不知愛卿可有法子？』&lt;/p&gt;
&lt;p&gt;廷尉想了一想，便說：「陛下，此事要點還是在於諸侯之間&lt;strong&gt;相互依賴、彼此耦合&lt;/strong&gt;，致生禍端。&lt;/p&gt;
&lt;p&gt;臣有一計，先收回諸侯的人事任命權，使其不可私自 &lt;code&gt;new&lt;/code&gt; 自己人，所有人事異動，須&lt;strong&gt;由中央進行管理與派遣&lt;/strong&gt;。這樣即使諸侯要造反，也不知道下面這群打工仔是不是自己人。大家各司其職，諸侯做好自己的行政作業，打工仔派到崗位就做好自己的工作，彼此不直接依賴，這樣出事的機率就少了。&lt;/p&gt;
&lt;p&gt;其次，明令禁止諸侯私自往來，對諸侯們進行隔離，若是有公務上的需要，&lt;strong&gt;一律藉由中央提供的接口來溝通&lt;/strong&gt;，彼此之間明訂契約，由中央進行隔離與調派，諸侯間就只需要按照協議好的合約下去合作，這樣勾結的機會也就少了，耦合也就降低了。陛下覺得如何？」&lt;/p&gt;
&lt;p&gt;皇帝大喜：『如此甚好！治眾如治寡，在於分而治之。此計可有名字？』&lt;/p&gt;
&lt;p&gt;「此乃－－依賴注入之計！」&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞新訓記 (5): 使用 三層式架構 來切分服務的關注點和職責吧</title>
      <link>https://igouist.github.io/post/2021/10/newbie-5-3-layer-architecture/</link>
      <pubDate>Sun, 03 Oct 2021 14:00:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2021/10/newbie-5-3-layer-architecture/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/S72H7sA.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;這是俺整理公司新訓內容的第五篇文章，目標是&lt;strong&gt;使用三層式架構 (3-Layer Architecture) 來切分服務的關注點和職責&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;什麼是分層分層可以吃嗎&#34;&gt;什麼是分層？分層可以吃嗎？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;天地混沌如雞子，商業邏輯生其中。&lt;/p&gt;
&lt;p&gt;萬八千歲，天地開闢。表現層為天。資料層為地。商業邏輯層在其中……&lt;/p&gt;
&lt;p&gt;　　　　－－民明書坊《盤古與他的CRUD之旅》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根據民明書坊的文獻記載，我們常聽到的「天地玄黃，宇宙洪荒」云云，其實指的就是上古時期的開發狀況。當時世界還是一片混沌，所有的程式碼都混雜成一坨，不是所有東西寫在一起你儂我儂，一言不合就三千行；就是依賴關係交錯複雜，改了北極壞南極。&lt;/p&gt;
&lt;p&gt;要說有多亂呢，大概就算前人嘗試引入了 MVC，也只是改成把所有程式都塞在 Controller 而已，其絕望程度可見一斑。&lt;/p&gt;
&lt;p&gt;這時候隔壁課的老盤調過來接刀，一看不得了，便決定先對這屎山整頓一番。他大喝一聲，那些靠近使用者的便上浮起來化作了天，親近資料庫的便沉澱下去變成了地，而所有的商業邏輯就連接著兩者，支撐起了整個專案。這也就是分層架構的由來。&lt;/p&gt;
&lt;h3 id=&#34;三層式架構&#34;&gt;三層式架構&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;分層架構是運用最為廣泛的架構模式，幾乎每個軟體系統都需要通過層（Layer）來隔離不同的關注點（Concern Point），以此應對不同需求的變化，使得這種變化可以獨立進行；此外，分層架構模式還是隔離業務複雜度與技術複雜度的利器。 －－ &lt;a href=&#34;https://raychiutw.github.io/2019/%E9%9A%A8%E6%89%8B-Design-Pattern-2-%E8%BB%9F%E9%AB%94%E5%88%86%E5%B1%A4%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F-Software-Layered-Architecture-Pattern/&#34;&gt;Ray&amp;rsquo;s Notes&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般來說，最常見的分層架構就是&lt;strong&gt;三層式架構&lt;/strong&gt;了。&lt;/p&gt;
&lt;p&gt;三層式架構顧名思義就是把應用程式分成三層，通常會分成「&lt;strong&gt;展示層、商業邏輯層、資料存取層&lt;/strong&gt;」。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/RxSrWJm.jpg&#34; alt=&#34;分層架構01&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞新訓記 (4): 使用 Swagger 來自動產生可互動的 API 文件吧</title>
      <link>https://igouist.github.io/post/2021/05/newbie-4-swagger/</link>
      <pubDate>Sun, 16 May 2021 22:42:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2021/05/newbie-4-swagger/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/lzjNys4.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;這是俺整理公司新訓內容的第四篇文章，目標是&lt;strong&gt;簡單地使用 Swagger 工具來自動產生可互動的 API 文件&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;api-文件與-swagger&#34;&gt;API 文件與 Swagger&lt;/h2&gt;
&lt;p&gt;在 &lt;a href=&#34;https://igouist.github.io/post/2021/05/newbie-3-dapper&#34;&gt;上一篇&lt;/a&gt; 我們建立了一個有簡單的 CRUD 的 Web API 服務，這篇我們就接續著 API 服務往下看吧！&lt;/p&gt;
&lt;p&gt;之前我們介紹 API 的時候有提過：API 是為了讓兩個服務之間可以溝通、互動所產生的接口。而所有的溝通要有效，都一定要先有共識，隨著溝通的人數越來越多，或是內容的理解要越來越細，就會用文件或契約的方式來達成共識。&lt;/p&gt;
&lt;p&gt;回到我們的 API 服務開發來說，就是你除了把服務生出來了，可以跑了以外，還有一個重要的點是：&lt;strong&gt;必須讓所有的使用者（包含幾個月後的你自己）知道怎麼使用這組 API 服務&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;也就來說，就是要寫 &lt;strong&gt;API 規格文件&lt;/strong&gt; 啦！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞新訓記 (3): 使用 Dapper 來連線到資料庫 CRUD 吧</title>
      <link>https://igouist.github.io/post/2021/05/newbie-3-dapper/</link>
      <pubDate>Sun, 09 May 2021 11:15:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2021/05/newbie-3-dapper/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/aIHQL5Z.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;這是俺整理公司新訓內容的第三篇文章，目標是&lt;strong&gt;在 .NET Core 簡單地使用 Dapper 連線到資料庫並完成 CRUD 的功能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;接續 &lt;a href=&#34;https://igouist.github.io/post/2021/05/newbie-2-webapi&#34;&gt;上一篇&lt;/a&gt; 的進度，我們接著要來連線到資料庫中完成我們的 Web Api 的 CRUD 範例。因為從新訓時期到現在工作團隊作業上主要都是使用 Dapper 來做連線資料庫的工作，這邊就直接用 Dapper 來推進吧！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dapper 有多好用呢？它輕量、它簡單、它快速&lt;/strong&gt;。總之先把大神們的介紹文直接拿來鎮樓：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.darkthread.net/blog/dapper/&#34;&gt;短小精悍的.NET ORM神器 &amp;ndash; Dapper - 黑暗執行緒&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/mrkt/2016/06/10/153606&#34;&gt;另一種資料存取對映處理方式的選擇 - Dapper - mrkt 的程式學習筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.huanlintalk.com/2014/03/a-micro-orm-dapper.html&#34;&gt;好用的微型 ORM：Dapper - Huanlin 學習筆記&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那麼按照慣例，我們先來 &lt;del&gt;吹捧今天的主角&lt;/del&gt; 說明一點簡單的前因後果吧。想直接實作的朋友，可以跳到&lt;a href=&#34;#%E6%AD%A3%E5%BC%8F%E9%96%8B%E5%B7%A5&#34;&gt;正式開工&lt;/a&gt;的小節呦。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞新訓記 (2): 認識 Api &amp; 使用 .net Core 來建立簡單的 Web Api 服務吧</title>
      <link>https://igouist.github.io/post/2021/05/newbie-2-webapi/</link>
      <pubDate>Sun, 02 May 2021 12:39:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2021/05/newbie-2-webapi/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/d2xM94x.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;這是俺整理公司新訓內容的第二篇文章，目標是&lt;strong&gt;對 Api, Restful Api, HTTP 等相關的知識點做個筆記，並用 .net Core 建立一個簡易的 Web Api 專案&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;前言基本觀念&#34;&gt;前言、基本觀念&lt;/h2&gt;
&lt;p&gt;我們在 &lt;a href=&#34;https://igouist.github.io/post/2021/04/newbie-1-hello-git&#34;&gt;上一篇&lt;/a&gt; 記錄了新訓第一天的 Git 操作筆記。接著在這篇，我們終於要進入 .net Core 啦！&lt;/p&gt;
&lt;p&gt;目前的規劃是先從建立一個可以使用的、最簡單版本的 Web Api 服務開始，再將各個工具擴增進來。所以後續的文章應該都會以這篇的簡易 API 為基底繼續延伸下去（如果順利的話啦）&lt;/p&gt;
&lt;p&gt;這篇文章的前半段會用來記錄一些&lt;strong&gt;使用或開發 API 常用到的相關知識&lt;/strong&gt;，如果對 HTTP 的部分已經有點頭緒，或是迫不及待想直接動手用 .net Core 開 Api 服務的朋友們，可以直接跳到 &lt;a href=&#34;#%E6%AD%A3%E5%BC%8F%E9%96%8B%E5%B7%A5&#34;&gt;正式開工&lt;/a&gt; 的部份。那麼，我們開始吧～&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;什麼是-api&#34;&gt;什麼是 API&lt;/h3&gt;
&lt;p&gt;我們在物件導向的 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface/&#34;&gt;介面&lt;/a&gt; 時有稍微聊過所謂介面（Interface）的概念：「在兩個系統，或是兩個分層之間要介接的時候，只需要提供我這個功能的接口／介面給對方，就能讓對方知道如何使用」&lt;/p&gt;
&lt;p&gt;API（Application Programming Interface）也是同樣的道理：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在不同的應用程式或服務（Application）之間，使用程式碼（Programming）的方式提供一組 介面（Interface），讓提供方和使用方可以藉由這組介面銜接起來。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;API 最貼切的比喻就是我們在 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;封裝篇&lt;/a&gt; 也用過的&lt;strong&gt;販賣機&lt;/strong&gt;：販賣機會提供不同飲料的按鈕，當我們選擇了其中一個按鈕按下、投了錢之後，對應的飲料就會掉下來。&lt;/p&gt;
&lt;p&gt;對應回來就是：我們到了某個服務（販賣機），去拿我們想要的資料（飲料），所以呼叫了該服務的某支 API（按鈕）並且提供了一些該 API 要求的資料（投錢），最後 API 就會把我們想要的資料交給我們（飲料）&lt;/p&gt;
&lt;p&gt;再用更實際的例子來說就像是：假設我們想要做一款可以查詢台北市的公車動態的 APP，於是我們到了提供公車動態的服務 &lt;a href=&#34;https://ptx.transportdata.tw/MOTC?t=Bus&amp;amp;v=2#!/CityBus/CityBusApi_RealTimeByFrequency&#34;&gt;MOTC Transport API v2&lt;/a&gt; 去找我們想要的 API，過程中我們可能需要告訴服務我們要查的是台北市，最後服務就會將公車動態的資料交給我們。&lt;/p&gt;
&lt;p&gt;關於 API 的部份，推薦可以先閱讀過 Huli 大大的這兩篇，將基本觀念說明的相當好懂且透徹：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@hulitw/learning-tcp-ip-http-via-sending-letter-5d3299203660&#34;&gt;從傳紙條輕鬆學習基本網路概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@hulitw/ramen-and-api-6238437dc544&#34;&gt;從拉麵店的販賣機理解什麼是 API&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，也推一下我在 CodingBar 看到的這篇 &lt;a href=&#34;https://medium.com/codingbar/api-%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E9%BA%BC-%E7%94%A8%E7%99%BD%E8%A9%B1%E6%96%87%E5%B8%B6%E4%BD%A0%E8%AA%8D%E8%AD%98-95f65a9cfc33&#34;&gt;API 到底是什麼？ 用白話文帶你認識&lt;/a&gt; 和它所引用的影片：&lt;/p&gt;
&lt;iframe src=&#34;https://www.youtube.com/embed/zvKadd9Cflc&#34; width=&#34;100%&#34; height=&#34;480&#34; frameborder=&#34;0&#34; scrolling=&#34;no&#34; allowfullscreen&gt;&lt;/iframe&gt;</description>
    </item>
    
    <item>
      <title>菜雞新訓記 (1): 使用 Git 來進行版本控制吧</title>
      <link>https://igouist.github.io/post/2021/04/newbie-1-hello-git/</link>
      <pubDate>Mon, 05 Apr 2021 22:39:01 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2021/04/newbie-1-hello-git/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ojI91y9.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;這是俺整理公司新訓內容的第一篇文章，目標是&lt;strong&gt;整理 Git 相關的筆記&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;前言推薦資源&#34;&gt;前言、推薦資源&lt;/h2&gt;
&lt;p&gt;說來慚愧，前陣子 PTT 和臉書社團都有討論到相關科系畢業卻不會 Git 會不會太誇張，我正是畢業之後才開始用 Git 的那類人囧，相信像我一樣的人並不少，因此這個系列就決定從「&lt;strong&gt;新訓時學到的 Git 的基本操作&lt;/strong&gt;」開始記錄。&lt;/p&gt;
&lt;p&gt;開始之前先感謝公司前輩和完善的新手教學，還有第一天就先學 Git 的優良傳統。另外，也感謝相當多優秀的 Git 學習資源，說明得也更為詳細深入，想好好了解 Git 的朋友也可以逛逛，這邊就先推薦一波：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gitbook.tw/&#34;&gt;為你自己學 Git&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;對新手非常友善。網站點進去後往下拉，可以看到大部分章節都能免費看，佛！&lt;/li&gt;
&lt;li&gt;最有價值的是裡面的各種狀況題。畢竟當你用 Git 不只需要基本操作的時候，呃，祝你好運&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://backlog.com/git-tutorial/tw/&#34;&gt;連猴子都能懂的 Git 入門指南&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;從入門到進階篇跟過一次的話，基本操作就沒有問題了&lt;/li&gt;
&lt;li&gt;圖解讓人很好理解，而且在教學的實作部分會提供儲存庫讓你下載實作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.darkthread.net/blog/category/Git&#34;&gt;黑暗執行緒的 Git 分類文章&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;同場加映：&lt;a href=&#34;https://blog.darkthread.net/blog/my-git-cheatsheet/&#34;&gt;黑暗執行緒的 Git 指令筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;黑大出品，品質保證&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://learngitbranching.js.org/?locale=zh_TW&#34;&gt;Learn Git Branching&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;用遊戲通關的方式認識 Git，對於一些分支的概念會很有幫助&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/users/20004901/ironman/525&#34;&gt;30 天精通 Git 版本控管&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://git-scm.com/book/zh-tw/v2&#34;&gt;Pro Git&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下來我們就從認識 Git 開始吧！&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;什麼是-git&#34;&gt;什麼是 Git？&lt;/h3&gt;
&lt;p&gt;你發生過以下狀況嗎？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;從沒做過版本控制，結果突然要改回前一版，不知所措&lt;/li&gt;
&lt;li&gt;使用資料夾／壓縮檔板控
&lt;ul&gt;
&lt;li&gt;20201201.rar, 20201215_v2.rar, 20201215_首頁.rar&amp;hellip;&amp;hellip;&lt;/li&gt;
&lt;li&gt;空間越吃越兇，東西越來越雜，事情越想越不對勁，但是不敢刪除&lt;/li&gt;
&lt;li&gt;其實不知道每一份實際上改了哪裡，要復原某一段的時候要找半天，不如直接重寫一段&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;團隊合作／分組報告，各自負責一個區域，結果複製來複製去組不起來，不只需要看眼科，修 BUG 還比寫的時間還多&lt;/li&gt;
&lt;li&gt;看到一段程式碼
&lt;ul&gt;
&lt;li&gt;完全不知道為什麼要這樣寫&lt;/li&gt;
&lt;li&gt;或是氣到要死，抓不到戰犯&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那麼，你很有可能需要 Git！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞新訓記 (0): 前言</title>
      <link>https://igouist.github.io/post/2021/04/newbie-0-menu/</link>
      <pubDate>Mon, 05 Apr 2021 22:39:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2021/04/newbie-0-menu/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/uobV40z.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;長夜將至，我從今開始守望。&lt;br/&gt;
　　　　　　　　　　　　　　　　　　　　　　　　　　　　——《冰與火之歌》守夜人誓詞&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;年初整理完物件導向系列後，休息（沉迷遊戲）了好一陣子，終於要繼續整理公司新訓的內容啦！&lt;/p&gt;
&lt;p&gt;因為這個系列會是公司新訓時期的筆記整理，所以會是比較簡易的實作紀錄，並不會太過深入，需要的時候會用延伸閱讀的形式補充上去。如果看文的過程中覺得有什麼能夠補充的，也歡迎告訴我呦。&lt;/p&gt;
&lt;p&gt;本系列預計會從 Git 的基本操作開始，簡單建立一個 Web Api 為主軸，逐步介紹相關的部份，例如簡單地引入套件、簡單地分層等等。基本方針就是直接抄襲 &lt;a href=&#34;https://sunnyday0932.github.io/&#34;&gt;隔壁同事的部落格&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;後續有更新的文章，就會整理到這篇目錄中。或是也可以從 &lt;a href=&#34;https://igouist.github.io/series/%E8%8F%9C%E9%9B%9E%E6%96%B0%E8%A8%93%E8%A8%98/&#34;&gt;菜雞新訓記&lt;/a&gt; 裡面做系列文的查詢。&lt;/p&gt;
&lt;p&gt;那麼，就從第一篇：&lt;a href=&#34;https://igouist.github.io/post/2021/04/newbie-1-hello-git&#34;&gt;Git 入門這樣做&lt;/a&gt; 開始吧！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (Ex1): 小結</title>
      <link>https://igouist.github.io/post/2021/01/oo-ex1-end2020/</link>
      <pubDate>Fri, 01 Jan 2021 23:50:49 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2021/01/oo-ex1-end2020/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/hycMTRZ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;隨著 2020 進到了 2021，菜雞與物件導向也推進到了五大原則結束，可以暫時告一段落了。&lt;/p&gt;
&lt;p&gt;最初和朋友約好了要把公司新訓學到的東西做個整理（廣告一下他的部落格：&lt;a href=&#34;https://sunnyday0932.github.io/&#34;&gt;Sian&lt;/a&gt;），只是沒想到因為太常發廢文偷懶，大半年才推進到物件導向的基礎而已，甚至占不到新訓內容的十分之一。希望 2021 能繼續推進，把這部份的坑給填一填，然後把前面的文章也重構一下，只是按照我的個性，可能又會忍不住開新的坑吧，哈哈。&lt;/p&gt;
&lt;p&gt;至於物件導向相關的心得和紀錄，也就是這個系列，偶而有想到或是有所體悟的時候再發上來吧，暫時想先把前面隨手寫凌亂文章給整一整先。在這個十幾篇的短系列，記錄了從類別與物件開始，到耦合、內聚及五大原則，每個主題的心得。這邊稍微做個小整理：&lt;/p&gt;
&lt;h3 id=&#34;類別物件post202007oo-1-class-object&#34;&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;類別、物件&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;物件就是用來表達「我們知道的某個東西」，&lt;strong&gt;物件導向是用物件彼此互動的方式來建立架構&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;類別去定義我們要的物件有什麼特徵、有什麼功能，再從類別中實例化（也就是根據設計圖產生）物件出來使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;建構式多載post202007oo-2-constructor-overload&#34;&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;建構式、多載&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;建構式用來在建立物件時就進行一些我們想要的操作，例如狗狗的毛色等等天生的東西，或是這個建立這個物件的必須素材&lt;/li&gt;
&lt;li&gt;多載指的就是可以有很多個同樣名字的方法，各自去接不同的參數，讓同個目標的函式可以&lt;strong&gt;根據傳入的參數不同做不一樣的處理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (15): 最少知識原則</title>
      <link>https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle/</link>
      <pubDate>Sun, 20 Dec 2020 23:57:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/FOWZ8zY.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;上一篇&lt;/a&gt;我們紀錄了依賴反轉原則，到此五大原則介紹完畢…是這樣嗎？太天真了！就像四天王總是五個人一樣，五大原則當然也有第六個！&lt;/p&gt;
&lt;p&gt;今天的主角就是五大原則中Ｌ位的第一候補：&lt;strong&gt;最少知識原則&lt;/strong&gt;，也被稱作&lt;strong&gt;迪米特法則&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;最少知識原則-least-knowledge-principle&#34;&gt;最少知識原則 (Least Knowledge Principle)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;只和直接的朋友溝通，不和陌生人說話&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那麼所謂的朋友是什麼呢？就是指這個物件或方法有直接相關的物件啦。例如當我們使用一個方法時，這個方法應該只認識：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;該方法所屬的類別&lt;/li&gt;
&lt;li&gt;該方法所接收的參數&lt;/li&gt;
&lt;li&gt;該方法中建立的類別&lt;/li&gt;
&lt;li&gt;該方法所屬的類別所依賴的對象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外對這個方法而言都是陌生人。什麼情況會遇到陌生人呢？有一個蠻常遇到的狀況就符合定義：當我們使用依賴對象的方法，該方法給了我們另一個類別時，我們就正在接觸毫無關係的陌生人。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (14): 依賴反轉原則</title>
      <link>https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle/</link>
      <pubDate>Sun, 13 Dec 2020 21:53:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ywiHuis.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在聊依賴反轉之前，先讓我們聊聊什麼是依賴，所謂的依賴就是一種「受到某個東西影響、牽制」的狀態。例如說如果有個像我一樣的肥宅每天一定要來一片雞排才能療癒身心，那我就是依賴雞排；同樣的，如果有個大叔不抽菸就會全身不舒服，就是對香菸有所依賴。當有「必須要藉由某個人事物來達到目的」的狀況時，就是依賴。&lt;/p&gt;
&lt;p&gt;而在程式設計裡面的概念也差不多，如果&lt;strong&gt;Ａ模組直接受到Ｂ模組的影響，我們就稱Ａ依賴了Ｂ&lt;/strong&gt;，最明顯的狀況就是Ａ模組需要藉由Ｂ模組的實例來完成某個功能的時候，例如「匯出報表」功能建立了一個「Excel 控制類別」的實例以建立檔案；或是「會員查詢」功能建立了一個「DB 連線」的實例來進入資料庫取得會員資料，諸如此類由Ａ模組直接藉由Ｂ模組的實例來完成想要的動作，就是依賴。&lt;/p&gt;
&lt;h2 id=&#34;依賴與耦合&#34;&gt;依賴與耦合&lt;/h2&gt;
&lt;p&gt;我們在之前的 &lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;耦合篇&lt;/a&gt; 提過，如果模組和另一個模組之間有關連，那這兩者之間就耦合。以此來看，依賴就是一種耦合的關係，那麼，依賴是健康還是不健康的耦合呢？&lt;/p&gt;
&lt;p&gt;現在讓我們用 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;多型篇&lt;/a&gt; 用過的「老闆徵工程師」的例子來舉例一下：現在有間小小公司，老闆請來了小明當工程師，並請他開工撰寫產品程式碼。&lt;/p&gt;
&lt;p&gt;當「撰寫產品程式」對「工程師」直接依賴的時候，狀況可能是這樣的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Product Work()
{
    Ming programmer = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Ming();
    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; product = programmer.Programming();
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; product;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;過一陣子，老闆發現小明寫出來的東西似乎不太行，於是把小明趕走，另外請了小華。這時候因為「工程師」這個實作類別不一樣了，我們就必須要改一次程式碼：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Product Work()
{
    Hua programmer = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Hua();
    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; product = programmer.Programming();
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; product;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (13): 介面隔離原則</title>
      <link>https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle/</link>
      <pubDate>Sun, 15 Nov 2020 12:00:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/itHN6VZ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;今天要記錄的是介面隔離原則，顧名思義是和介面高度相關的原則。因此在閱讀本篇之前，可能需要先對 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;介面&lt;/a&gt; 有一點了解呦。&lt;/p&gt;
&lt;p&gt;事情就從上一篇 &lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;里氏替換原則&lt;/a&gt; 的鳥類物流公司開始說起。老闆痛定思痛，決定先用&lt;strong&gt;介面&lt;/strong&gt;先規定好物流士們的應徵條件，例如裝貨、卸貨、飛行、必須有帥氣的喙等等。&lt;/p&gt;
&lt;p&gt;這道命令下來後，倉庫們的企鵝都慌了，來檢查的編譯器瘋狂跳出 Error:「您未實作 IBird 的 Fly() 方法！」這下怎麼辦呢，為了要保住飯碗，企鵝們就必須實作出飛行才行，可是企鵝真的就不會飛呀！&lt;/p&gt;
&lt;p&gt;這下子企鵝們只剩下兩個選擇：不實作飛行，但是就不能被當成物流士，最後就會被開除；或是……空實作。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Penguin&lt;/span&gt; : IBird
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Fly()
    {
      &lt;span style=&#34;color:#75715e&#34;&gt;// Do nothing;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;企鵝們終於騙過了編譯器檢查員，然而當送貨的命令下來之後，企鵝們再一次卡在倉庫門口發呆，最終物流公司仍然踏上了虧損的老路，再度面臨倒閉危機…&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (12): 里氏替換原則</title>
      <link>https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle/</link>
      <pubDate>Sun, 01 Nov 2020 11:31:44 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ZAuxFRy.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;里氏替換原則-liskov-substitution-principle&#34;&gt;里氏替換原則 (Liskov Substitution Principle)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;子類別必須能夠替換父類別&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;里氏原則還包含了一個概念：子類別替換父類別後，&lt;strong&gt;不需要改變，也不會發生任何錯誤或異常&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;從定義就可以看出來，這項原則是來替我們處理繼承問題的。因此，在開始本篇之前，可能需要先對 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;繼承&lt;/a&gt; 以及 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;多型&lt;/a&gt; 有基本的認識。如果可以的話，也請先看過 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;介面&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;那麼，就讓我們從很久很久以前開始說起…&lt;/p&gt;
&lt;h2 id=&#34;我的子類別進入叛逆期了怎麼辦&#34;&gt;我的子類別進入叛逆期了，怎麼辦？&lt;/h2&gt;
&lt;p&gt;很久很久以前，有一間公司受到 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%BB%A5%E9%B8%9F%E7%B1%BB%E4%B8%BA%E8%BD%BD%E4%BD%93%E7%9A%84%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE&#34;&gt;鴿子封包&lt;/a&gt; 所啟發，打算發展鳥類運輸技術，強勢打入無人機市場，用生物智慧掀起對人工智慧的革命。既然&lt;strong&gt;鳥類都會飛行&lt;/strong&gt;，理所當然可以藉由飛行來進行空運，甚至還可以偷偷擊墜那些無人機對手，野心勃勃的老闆立馬徵了一批鳥類物流士，打出「凡是鳥類都可應徵」的旗號，各式各樣的猛禽響應而來，一時之間掀起整個物流業的風暴！&lt;/p&gt;
&lt;p&gt;但是好景不常，公司營運之後發貨狀況不佳，頻繁發生丟包問題，甚至有些貨根本就出不了倉庫，虧損越來越大，心急如焚的老闆下令徹查，這才發現—&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (11): 開放封閉原則</title>
      <link>https://igouist.github.io/post/2020/10/oo-11-open-closed-principle/</link>
      <pubDate>Sun, 25 Oct 2020 11:58:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/10/oo-11-open-closed-principle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/6pQOti2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;開放封閉原則-open-close-principle&#34;&gt;開放封閉原則 (Open-Close Principle)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;軟體實體（類別、模組、函式等等）應該對擴展開放，而對修改封閉&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我們了解什麼是「對擴展開放」和「對修改封閉」之前，先讓我們談談：什麼是擴展，什麼又是修改呢？&lt;/p&gt;
&lt;p&gt;用白話一點的方式來形容，修改就是把東西拆開來改，像是手術；而擴展就是對東西額外加裝模組，像是添購設備。我們用飛行來舉例，像是鳥類直接用翅膀飛行，如果有需要修改飛行方法的話就得對鳥直接進行手術；但如果今天是一個裝備了噴射背包的人，我們只需要把噴射背包換成噴射鞋子、甚至噴射翅膀就可以了，不需要去修改人這個本體。&lt;/p&gt;
&lt;p&gt;這邊可以發現開放封閉原則是針對「改變的時候」去做一個行動的建議，例如需求追加和變更等等。&lt;strong&gt;凡是變化都有成本&lt;/strong&gt;，例如變動的難易度、變動造成的影響範圍等等都會影響到成本，若是程式碼冗長、內部邏輯複雜，類別之間互相耦合、影響範圍很廣，導致綁手綁腳或壞東壞西等等狀況，使得修改很困難，成本就會變高，進而使得開發效率變低。&lt;/p&gt;
&lt;p&gt;然而，軟體並不是製造完畢就完工的東西，而是隨需求而生、隨需求而變的動態作品，因此程式碼的修改或重構相當頻繁。就像我們在 &lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;內聚耦合篇&lt;/a&gt; 提過的：軟體面對改變的能力，就像基因適應環境並生存下去的能力。因此，程式必須具有彈性，也就是需要盡可能降低修改的成本。&lt;/p&gt;
&lt;p&gt;那麼讓我們回到前面：動手術跟換道具，哪個的成本比較高呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;面對需求，對程式碼的改動是透過增加新程式碼進行的，而不是更改現有的程式碼&lt;/strong&gt;　　
&lt;br/&gt;（《大話設計模式》）&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (10): 單一職責原則</title>
      <link>https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle/</link>
      <pubDate>Fri, 02 Oct 2020 11:03:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/VyyeaYz.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我們在前面的 &lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;內聚和耦合&lt;/a&gt; 有提到過，內聚並不是無腦把相關的程式碼都封在一起就好了，也有分成健康的和不健康的。但我們要怎麼知道這個類別是否足夠健康呢？單一職責原則就是很好的檢驗方式，這篇就讓我們來紀錄一下。&lt;/p&gt;
&lt;h2 id=&#34;單一職責原則-single-responsibility-principle&#34;&gt;單一職責原則 (Single Responsibility Principle)&lt;/h2&gt;
&lt;p&gt;「單一職責」原則顧名思義，就是一個類別應該&lt;strong&gt;只負責一個職責&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但是這樣太過籠統了，「職責」相當容易產生誤會，容易變成各說各話。&lt;s&gt;畢竟咱們工程師最愛戰定義了嘛。&lt;/s&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;「你這類別不優，它有兩個職責！登入跟登出！」&lt;/p&gt;
&lt;p&gt;『沒有啦，我這個類別就是負責帳戶管理的啊』&lt;/p&gt;
&lt;p&gt;「&lt;a href=&#34;https://dailyview.tw/Daily/2019/11/07&#34;&gt;OSSO&lt;/a&gt;。乾脆你全部放一起，然後說是負責網站管理算了，呵」&lt;/p&gt;
&lt;p&gt;『……你存心來找碴的是不是？』&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;為了避免像這樣產生職場糾紛，我們需要先定義一下什麼是「職責」。經過前輩們的努力（解釋）之後，單一職責的定義就成了：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;就一個類別而言，應該只有一個引起它變化的原因&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外，我也看過「一個類別應該只對一個角色負責」的說法，這兩者的核心概念是一樣的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (9): SOLID</title>
      <link>https://igouist.github.io/post/2020/09/oo-9-solid/</link>
      <pubDate>Sun, 20 Sep 2020 13:51:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/09/oo-9-solid/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/U7iWMT9.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;終於進入了原則篇，接下來的幾篇我們會介紹幾個物件導向的原則（基本上就是指 SOLID 原則）。因此這篇就讓我 &lt;s&gt;水一下&lt;/s&gt; 當成後半段的目錄，方便之後可以把相關的部分整理進來。&lt;/p&gt;
&lt;h2 id=&#34;為什麼我們需要這些原則&#34;&gt;為什麼我們需要這些原則？&lt;/h2&gt;
&lt;p&gt;我們在前面的章節已經說明了一些物件導向的特性，例如繼承和多型等等。然而我們並沒有討論到怎麼運用、或是怎樣設計才能算是更好的、更優雅的、更符合物件導向精神的；我們並沒有提到一個評估的標準，或是指引一個更好的方向。&lt;/p&gt;
&lt;p&gt;然而，混亂的使用物件導向對整個專案的毀滅性甚至比乾脆不使用物件導向還高。&lt;/p&gt;
&lt;p&gt;這些特性使用起來很簡單，大多數語言只需要一個符號或標示就能完成繼承，把一堆東西全部塞在一起就可以說我在封裝。但怎麼使用得好，又該什麼時候使用呢？這就是難的地方吧。&lt;/p&gt;
&lt;p&gt;例如說濫用繼承，或是封裝時完全不隱藏複雜度一路 Puuuuublic 到底，又或者是類別之間過於相互依賴，全部耦合成一團等等。如果隨便地使用物件導向的各項特性，就會讓整個架構變得僵化、脆弱、危險、充滿臭味。&lt;/p&gt;
&lt;p&gt;更可怕的是，這個發臭的過程是每一次設計、每一次修改都會有所影響，所謂「持續發生，腐敗成真」，&lt;strong&gt;隨著物件導向的亂用、誤用、無腦用，軟體就會逐漸腐化&lt;/strong&gt;。一組腐化的軟體可能會有以下特徵：大量的依賴使得修改變得困難、修改後看似不相干的各個地方發生問題、或是修改時沒辦法依循原本的設計、到處出現不必要的複雜性和不必要的重複，模組也變得難以理解等等。&lt;/p&gt;
&lt;p&gt;阻止程式碼的腐化、追求更好的架構和設計、寫出更好的代碼，當然是我輩所追求的目標。儘管面對的可能是不同的問題和不同的環境，那些優質、穩固、具有&lt;strong&gt;反脆弱&lt;/strong&gt;特質的程式碼也必然會有些共通之處。例如說：需要具有&lt;strong&gt;面對改變&lt;/strong&gt;的能力、具有&lt;strong&gt;方便管理&lt;/strong&gt;的能力、具有&lt;strong&gt;隱藏複雜性&lt;/strong&gt;的能力。&lt;/p&gt;
&lt;p&gt;因此，大前輩們整理並提出了一些可以致力的方向，也就是所謂的「&lt;strong&gt;原則&lt;/strong&gt;」。如同心法、教義一般，只要實作的同時將其牢記在心，就能讓我們作為一些行動的準則和依據。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (8): 內聚、耦合</title>
      <link>https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling/</link>
      <pubDate>Sun, 13 Sep 2020 23:56:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/cgxW9yZ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;做為前後段落的分水嶺，這篇文章我將紀錄一下 &lt;strong&gt;「內聚」(Cohesion)&lt;/strong&gt; 和 &lt;strong&gt;「耦合」(Coupling)&lt;/strong&gt;，這兩者是評估一個類別或元件的重要概念。&lt;/p&gt;
&lt;p&gt;在實務上，為了提升擴展性，降低維護成本等因素，我們對於單個類別或元件，會有著 &lt;strong&gt;「低耦合」&lt;/strong&gt; 及 &lt;strong&gt;「高內聚」&lt;/strong&gt; 的期待。例如我們在 &lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt; 中，我們就有提到封裝的好壞相當重要，其中也包含了「提高類別內的內聚性，降低對外的耦合性」。那麼，到底什麼是內聚，什麼又是耦合呢？&lt;/p&gt;
&lt;h2 id=&#34;內聚&#34;&gt;內聚&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;「把需要的程式和資料都包裝在同一個模組內，使得該模組能夠做為一個單獨的個體執行」&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;白話一點說，就是就是把用到的東西都打包到一處，該有的自己都有了，所以即使單獨一個人也能完成工作的能力、可以自己 Carry 整場不用看豬隊友臉色的能力。越能自己單幹，越不需要依賴其他類別的時候，內聚力也就越高。&lt;/p&gt;
&lt;p&gt;也就是說：如果你的類別什麼都要依賴其他類別，像小嬰兒一樣需要呵護照顧，那內聚力就很低。反之，如果像野外求生大師，啥都靠自己，那內聚力就超高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;內聚代表的是該模組的獨立性，當這個模組可以獨力完成工作，就代表我們能夠重複使用它，且不需要擔心影響到其他模組。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;並且也基於這點，我們不用擔心變動這個模組時需要先處理其他的模組，因為這個工作所需的都包含在模組內了，這樣就可以&lt;strong&gt;單獨修改&lt;/strong&gt;該模組，減少維護成本。&lt;/p&gt;
&lt;p&gt;例如你的筆已經包含了所有寫字工具的條件，具有墨水跟筆芯等等，可以只使用筆就完成寫字這個工作。那麼我們就可以隨身帶著，在任何需要的時候重複使用它，而不用擔心我們會不會漏了什麼必要零件沒有帶出門。同時，如果我們需要換筆芯或墨水，我們也知道要更換的部份就在筆裡面，不需要去找鉛筆盒中別的地方。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (7): 介面</title>
      <link>https://igouist.github.io/post/2020/07/oo-7-interface/</link>
      <pubDate>Sun, 12 Jul 2020 23:53:07 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/oo-7-interface/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/9eGbMlk.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果說&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;繼承&lt;/a&gt;是用來表明物件「屬於什麼」；那麼介面就是用來表明物件「能做什麼」。&lt;/p&gt;
&lt;p&gt;如果說&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;封裝&lt;/a&gt;是將物件視作一個整體，是隱藏複雜度；那麼介面就是封裝精神的體現。&lt;/p&gt;
&lt;p&gt;如果說&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;多型&lt;/a&gt;是指藉著繼承後能實作不同的行為的可能性達到擴展的彈性；那麼介面就是在實作多型。&lt;/p&gt;
&lt;p&gt;介面就是這麼厲害，這麼瀟灑。介面就是我大哥，今天誰不服介面，對不起！我們不認識。&lt;/p&gt;
&lt;p&gt;介面就像是針對類別的實作、物件的行為去做規定的一個契約書，會先定義好要實作這個介面的類別所必須要有的方法，而當我們建立符合這個介面的類別時，就必須實作出所有介面中定義好方法才可以。……這樣說起來實在太繞口，總而言之介面的核心概念只有一條：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我不在乎你是誰，我只在乎你能做什麼。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;還是公司誠徵工程師的例子&#34;&gt;還是公司誠徵工程師的例子&lt;/h2&gt;
&lt;p&gt;由於介面基本上就是封裝繼承多型抽象之大雜燴，所以我們把前面&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;多型&lt;/a&gt;的小明小華例子稍微修改來用吧。也就是以公司徵人的方式去理解介面。&lt;/p&gt;
&lt;p&gt;介面就像是老闆開出來的要求列表，例如說：要會寫 C#、要會寫 SQL、要會 VB…等等，於是老闆就貼出了徵人啟示，要求新來的員工必須要有 &lt;code&gt;IProgrammer&lt;/code&gt; 寫的能力：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; IProgrammer
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; WriteCSharp();
    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; WriteSQL();
    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; WriteVB();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;特別注意和前面多型的例子的不同處，&lt;strong&gt;介面只需要先定義好該做的事，裡面怎麼做不需要管；所以只需要宣告要求的方法，不需要撰寫方法本體&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;於是今天小華就又(?)來面試了，但是他其實並不會寫 C#：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Hua&lt;/span&gt; : IProgrammer
{
    &lt;span style=&#34;color:#75715e&#34;&gt;// Error: Hua 未實作 IProgrammer.WriteCSharp()
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; WriteSQL() { &lt;span style=&#34;color:#75715e&#34;&gt;/* Work */&lt;/span&gt; }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; WriteVB() { &lt;span style=&#34;color:#75715e&#34;&gt;/* Work */&lt;/span&gt; }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這時候編譯器就會跳出錯誤了：很抱歉，你不符合我們 &lt;code&gt;IProgrammer&lt;/code&gt; 的規定，因為我們只喜歡訓練精英（略），請你實作完之後再來。否則你就不能掛上我們 &lt;code&gt; : IProgrammer&lt;/code&gt; 的頭銜。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (6): 抽象、覆寫</title>
      <link>https://igouist.github.io/post/2020/07/oo-6-abstract-override/</link>
      <pubDate>Sun, 12 Jul 2020 23:53:06 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/oo-6-abstract-override/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Y2gHFsr.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;備註：這邊的抽象是指程式語言中的抽象類別，而非抽象化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;抽象的概念很直接，請回想一下前面的例子就可以了：&lt;/p&gt;
&lt;p&gt;當我們在用卡牌的例子時，雖然怪獸卡跟魔法卡都繼承了 Card 這個類別，但是我們仍然能 &lt;br/&gt; &lt;code&gt;new Card()&lt;/code&gt; 來建立一張新卡牌，那…怪怪的吧，這張卡牌到底是什麼呀，空白的卡片嗎？&lt;/p&gt;
&lt;p&gt;又或是動物的例子，我們的狗跟貓都繼承了哺乳類，那我們能實例化一個哺乳類嗎？我們的狗跟鳥都是動物，那我們能實例化一個動物嗎？&lt;/p&gt;
&lt;p&gt;小明跟小華都繼承了工程師，那我們能 new 一個工程師嗎…？&lt;/p&gt;
&lt;p&gt;有些類別就是這樣，它們負責定義共通的那些特性，&lt;strong&gt;然而它們本身不應該被實體化成一個物件，這種類別我們就應該把它們標記為抽象類別&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象類別在 C# 裡用 &lt;code&gt;abstract&lt;/code&gt; 這個修飾詞來表示&lt;/strong&gt;，可以加在類別或方法上。例如 &lt;code&gt;abstract class Animal&lt;/code&gt; 就代表動物這個類別是個抽象類別，它不能被實例化。&lt;/p&gt;
&lt;p&gt;而當加在方法上時，例如 &lt;code&gt;public abstract void Eat()&lt;/code&gt; 就是代表這個進食的方法無法被叫用，只能由繼承者去重新定義這個方法。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Animal&lt;/span&gt;
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; color { &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt;; }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Eat();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那麼繼承者們，也就是衍生類別如何去重新定義父類別的方法呢？&lt;/p&gt;
&lt;p&gt;&lt;del&gt;所謂「欲戴王冠，必 Override」&lt;/del&gt;，這時候就必須使用&lt;strong&gt;覆寫（&lt;code&gt;override&lt;/code&gt;）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;覆寫是指對於像是前述的抽象方法時，在同名的方法前加上 &lt;code&gt;override&lt;/code&gt; 關鍵字就可以讓程式知道你要覆寫這個方法（你不覆寫的話，編譯器還會生氣）。&lt;/p&gt;
&lt;p&gt;例如前述的 Eat，狗就可以用 &lt;code&gt;public override void Eat()&lt;/code&gt; 的方式去覆寫吃東西這個方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Dog&lt;/span&gt; : Animal
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; color { &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt;; } = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Black&amp;#34;&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Eat()
    {
        &lt;span style=&#34;color:#75715e&#34;&gt;/* 嚼嚼嚼 */&lt;/span&gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (5): 多型</title>
      <link>https://igouist.github.io/post/2020/07/oo-5-polymorphism/</link>
      <pubDate>Sun, 12 Jul 2020 23:53:05 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/oo-5-polymorphism/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/65N5R3A.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;多型算是比較三特性之中給人感覺比較溫和的了，不如說只要有了繼承，那麼多型的到來就是必然的。多型的定義是：不同的物件能夠做出一樣的行為，但必須由他們自己的程式碼來實作。&lt;/p&gt;
&lt;p&gt;白話一點說就是：&lt;strong&gt;一樣的事，不同做法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;多型相對是比較好理解的，畢竟每個人做同一件事的方法本來就不太一樣。例如一樣是泡奶茶，英國就正常地泡，&lt;a href=&#34;https://www.ettoday.net/news/20200707/1754177.htm&#34;&gt;美國就會用微波爐&lt;/a&gt;；一樣是肉粽，有些人就是比較愛吃油飯；到了程式的世界裡也是，即使繼承了同一個物件，實現這個行為的方式也可以不同。&lt;/p&gt;
&lt;p&gt;在此可以先推菜鳥工程師肉豬的這篇 &lt;a href=&#34;https://matthung0807.blogspot.com/2018/02/java-overload.html&#34;&gt;Java 什麼是多載(Overload), 覆寫(Override), 多型(Polymorphism)&lt;/a&gt; 中的說明。其中可以從例子看到儘管狗跟鳥都是繼承自動物這個類別，但對於「移動」這個方法，他們實作的方式並不一樣。這就是多型的範例。&lt;/p&gt;
&lt;p&gt;我個人更喜歡用職位的方式去理解多型。&lt;/p&gt;
&lt;p&gt;被繼承者就像是該職位的工作，例如說：&lt;code&gt;Programmer&lt;/code&gt; 要會寫 C#、要會寫 SQL、要會 VB…等等，於是老闆就貼出了徵人啟示，要求新來的員工必須要有 &lt;code&gt;Programmer&lt;/code&gt; 寫的能力：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Programmer&lt;/span&gt;
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; WriteCSharp()
    {
        &lt;span style=&#34;color:#75715e&#34;&gt;/* 努力地寫 C# */&lt;/span&gt;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; WriteSQL()
    {
        &lt;span style=&#34;color:#75715e&#34;&gt;/* 努力地寫 SQL */&lt;/span&gt;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; WriteVB()
    {
        &lt;span style=&#34;color:#75715e&#34;&gt;/* 努力地寫 VB */&lt;/span&gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (4): 繼承</title>
      <link>https://igouist.github.io/post/2020/07/oo-4-inheritance/</link>
      <pubDate>Sun, 12 Jul 2020 23:53:04 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/oo-4-inheritance/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/g9FZ3WN.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接著要介紹的是繼承 aka 物件導向三大特性之王 aka 濫用榜 Ko.1 ，繼承的強大幾乎和它的惡名一樣可怕，給一個從聊聊程式的這篇 &lt;a href=&#34;https://dotblogs.com.tw/initials/2016/06/10/171117&#34;&gt;[心得整理] c# 物件導向程式 - 2.封裝、繼承、多型的三大特性&lt;/a&gt; 摘過來的例子就可以略知一二了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/IFV4xjr.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;什麼也不做，僅僅只是繼承而已，就取得了繼承對象（C# 中稱為基底類別）近乎全部的內容，真是太可怕了。在 C# 中，繼承可以取得基底類別除了 &lt;code&gt;Private&lt;/code&gt; 以外所有的內容，例如 &lt;code&gt;Protected&lt;/code&gt; 更是表明就是只給繼承使用的。&lt;/p&gt;
&lt;p&gt;由此可見，在減少重複程式碼的路上，繼承無疑達到了全新的高度。&lt;/p&gt;
&lt;p&gt;那麼繼承代表的是什麼意思呢？大多的網站都能直接說明：&lt;strong&gt;繼承是一種「is-a」的關係。當你能說出Ａ是一個Ｂ的時候，就代表你認為Ａ可以繼承自Ｂ&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最直覺的繼承例子就是&lt;strong&gt;物種的分類&lt;/strong&gt;。舉例來說，狗跟貓都是哺乳類，因此他們都可以繼承到一些哺乳類共通的特徵（例如哺乳、用肺呼吸）。藉由繼承，我們可以把這些哺乳類共有的特徵全部放在哺乳類這個物件，再由狗和貓分別去繼承哺乳類，藉此讓他們都能得到哺乳類的特徵，再進一步發展出自己的特徵和行為，甚至重新定義基底類別的方法為自己所用。因此，像大話設計模式就將繼承說明如：繼承者是對於被繼承者的一種特殊化。&lt;/p&gt;
&lt;p&gt;如此一來，當我們需要修改哺乳類的定義的時候，&lt;strong&gt;只需要修改一個地方，而繼承了哺乳類的這些物件（C# 中稱為衍生類別）全都能夠一起修改到，大大地減少了跑來跑去修改的次數，也讓程式碼的重複大幅度地減少&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;然而也因為如此，繼承最大的惡名出現了：&lt;strong&gt;繼承享受了取用基底類別內容的好處，卻也必須背負牽一髮動全身的風險&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (3): 封裝</title>
      <link>https://igouist.github.io/post/2020/07/oo-3-encapsulation/</link>
      <pubDate>Sun, 12 Jul 2020 23:53:03 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/oo-3-encapsulation/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/cc9DLDo.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;封裝、&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;繼承&lt;/a&gt;、&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;多型&lt;/a&gt;並稱物件導向三大特性，我們接下來也會按照這個順序快速地介紹。首先就是我們的黑盒子：封裝。&lt;/p&gt;
&lt;p&gt;封裝包含了兩個重要的觀念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;控制物件和外部進行互動的出入口&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隱藏物件內部的細節資訊&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;強者我同事整理的&lt;a href=&#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-3_%E5%B0%81%E8%A3%9Dencapsulation%E7%B9%BC%E6%89%BFinheritance%E8%88%87%E5%A4%9A%E5%9E%8Bpolymorphism/&#34;&gt;文章&lt;/a&gt;裡的例子就舉得不錯：當你按下鍵盤的Ａ鍵，螢幕隨即出現了Ａ，你不必知道中間發生了什麼事，你只需要知道怎麼操作和最後得到什麼就可以了。&lt;/p&gt;
&lt;p&gt;其中鍵盤提供的按鍵，就是我們對電腦進行互動的出入口；而電腦實際上做了什麼事情，也被隱藏了起來，讓我們只需要關注結果就好。&lt;/p&gt;
&lt;p&gt;此外我也看到過販賣機的例子，&lt;strong&gt;當你去販賣機買飲料，你也不需要知道裡面的構造，只要知道你選了飲料投了錢，飲料就會跑出來就行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;從上面的兩個例子，相信大家已經掌握到封裝的概念了：&lt;strong&gt;將物件視作一個整體，把內部的實作內容隱藏起來，讓使用者只需要知道怎麼使用這個物件即可。&lt;/strong&gt;（相似的思路，我們後續的&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;介面&lt;/a&gt;會再提到）&lt;/p&gt;
&lt;p&gt;如果封裝做得夠好，除了可以將程式碼整理得井井有條以外，也能讓物件內部的修改不會直接影響到使用物件的地方，達成了降耦合的目標&lt;/p&gt;
&lt;p&gt;並且也能讓物件的使用者直覺地知道如何使用物件提供的方法，如此使用者就可以專注在更高層次的抽象，而不用被物件內部的細節所干擾。&lt;/p&gt;
&lt;p&gt;最後，從上面的敘述中我們可以察覺到要實現封裝，最重要的就是：&lt;strong&gt;對外的開放程度（存取範圍）的控制&lt;/strong&gt;。或是套一句前輩的說法：&lt;strong&gt;給程式碼隱私的空間&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;補充：如果想問「什麼是耦合？」的朋友，建議可以看看這篇：&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10203659&#34;&gt;實務上的高內聚與低耦合&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;或是參照本系列後續的 &lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;內聚與耦合&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;存取範圍與存取子&#34;&gt;存取範圍與存取子&lt;/h2&gt;
&lt;p&gt;先讓我們從存取範圍開始說起吧，因為我個人慣用的是 C#，因此就介紹一下 C# 是怎麼控制存取範圍的。&lt;/p&gt;
&lt;p&gt;在 C# 之中，類別裡控制可見度是使用修飾子來定義存取範圍，也就是當我們替類別宣告欄位時常看到的 &lt;code&gt;Public&lt;/code&gt; 和 &lt;code&gt;Private&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Public&lt;/code&gt;: 這是公開的，所有人都看得到&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Private&lt;/code&gt;: 這是私有的，只有自己看得到&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了最常用的這兩個以外，還有其他的修飾子可以先知道一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Protected&lt;/code&gt;: 這是受到保護的，只有自己和繼承的孩子們看得到&lt;/li&gt;
&lt;li&gt;&lt;code&gt;internal&lt;/code&gt;: 這是內部的，只有身為同一個組件的朋友們看得到&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Protected internal&lt;/code&gt;：組合上面兩個，也就是可以給同個組件的朋友們，或是其他組件繼承的孩子們看見&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下來的部分會以最常見的 &lt;code&gt;Public&lt;/code&gt; 和 &lt;code&gt;Private&lt;/code&gt; 來繼續說明，對存取範圍的這些修飾子有興趣的朋友，可以參照 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/csharp/language-reference/keywords/accessibility-levels&#34;&gt;存取範圍層級&lt;/a&gt; 的說明。&lt;/p&gt;
&lt;p&gt;現在我們已經知道了有哪些修飾子可以用來控制存取範圍，但為什麼我們會需要宣告存取範圍的大小呢？其根本是為了&lt;strong&gt;將控制權掌握在物件本身&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;就像大話設計模式比喻的：物件就像間房子，我們不希望被看光光，可以看見的 &lt;code&gt;Public&lt;/code&gt; 就像門和窗，而不該看見的 &lt;code&gt;Private&lt;/code&gt; 則是用牆壁隱藏起來，而對於這間房子而言，門窗是可以控制的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (2): 建構式、多載</title>
      <link>https://igouist.github.io/post/2020/07/oo-2-constructor-overload/</link>
      <pubDate>Sun, 12 Jul 2020 23:53:02 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/oo-2-constructor-overload/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/naCjLay.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我就直接說了，有用前面的程式碼區塊的人，絕對執行不了。因為我們建立哥布林和戰士這兩張卡片的時候，根本就沒有給他們數值呀！&lt;/p&gt;
&lt;p&gt;雖然可以先呼叫出來再賦值…&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; goblin = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Card();
goblin.Name = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;哥布林&amp;#34;&lt;/span&gt;;
goblin.Attack = &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;;
goblin.Health = &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;/* ...其他賦值 */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這實在相當占空間，也有點奇怪。畢竟如果是阿福（狗），一出生的時候應該就確定了一些特徵才對，例如品種、血型、眼睛顏色這種。並不會出生後過一陣子，才突然決定這些東西，既然如此，我們在產生物件的時候，當然也會希望在&lt;strong&gt;建立的同時就先決定好一部份內容&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這時候我們就可以藉由&lt;strong&gt;建構式&lt;/strong&gt;的方式，在建立物件時就進行一些我們想要的操作。&lt;/p&gt;
&lt;h2 id=&#34;建構式&#34;&gt;建構式&lt;/h2&gt;
&lt;p&gt;事實上，&lt;strong&gt;當我們呼叫 &lt;code&gt;new Card()&lt;/code&gt; 的時候&lt;/strong&gt;（不覺得這個 () 很有呼叫方法的感覺嗎？）&lt;strong&gt;我們就是正在調用 Card 的建構式&lt;/strong&gt;。而當我們沒有特別去定義建構式的時候，就會直接使用內建的建構式去幫我們產生物件。&lt;/p&gt;
&lt;p&gt;現在我們替 Card 新增一個建構式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Card&lt;/span&gt;
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Card (&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; name, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; attack, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; health)
    {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Name = name;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Attack = attack;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.Health = health;
    }
    &lt;span style=&#34;color:#75715e&#34;&gt;/* ... 其他屬性和方法 */&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 C# 的時候，建構式必須和類別同名，且不需要定義回傳類型。當我們有了建構式，剛剛的例子就可以改寫成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; goblin = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Card(name: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;哥布林&amp;#34;&lt;/span&gt;, attack: &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, health: &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; warrior = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Card(name: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;戰士&amp;#34;&lt;/span&gt; , attack: &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, health: &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;);
warrior.Hit(goblin);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;建構式也就是建立這個物件時執行的函式&lt;/strong&gt;，通常會用來進行初始化，也就是做一些建立物件必要的準備。例如傳遞必要屬性或是建構需要的其他物件、或是給予私有屬性初始值等等，例如說我們的卡牌一建立，就會需要知道它的名字和戰鬥力，這樣才有卡牌的感覺，而不該像一些 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%AD%A6%E8%97%A4%E9%81%8A%E6%88%B2&#34;&gt;壞決鬥者&lt;/a&gt; 邊打牌邊偷偷印卡。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (1): 類別、物件</title>
      <link>https://igouist.github.io/post/2020/07/oo-1-class-object/</link>
      <pubDate>Sun, 12 Jul 2020 23:53:01 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/oo-1-class-object/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/TIEIXm5.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;直覺上你當然知道什麼是物件；物件就在你的身邊。&lt;/p&gt;
&lt;p&gt;汽車、iPhone、收音機、吐司機、廚房用具等等，你說得出來的都是。&lt;/p&gt;
&lt;p&gt;　　——《深入淺出學會編寫程式》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;什麼是物件？一切都是物件；物件是什麼？物件是一切事物的抽象化。&lt;/p&gt;
&lt;p&gt;物件導向試圖讓抽象的程式碼，更貼近於我們的實際生活，其認為一切是由各式各樣的人事物互動所組成的，因此有了物件這個共通、最基本的概念。&lt;/p&gt;
&lt;p&gt;關於把概念抽象化成物件的過程，可以參考 &lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10201905&#34;&gt;一個語言如果不改變你的思考方式，就不值得學？談程式語言的本質&lt;/a&gt; 這篇，對於抽象化的部份我認為描述得很好。&lt;/p&gt;
&lt;p&gt;現在我們知道，物件就是用來表達「我們知道的某個東西」，且可以是「任何東西」，例如說狗就是一個物件，食物也是一個物件。而這些物件之間會彼此互動，例如說狗有吃東西這個&lt;strong&gt;動作&lt;/strong&gt;，我們就能夠試著用物件來表達「狗吃食物」這個動作；同時物件也會有一些專屬於它的&lt;strong&gt;特徵&lt;/strong&gt;，例如說狗可能有名字、毛色等等。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;Dog afu = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Dog(); &lt;span style=&#34;color:#75715e&#34;&gt;// 阿福是一隻狗
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Console.Write(afu.Color); &lt;span style=&#34;color:#75715e&#34;&gt;// 阿福是黑色的
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;afu.Eat(food); &lt;span style=&#34;color:#75715e&#34;&gt;// 阿福會吃食物
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;理解物件的概念是相當直覺且迅速的，畢竟你我身邊有著數不清的東西，它們都是一件一件的物件，但這樣的理解還不夠明確。&lt;/p&gt;
&lt;p&gt;就像前文所引的 &lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10201905&#34;&gt;談程式語言的本質&lt;/a&gt; 文中所提到的，在抽象化的同時我們必然要選擇。&lt;/p&gt;
&lt;p&gt;例如說狗是一個物件；那麼狗擁有的那些東西呢？狗耳朵？狗的聲音？也是物件嗎？狗又能做哪些動作？&lt;/p&gt;
&lt;p&gt;狗是單純一個物件，還是很多個物件組合而成的？狗肺是物件嗎？細胞是物件嗎？我們要做到什麼程度呢？&lt;/p&gt;
&lt;p&gt;我們需要選擇怎麼去描述「狗」，我們需要將它用程式碼的方式定義出來。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我們需要類別&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Dog&lt;/span&gt;
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; color;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Eat(IFood food) { &lt;span style=&#34;color:#75715e&#34;&gt;/* 進食與消化之類的 */&lt;/span&gt; };
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;藉由我們定義的類別，就可以從類別中實例化（＝建立）出物件。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>菜雞與物件導向 (0): 前言</title>
      <link>https://igouist.github.io/post/2020/07/oo-0-object-oriented/</link>
      <pubDate>Sun, 12 Jul 2020 23:53:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/oo-0-object-oriented/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/9UtcyAf.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在訂便當告一段落之後，其實就已經和同事約好要來整理公司新訓的筆記。但儘管已經到職快一年了，有些工具已經在專案碰過好幾次。但遇到需要跟朋友討論，或是聽前輩說明觀念的時候，還是不自主地會想「我真的懂嗎？」故一直是挺畏懼的。&lt;/p&gt;
&lt;p&gt;但幸虧同事的鼓勵和以身作則，最終還是開啟了這個新系列，決定直接開坑把當初前輩新訓指導過的部分整理下來，也算是讓自己能趁著這機會好好複習一番，把自己的想法跟心得記錄下來。&lt;/p&gt;
&lt;p&gt;另外，如果你是真心希望弄懂物件導向的朋友，這邊推薦&lt;a href=&#34;https://www.tenlong.com.tw/products/9789866761799&#34;&gt;《大話設計模式》&lt;/a&gt;的附錄，內容對物件導向的介紹清晰易懂且循序漸進，非常適合作為了解物件導向的起頭。&lt;/p&gt;
&lt;p&gt;本篇的段落將會分成以下幾個部份，由於只是筆記一下，因此會附上一些知識點的參考資料，看見的時候可以先行閱讀；末尾也會附上有關的參考資料及文章，對於這類概念性的東西，一向是推薦多方閱讀以增強理解，就像保哥寫的：「&lt;strong&gt;如果你問 100 個人這個問題，可能會得到 200 個答案，所以你一定要有自己獨到、有自信、精闢的見解或描述方式&lt;/strong&gt;。」如果有寫得不錯的文章想推薦給我，或是有地方需要補充和指證，還請不吝指教。共勉之。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-0-object-oriented&#34;&gt;菜雞與物件導向 (0): 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-1-class-object&#34;&gt;菜雞與物件導向 (1): 類別、物件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-2-constructor-overload&#34;&gt;菜雞與物件導向 (2): 建構式、多載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-3-encapsulation&#34;&gt;菜雞與物件導向 (3): 封裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-4-inheritance&#34;&gt;菜雞與物件導向 (4): 繼承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-5-polymorphism&#34;&gt;菜雞與物件導向 (5): 多型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-6-abstract-override&#34;&gt;菜雞與物件導向 (6): 抽象、覆寫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/07/oo-7-interface&#34;&gt;菜雞與物件導向 (7): 介面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling&#34;&gt;菜雞與物件導向 (8): 內聚、耦合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/09/oo-9-solid&#34;&gt;菜雞與物件導向 (9): SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle&#34;&gt;菜雞與物件導向 (10): 單一職責原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/10/oo-11-open-closed-principle&#34;&gt;菜雞與物件導向 (11): 開放封閉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-12-liskov-substitution-principle&#34;&gt;菜雞與物件導向 (12): 里氏替換原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/11/oo-13-interface-segregation-principle&#34;&gt;菜雞與物件導向 (13): 介面隔離原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle&#34;&gt;菜雞與物件導向 (14): 依賴反轉原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2020/12/oo-15-least-knowledge-principle&#34;&gt;菜雞與物件導向 (15): 最少知識原則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://igouist.github.io/post/2021/01/oo-ex1-end2020&#34;&gt;菜雞與物件導向 (Ex1): 小結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>AutoMapper —— 類別轉換超省力</title>
      <link>https://igouist.github.io/post/2020/07/automapper/</link>
      <pubDate>Sun, 05 Jul 2020 23:40:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/07/automapper/</guid>
      <description>&lt;p&gt;類別間的轉換幾乎是每個專案每個工程師都會碰到的動作，舉凡是分層架構每層之間的轉換，如 Dto 轉換成 ViewModel；或是接收到資料要塞進自定義的類別時也需要進行轉換。但&lt;strong&gt;在遠古時代，當我們要把一個類別的資料倒進另一個類別時，總免不了一番折騰&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如一個卡片對戰遊戲的資料庫，光是要先把卡片資料讀取出來就需要：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/c81Hx5I.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;有些時候也會看見用 Foreach 然後逐一傳值的場景，或是各種差不多的變種情況。同樣的是，光是將一個簡單的卡片資訊轉換成 ViewModel，就花了一大段在做對映的處理。這個過程本身枯燥乏味又占空間，更可怕的是，&lt;strong&gt;如果有個陳年資料表，動不動就上百個欄位，那這個轉換過程的恐怖程度可想而知&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;幸好！天無絕人之路，這種時候就是本日的主角 —— AutoMapper 出場的時候了。&lt;/p&gt;
&lt;p&gt;當 AutoMapper 一出手，轉換的過程瞬間就變成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/KxHAKpi.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;是不是精簡很多呢？接著就讓我們來看看怎麼開始使用吧！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Visual studio 環境設定 —— 字型、套件、快捷鍵</title>
      <link>https://igouist.github.io/post/2020/03/visualstudio/</link>
      <pubDate>Sat, 28 Mar 2020 00:11:00 +0800</pubDate>
      
      <guid>https://igouist.github.io/post/2020/03/visualstudio/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;目標：整理一下自己用的&lt;strong&gt;字型、插件和快捷鍵&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天在工作時寫到一半突然藍屏，重開機之後俺的地表最強編譯器 Visual Studio 整個就開始鬧脾氣，打開專案整排都是 Error，連 System.Object 都找不到，差點往生。還好用了修復功能之後一切恢復正常，但是載入的插件和一些個人設定就這樣重置了……&lt;/p&gt;
&lt;p&gt;為了之後可能還會遇到相同的事情，這邊就先將平常的 Visual Studio 環境用到的設定做一份紀錄，之後遇到新插件或是什麼功能也可以回來更新這篇文，如此一來下次又被洗白的時候就可以回來參考了。&lt;/p&gt;
&lt;p&gt;這邊主要會記錄三個部分，並隨時可能更新。主要是字型、使用的插件以及常用的快捷鍵。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;不過我的 Visual Studio 也被洗白了所以這篇會跟著找回失落插件的歷程慢慢補上QQ&lt;/del&gt;&lt;/p&gt;
&lt;h2 id=&#34;字型&#34;&gt;字型&lt;/h2&gt;
&lt;p&gt;字型部分必定、絕對要使用&lt;strong&gt;等寬字型&lt;/strong&gt;，這是必要的前提也是絕對的共識，畢竟你不會希望有什麼神秘空白，或是推個版就排版大炸裂之類的。&lt;/p&gt;
&lt;p&gt;推薦先參閱 &lt;a href=&#34;https://kevintsengtw.blogspot.com/2014/08/blog-post.html&#34;&gt;換個好字型讓程式開發有效率&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(2021/1/27) 補充：字型也可以看 &lt;a href=&#34;https://devfonts.gafi.dev/&#34;&gt;devfonts&lt;/a&gt; 。裡面直接放了超多 Coding 常用字型，也可以貼上 Code 直接進行比較，相當貼心。想逛一下挑個順眼字型的朋友直接試試唄。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;consolas&#34;&gt;Consolas&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/az9u0B3.png&#34; alt=&#34;&#34;&gt;
內建就有的字體，個人認為在不想另外下載字體的時候是相當優質的選擇。&lt;/p&gt;
&lt;p&gt;看起來粗粗圓圓的很放鬆。&lt;/p&gt;
&lt;h3 id=&#34;firacode&#34;&gt;FiraCode&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/9OJpMXL.png&#34; alt=&#34;&#34;&gt;
&lt;a href=&#34;https://github.com/tonsky/FiraCode&#34;&gt;FiraCode&lt;/a&gt;，整體看起來就是乾淨優雅，尤其是連字能使得整個 Code 更有滑順的感覺，十分推薦。&lt;/p&gt;
&lt;p&gt;然而，FiraCode 雖然陪伴我一段不短的時間，但還是有一個致命的缺陷：不支援中文！&lt;/p&gt;
&lt;p&gt;於是後來我基本上都使用下面介紹的這款&lt;/p&gt;
&lt;h3 id=&#34;更紗黑體&#34;&gt;更紗黑體&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/yVMe5wC.png&#34; alt=&#34;&#34;&gt;
&lt;a href=&#34;https://github.com/be5invis/Sarasa-Gothic&#34;&gt;更紗黑體&lt;/a&gt; 除了同樣支援連字以外，更支援多國語系。例如繁中就是有標註 TC 的字形，看見中英文都套用上去就是一陣舒服。是現在我的主力。&lt;/p&gt;
&lt;p&gt;至於不想用等寬字體的朋友，都看到這裡了，沒關係。下面這套推薦給你們&lt;/p&gt;
&lt;h3 id=&#34;ink-free&#34;&gt;Ink Free&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/EShjvS5.png&#34; alt=&#34;&#34;&gt;
就是這麼直接！這麼舒服！如果你的同事要過來 Code Review，不要猶豫字體直接換下去！&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
