<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Service-Bus on 伊果的沒人看筆記本</title>
    <link>https://igouist.github.io/tags/service-bus/</link>
    <description>Recent content in Service-Bus on 伊果的沒人看筆記本</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hant-TW</language>
    <managingEditor>Igouist (Igouist)</managingEditor>
    <webMaster>Igouist (Igouist)</webMaster>
    <follow_challenge>
      <feedId>56200764111934464</feedId>
      <userId>41821085092905984</userId>
    </follow_challenge>
    <lastBuildDate>Sat, 27 Aug 2022 10:09:00 +0800</lastBuildDate><atom:link href="https://igouist.github.io/tags/service-bus/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>菜雞抓蟲：Azure Functions ServiceBus Trigger 執行過久時會重複觸發 Functions</title>
      <link>https://igouist.github.io/post/2022/08/azure-function-servicebus-trigger-max-auto-renew-duration/</link>
      <pubDate>Sat, 27 Aug 2022 10:09:00 +0800</pubDate>
      <author>Igouist (Igouist)</author>
      <guid>https://igouist.github.io/post/2022/08/azure-function-servicebus-trigger-max-auto-renew-duration/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/00WQGqR.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;tldr&#34;&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;當發現&lt;strong&gt;需要執行很久的 ServiceBus Trigger Function 有重複執行的情況&lt;/strong&gt;出現時，可以嘗試到&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/azure-functions/functions-bindings-service-bus?tabs=in-process%2Cextensionv5%2Cextensionv3&amp;amp;pivots=programming-language-csharp#hostjson-settings&#34;&gt;官方的 Host.json 設定指引&lt;/a&gt;，按照 SDK 版本找到對應的「&lt;strong&gt;訊息鎖定最大持續時間&lt;/strong&gt;」設定，例如 maxAutoLockRenewalDuration（延伸模組 5.x+）或 maxAutoRenewDuration（Functions 2.x），並加入專案的 Host.json&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因為 ServiceBus 在傳遞訊息之後，如果超過一段時間（MaxAutoRenewDuration）內沒有得到回應，就會解除信件的鎖並嘗試重新傳遞&lt;/strong&gt;，這時候如果原先的 Function 仍在執行，就會一前一後重複執行 Function 並發生許多光怪陸離的事，例如寫入兩筆資訊、重複複製資料之類的。&lt;/p&gt;
&lt;p&gt;建議如果調整了有 ServiceBus Trigger Function 的 Azure Functions Timeout 設定時，或是發現某支 ServiceBus Trigger 的 Functions 執行時間過長，就要一併注意 MaxAutoRenewDuration 的設定，避免重複執行的情況出現。&lt;/p&gt;
&lt;h2 id=&#34;事發原由&#34;&gt;事發原由&lt;/h2&gt;
&lt;p&gt;工作時將一段需要呼叫其他 API、執行相當久的程式片段搬上 &lt;a href=&#34;https://igouist.github.io/post/2022/09/bus-reminder-2-azure-functions-timetrigger-with-line-notify/&#34;&gt;Azure Functions&lt;/a&gt;，並使用 &lt;a href=&#34;https://igouist.github.io/post/2022/08/azure-service-bus&#34;&gt;Service Bus&lt;/a&gt; 來傳遞訊息觸發 Functions 執行，這時卻發現 &lt;strong&gt;Function 被執行了兩次&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;現在就讓我們來重建當時的情況吧。首先我們有個 Service Bus Trigger 的 Azure Function，這邊就直接從 Visual Studio 提供的&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/azure-functions/dotnet-isolated-process-guide&#34;&gt;已隔離（Isolated）&lt;/a&gt;範本進行建立。&lt;/p&gt;
&lt;p&gt;為了重現執行很久的特點，我們讓它 Delay 個八分鐘，並在開始和結束的時候告訴我們一下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// ServiceBus Trigger 測試用 Function&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;param name=&amp;#34;myQueueItem&amp;#34;&amp;gt;My queue item.&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[Function(&amp;#34;ServiceBusTriggerSample&amp;#34;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task Run(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;    [ServiceBusTrigger(
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;        queueName: &amp;#34;%QueueName%&amp;#34;,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;        Connection = &amp;#34;ServiceBus&amp;#34;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; myQueueItem)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    _logger.LogInformation(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;開始處理訊息: {myQueueItem}&amp;#34;&lt;/span&gt;, myQueueItem);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; Task.Delay(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; TimeSpan(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    _logger.LogInformation(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;結束處理訊息: {myQueueItem}&amp;#34;&lt;/span&gt;, myQueueItem);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;並且簡單地用之前 &lt;a href=&#34;https://igouist.github.io/post/2022/08/azure-service-bus&#34;&gt;Service Bus 文章&lt;/a&gt; 的範例送個 &amp;ldquo;Hello&amp;rdquo; 進去 Queue 裡，準備觸發 Function：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task Main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; context = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello!&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var client = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ServiceBusClient(_connectionString);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var sender = client.CreateSender(_queueName);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ServiceBusMessage(context);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; sender.SendMessageAsync(message);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 Function 接收到訊息後，讓我們觀察 Console：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/dBFWz2p.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以發現第一次執行尚未結束的時候，大概經過五分鐘就又執行了第二次！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;調整訊息鎖定最大持續時間&#34;&gt;調整訊息鎖定最大持續時間&lt;/h2&gt;
&lt;p&gt;原先以為是 Function 執行失敗導致 ServiceBus 重新傳遞之類的狀況，但找了老半天沒有頭緒，嘗試了調整一些設定也沒有起色，陷入了深深的混亂&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/UY3EhoA.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;幸好天無絕人之路，最終在 &lt;a href=&#34;https://stackoverflow.com/questions/62752905/azure-function-service-bus-trigger-running-multiple-times&#34;&gt;Stackoverflow&lt;/a&gt; 海巡的時候了發現一線生機！&lt;/p&gt;
&lt;p&gt;原來 Azure Functions 的 Service Bus Trigger 有個「&lt;strong&gt;訊息鎖定最大持續時間&lt;/strong&gt;」設定！&lt;/p&gt;
&lt;p&gt;當 Service Bus 傳遞訊息到 Function 的時候，Function 會根據執行結果告訴 Service Bus 該訊息要標記成功或是失敗；但如果訊息就這麼一去不回時，Service Bus 會先觀望一下，&lt;strong&gt;直到超過了「訊息鎖定最大持續時間」就會下令解除訊息的鎖定，嘗試重新傳遞&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這次的事件就是因為我們即使調長了 Timeout 時間，但當該 Function 執行超過預設的鎖定時間（五分鐘）時，Service Bus 再度傳遞了訊息，才導致 Function 重複被執行而造成各種奇怪的資料錯誤&lt;/p&gt;
&lt;p&gt;那麼這個「訊息鎖定最大持續時間」怎麼設定呢？我們可以參照&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/azure-functions/functions-bindings-service-bus?tabs=in-process%2Cextensionv5%2Cextensionv3&amp;amp;pivots=programming-language-csharp#hostjson-settings&#34;&gt;官方的 Host.json 設定指引&lt;/a&gt;，按照 SDK 版本找到對應的「訊息鎖定最大持續時間」設定，例如 maxAutoLockRenewalDuration（延伸模組 5.x+）或 maxAutoRenewDuration（Functions 2.x），並加入專案的 Host.json。&lt;/p&gt;
&lt;p&gt;現在讓我們在範例專案加入 maxAutoRenewDuration 的設定，這邊就改成比前面的執行時間八分鐘更長的十分鐘：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/TTpXELd.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;接著再重新傳遞一次訊息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/2epGiF9.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到過程中沒有重新傳遞訊息了，大功告成！&lt;/p&gt;
&lt;p&gt;總之，學到了調整 ServiceBus Trigger Function 的 Azure Functions Timeout 設定時，或是發現某支 ServiceBus Trigger 的 Functions 執行時間過長，就要一併注意 MaxAutoRenewDuration 的設定，避免重複執行。&lt;/p&gt;
&lt;p&gt;如此如此，這般這般，一天又平安的過去了，感謝 Stackoverflow 大大們的努力。&lt;/p&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/62752905/azure-function-service-bus-trigger-running-multiple-times&#34;&gt;Azure function service bus trigger running multiple times - Stockoverflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/azure-functions/functions-bindings-service-bus?tabs=in-process%2Cfunctionsv2%2Cextensionv3&amp;amp;pivots=programming-language-csharp#hostjson-settings&#34;&gt;Azure Functions 的 Azure 服務匯流排繫結 | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>使用 Azure Service Bus 來建立簡單的訊息佇列（Message Queue）吧</title>
      <link>https://igouist.github.io/post/2022/08/azure-service-bus/</link>
      <pubDate>Sat, 13 Aug 2022 16:50:00 +0800</pubDate>
      <author>Igouist (Igouist)</author>
      <guid>https://igouist.github.io/post/2022/08/azure-service-bus/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/5Vube9E.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;在工作上遇到在兩個 Azure 工具間建立訊息佇列（Message Queue）的需求，因此接觸到了 Azure Service Bus（中文：服務匯流排 &lt;del&gt;燴牛排？&lt;/del&gt;），在前輩的協助下建立了一組簡單的 Demo，這就來筆記一下。&lt;/p&gt;
&lt;h2 id=&#34;什麼是訊息佇列message-queue-mq&#34;&gt;什麼是訊息佇列（Message Queue, MQ）&lt;/h2&gt;
&lt;p&gt;首先讓我們簡單認識一下訊息佇列。假設我們有生產者和消費者兩個服務，其中&lt;strong&gt;生產者負責產生資料，而消費者負責消費這些資料&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/mg4lXJk.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;各位也可以這樣理解：生產者就像是壽司師傅，他會不斷的捏壽司出來；而這時候來了一位大胃王顧客，他就是消費者，會不斷地把壽司吃掉&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/Sk16WdC.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;大概對這兩個角色有點認識就行了。那麼，假設我們有兩組 API 服務：其中一個是負責寫入 Log 的服務，而另一個是產品服務。&lt;/p&gt;
&lt;p&gt;產品服務會將 Log 內容丟給 Log 服務去紀錄 Log，這時候產生了這些日誌資料的產品服務就是生產者，而消費這些日誌資料去寫 Log 的服務就是消費者。&lt;/p&gt;
&lt;p&gt;也就是：&lt;strong&gt;&lt;code&gt;產品服務（生產者） —— 資料 —&amp;gt; Log 服務（消費者）&lt;/code&gt;&lt;/strong&gt; 這樣的狀況。&lt;/p&gt;
&lt;p&gt;然而像這樣&lt;strong&gt;直接相依的兩個服務，可能就會遇到一些問題：像是消費者突然掛掉，導致生產者也跟著掛掉；又或是消費者的變動和擴展會連帶影響到生產者必須跟著變動等等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;這樣說可能有些模糊。就以上面提到的 Log 服務來說，在直接呼叫 API 的情況下，我們常常會需要在產品服務中直接明確寫出 Log 服務的資訊，像是站台位址、API 路由之類的。&lt;/p&gt;
&lt;p&gt;但當 Log 服務的站台或方法有變動，我們就被迫要修改產品服務對應的程式碼；而如果我們今天想要擴展 Log 服務的站台，就會需要修改產品服務裡關於 Log 服務的資訊。&lt;/p&gt;
&lt;p&gt;而今天如果 Log 服務短暫掛掉了，可能就會連帶讓我們的產品服務一起掛掉，就算有進行簡單的錯誤處理，當時該記的 Log 內容也就遺失了。&lt;/p&gt;
&lt;p&gt;那面對這些問題的時候怎麼辦呢？這時候我們就可以&lt;strong&gt;在中間加一條佇列&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/zrgm8JC.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;用前面的壽司店來說就是這樣（很堅持要用壽司舉例）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/J6aksgo.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;我們加入訊息佇列之後得到的好處有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;解除耦合&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;生產者不需要知道消費者的資訊，消費者的變動也不會直接影響到生產者&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高擴展性&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;即使我們要增加消費者的數量，變成三個消費者來處理這些資料，也只要讓佇列處理轉發就好，而不用影響生產者&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非同步&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;生產者現在只要把訊息丟到佇列就可以回頭繼續做自己的事了，不用管也不用等待消費者處理這些訊息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;緩衝&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;佇列讓消費者多了一段緩衝區，即使消費者忙不過來，也有佇列可以讓訊息好好排隊&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外還可以玩一些花式處理，例如藉由佇列來做到限制流量等等，此處先按下不表。&lt;/p&gt;
&lt;p&gt;現在我們大概知道訊息佇列在幹嘛了。接著就讓我們來玩玩 Azure Service Bus 這個訊息佇列服務吧！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;想更了解 Message Queue 的朋友，也可以閱讀以下的參考資料呦：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/starbugs/%E8%AE%93%E4%BB%BB%E5%8B%99%E6%8E%92%E9%9A%8A%E5%90%A7-message-queue-1-de949e274c43&#34;&gt;[基礎觀念系列] 讓任務排隊吧：Message Queue — (1) - 莫力全 Kyle Mo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;amp;mid=2247485080&amp;amp;idx=1&amp;amp;sn=f223feb9256727bde4387d918519766b&#34;&gt;什么是消息队列？ - Java3y (qq.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ningg.top/message-queue-intro/&#34;&gt;消息队列（Message Queue）基本概念 | NingG 个人博客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10238631&#34;&gt;Message Queue - (1) - iT 邦幫忙 (ithome.com.tw)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10209296&#34;&gt;Producer Consumer 模式 - iT 邦幫忙 (ithome.com.tw)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/tw/message-queue/&#34;&gt;什麼是訊息佇列？ (amazon.com)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;建立-azure-service-bus-資源&#34;&gt;建立 Azure Service Bus 資源&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;小提示：Azure Service Bus 是一項收費服務，你可能會想先了解&lt;a href=&#34;https://azure.microsoft.com/zh-tw/pricing/details/service-bus/&#34;&gt;定價&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;首先讓我們先到 &lt;a href=&#34;https://portal.azure.com/#home&#34;&gt;Azure&lt;/a&gt;，建立一個新的資源：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/s0klgGc.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;找到 Service Bus 並新建它：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/ngSiiJm.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/2TepYi8.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;接著選擇要掛資源的帳戶和群組後，替我們的 Service Bus 取個好記的名字。&lt;/p&gt;
&lt;p&gt;這邊示範的方案當然就直接選最便宜的 XD&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/6N744Nr.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;除了基本設定以外，這邊還能變更最低 TLS 版本（維護老舊專案者注意，或是準備&lt;a href=&#34;https://blog.darkthread.net/blog/net35-tls12-issue/&#34;&gt;踩雷&lt;/a&gt;）等等，可以頁籤都戳一戳。&lt;/p&gt;
&lt;p&gt;確認之後就可以勇敢按下「審核 + 建立」囉！&lt;/p&gt;
&lt;p&gt;按下後會部署個幾分鐘，部屬完畢之後就可以直接前往資源：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/oPmqwpi.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;抵達我們的 Service Bus 資源頁面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/CvH4MgL.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;這樣我們就成功建立 Service Bus 啦！&lt;/p&gt;
&lt;h2 id=&#34;建立佇列queue&#34;&gt;建立佇列（Queue）&lt;/h2&gt;
&lt;p&gt;接著就讓我們來建立一條佇列吧，首先讓我們再看一眼微軟把拔提供的佇列概念圖：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/Oi1GOqz.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;回到 Azure 的 Service Bus 資源頁面，讓我們在畫面上點選建立佇列：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/lwNmNQR.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;並且取個好名字，等等發訊息的時候會用到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/6ONWYWT.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這邊會需要注意一下「最大傳遞計數」（Maximum Delivery Count），簡單來說就是這封訊息會嘗試傳遞幾次，如果超過次數都沒有傳遞成功就會被丟到無效信件。可以參閱&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/service-bus-messaging/service-bus-dead-letter-queues#maximum-delivery-count&#34;&gt;服務匯流排寄不出的信件佇列的概觀&lt;/a&gt;中的「最大傳遞計數」小節&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;這篇我們不會用到下面選項的&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/service-bus-messaging/service-bus-partitioning&#34;&gt;資料分割&lt;/a&gt;、到期自動轉&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/service-bus-messaging/service-bus-dead-letter-queues&#34;&gt;無效信件&lt;/a&gt;等功能，有興趣的朋友可以再自己研究一下呦～&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;建立完就會出現在我們 Service Bus 的頁面下方囉：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/Jbzbei8.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;取得-servicebus-的連線字串&#34;&gt;取得 ServiceBus 的連線字串&lt;/h2&gt;
&lt;p&gt;接著為了讓我們後續可以順利連線，先到左邊的 &lt;strong&gt;「設定 &amp;gt; 共用存取原則」拿到我們的連線字串&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/zYkN3cQ.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;這邊直接使用預設的原則，如果有需要控管不同使用者的權限，例如說某組連線字串只能接收或讀取等等，也可以在這邊新增原則來管理。&lt;/p&gt;
&lt;h2 id=&#34;將訊息放入佇列&#34;&gt;將訊息放入佇列&lt;/h2&gt;
&lt;p&gt;現在 Queue 已經建立起來了，接著就是要嘗試把訊息丟到 Queue 裡面囉！&lt;/p&gt;
&lt;p&gt;為了方便測試，這邊就採用 Visual Studio 內建的 API 樣板，直接在 Controller 簡單建立一個範例，要實際應用在專案中的朋友請再依據專案架構自行調整。&lt;/p&gt;
&lt;p&gt;那麼就讓我們開始吧，首先我們會需要安裝 &lt;strong&gt;Azure.Messaging.ServiceBus&lt;/strong&gt; 這個套件包：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/zXuFLdw.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;接著是我們本次的範例用 Controller，以及尚未實作傳送訊息的 Function：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// Service Bus Queue 示範用 Controller&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[ApiController]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[Route(&amp;#34;[controller]&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;)]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;QueueController&lt;/span&gt; : ControllerBase
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/// 將訊息放入佇列&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;    [HttpPost]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task Enqueue([FromBody] &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; context)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 我們要在這裡實作傳送訊息到 Queue 的方法&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;傳送一則訊息到佇列&#34;&gt;傳送一則訊息到佇列&lt;/h3&gt;
&lt;p&gt;接著讓我們來傳送訊息吧，這邊會需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用 ServiceBus 的連線字串建立 &lt;code&gt;ServiceBusClient&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用 Queue 的名稱，從 &lt;code&gt;ServiceBusClient&lt;/code&gt; 建立 &lt;code&gt;ServiceBusSender&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;ServiceBusSender&lt;/code&gt; 來傳送訊息到 Queue&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// 將訊息放入佇列&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[HttpPost]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task Enqueue([FromBody] &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; context)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 用 ServiceBus 的連線字串建立 Client&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 連線字串可以在 Azure ServiceBus 頁面的共用存取原則找到&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ServiceBusClient 用完記得要呼叫 DisposeAsync() 來關掉&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 或是直接使用 await using 包起來&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; connectionString = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR SERVICE BUS CONNECTION STRING&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var client = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ServiceBusClient(connectionString);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 傳遞 Queue 的名字給 CreateSender 方法來建立 Sender&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 和 ServiceBusClient 一樣，有提供 DisposeAsync 方法來關閉&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 或是直接使用 await using 包起來&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; queueName = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR QUEUE NAME&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var sender = client.CreateSender(queueName);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 將要傳送的訊息包裝成 ServiceBusMessage&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 並使用 ServiceBusSender.SendMessageAsync 傳送出去&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ServiceBusMessage(context);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; sender.SendMessageAsync(message);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;提醒一下將來會跑回來複製貼上的我和各位朋朋：記得把連線字串跟佇列名稱改成你的！&lt;/p&gt;
&lt;p&gt;現在讓我們來呼叫ＡＰＩ，丟個 &lt;code&gt;&amp;quot;Hello&amp;quot;&lt;/code&gt; 進去試試：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/ioXGear.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;接著到 Azure Service Bus 的 Queue 介面瞧瞧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/1zTEnWt.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;Queue 也確實收到一則訊息了，看來我們成功把 Hello 丟進去啦！&lt;/p&gt;
&lt;h3 id=&#34;傳送一批訊息到佇列&#34;&gt;傳送一批訊息到佇列&lt;/h3&gt;
&lt;p&gt;當然在實務上，我們有時候會想要傳一卡車的訊息；例如我們剛處理完一批客戶，想把它們丟到佇列去讓另一個服務做點事，這時候如果還得一封一封塞訊息就有點怪怪的。&lt;/p&gt;
&lt;p&gt;雖然我們可以直接粗暴地把 Sender 的 &lt;code&gt;SendMessageAsync&lt;/code&gt; 加個 &lt;code&gt;s&lt;/code&gt; 變成 &lt;code&gt;SendMessagesAsync&lt;/code&gt;，這樣它就能接收串列的 &lt;code&gt;IEnumerable&amp;lt;ServiceBusMessage&amp;gt;&lt;/code&gt; 了（真貼心啊 Azure）&lt;/p&gt;
&lt;p&gt;不過，我們還可以選擇使用 &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/api/azure.messaging.servicebus.servicebusmessagebatch&#34;&gt;ServiceBusMessageBatch&lt;/a&gt; 這個工具來幫我們一次發他個一批訊息。&lt;/p&gt;
&lt;p&gt;這邊也示範一下。&lt;del&gt;讓我之後可以回來抄&lt;/del&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// 將一堆訊息放入佇列&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;param name=&amp;#34;context&amp;#34;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[HttpPost(&amp;#34;Batch&amp;#34;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task EnqueueBatch([FromBody] &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; context)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 把訊息重複個十次，假裝我們有很多訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; contexts = Enumerable.Repeat(context, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 和單則訊息的場合一樣：先建立 Client 及 Sender&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; connectionString = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR SERVICE BUS CONNECTION STRING&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var client = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ServiceBusClient(connectionString);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; queueName = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR QUEUE NAME&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var sender = client.CreateSender(queueName);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 從 Sender 來建立一批訊息（類似郵差包的感覺）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var messageBatch = &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; sender.CreateMessageBatchAsync();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 將訊息逐一嘗試放到這批訊息中（把信塞到郵差包的感覺）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;foreach&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; text &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; contexts)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ServiceBusMessage(text);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (messageBatch.TryAddMessage(message) &lt;span style=&#34;color:#66d9ef&#34;&gt;is&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Exception(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;放入訊息失敗&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 把整個郵差包丟出去&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; sender.SendMessagesAsync(messageBatch);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;直接多十條訊息，看起來沒問題：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/iZxuUqu.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;傳送物件到佇列&#34;&gt;傳送物件到佇列&lt;/h3&gt;
&lt;p&gt;Ｑ：我要傳的東西不是 string 而是物件怎麼辦？&lt;/p&gt;
&lt;p&gt;Ａ：山不轉路轉，就用 &lt;code&gt;JsonSerializer.Serialize&lt;/code&gt; 轉成 Json 再傳。&lt;/p&gt;
&lt;p&gt;好的結案。&lt;/p&gt;
&lt;h2 id=&#34;從佇列取出訊息&#34;&gt;從佇列取出訊息&lt;/h2&gt;
&lt;p&gt;現在我們已經可以把訊息丟到 Queue 中了，接下來當然就是要拿出來囉！&lt;/p&gt;
&lt;p&gt;拿出來的時候也有幾個不同的姿勢，接著就讓我們一一介紹下：&lt;/p&gt;
&lt;h3 id=&#34;從佇列中讀取一則訊息&#34;&gt;從佇列中讀取一則訊息&lt;/h3&gt;
&lt;p&gt;就像我們要寫入訊息的時候，要從 &lt;code&gt;ServiceBusClient&lt;/code&gt; 建立一個 &lt;code&gt;ServiceBusSender&lt;/code&gt; 一樣，當我們要寄送訊息的時候，也要從 &lt;code&gt;ServiceBusClient&lt;/code&gt; 建立一個 &lt;code&gt;ServiceBusReceiver&lt;/code&gt; 來幫我們處理訊息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// 取出佇列中的單則訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[HttpGet(&amp;#34;Receive&amp;#34;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task&amp;lt;&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;&amp;gt; Receive()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 和發送訊息的場合差不多：先建立 Client 及 Receiver&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; connectionString = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR SERVICE BUS CONNECTION STRING&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var client = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ServiceBusClient(connectionString);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 和前面的 ServiceBusSender 一樣，有提供 DisposeAsync 方法讓我們用完時關閉&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 或是直接使用 await using 包起來&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; queueName = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR QUEUE NAME&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var receiver = client.CreateReceiver(queueName);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 使用 ReceiveMessageAsync 來把訊息讀取出來&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; receiver.ReceiveMessageAsync();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; body = message.Body.ToString();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 告訴 Service Bus 這個訊息有成功處理了&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; receiver.CompleteMessageAsync(message);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; body;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;過程相當的簡單，只需要叫 &lt;code&gt;ServiceBusReceiver&lt;/code&gt; 幫忙拿出來就好。現在讓我們呼叫試試：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/H9v2PdJ.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;成功取得我們前面放進去的訊息囉！&lt;/p&gt;
&lt;h3 id=&#34;從佇列中持續讀取訊息&#34;&gt;從佇列中持續讀取訊息&lt;/h3&gt;
&lt;p&gt;前面提到的 &lt;code&gt;ServiceBusReceiver&lt;/code&gt; 可以從佇列中取出一則訊息，但大多時候訊息的接收方是被動的，也就說接收方其實並不知道發送方傳訊息了沒、現在有沒有訊息，更不用說主動去取出訊息了。&lt;/p&gt;
&lt;p&gt;因此通常的作法是採用被動接收訊息再進行處理的方式：&lt;strong&gt;事先註冊好處理訊息的事件，當有訊息進來的時候就按照指示去進行處理&lt;/strong&gt;，這時候我們就會需要用到 &lt;code&gt;ServiceBusProcessor&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;並且當 &lt;code&gt;ServiceBusProcessor&lt;/code&gt; 建立之後，我們會需要告訴他兩件事：我們想怎麼處理訊息、出錯的時候該怎麼辦。&lt;/p&gt;
&lt;p&gt;這些都設定完之後，&lt;code&gt;ServiceBusProcessor&lt;/code&gt; 就會上工站崗。只要有訊息進來，它就會按照我們給的小抄去執行&lt;/p&gt;
&lt;p&gt;整理一下，我們接收 Service Queue 的訊息時會需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用 ServiceBus 的連線字串建立 &lt;code&gt;ServiceBusClient&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用 Queue 的名稱，從 &lt;code&gt;ServiceBusClient&lt;/code&gt; 建立 &lt;code&gt;ServiceBusProcessor&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;設定接收到訊息之後的處理方式 &lt;code&gt;ProcessMessageAsync&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;設定出錯時的處理方式 &lt;code&gt;ProcessErrorAsync&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;讓 &lt;code&gt;ServiceBusProcessor&lt;/code&gt; 持續接收訊息&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// 取出佇列中的訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task Dequeue()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 和發送訊息的場合差不多：先建立 Client 及 Processor&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; connectionString = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR SERVICE BUS CONNECTION STRING&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var client = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ServiceBusClient(connectionString);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 和前面的 ServiceBusSender 一樣，有提供 DisposeAsync 方法讓我們用完時關閉&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 或是直接使用 await using 包起來&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; queueName = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR QUEUE NAME&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var processor = client.CreateProcessor(queueName);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 告訴 Processor 我們想怎麼處理訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    processor.ProcessMessageAsync += MessageHandler;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    processor.ProcessErrorAsync += ErrorHandler;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 讓 Processor 上工，開始接收訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; processor.StartProcessingAsync();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 實際上會掛著讓 processor 一直處理送來的訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 這邊示範而已就意思意思跑個一下下&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; Task.Delay(&lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 讓 Processor 下班休息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; processor.StopProcessingAsync();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// 處理佇列訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task MessageHandler(ProcessMessageEventArgs args)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 從訊息的 Body 取出我們發送時塞進去的內容&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = args.Message.Body.ToString();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 對訊息內容做你想做的事&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 這邊就印出來看個一眼意思意思&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Console.WriteLine(message);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 告訴 Service Bus 這個訊息有成功處理了&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; args.CompleteMessageAsync(args.Message);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// 處理佇列錯誤訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task ErrorHandler(ProcessErrorEventArgs args)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 從訊息中取出錯誤訊息$$&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; exception = args.Exception.ToString();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 對訊息做一些錯誤處理，例如存到日誌系統之類的&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 這邊也印出來看個一眼意思意思&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Console.WriteLine(exception);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接著就讓我們呼叫看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/hKoP1bD.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看見我們確實收到了前面發送的「Hello」，接收大成功！&lt;/p&gt;
&lt;h3 id=&#34;補充在-servicebus-explorer-確認訊息&#34;&gt;補充：在 ServiceBus Explorer 確認訊息&lt;/h3&gt;
&lt;p&gt;除了直接在程式中接收訊息以外，我們在 Azure 的頁面上其實也能確認傳遞中的訊息內容。&lt;/p&gt;
&lt;p&gt;首先到佇列左側的列表找到「&lt;strong&gt;Service Bus Explorer&lt;/strong&gt;」，就可以確認目前佇列和無效信件中的訊息數量。&lt;/p&gt;
&lt;p&gt;點下從頭查看後，就可以看見訊息列表的內容，並點擊訊息查看本文和屬性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/Uy6MDui.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;在找問題的時候還蠻好用，想確認訊息內容的時候可以試試。&lt;/p&gt;
&lt;h2 id=&#34;建立主題topic&#34;&gt;建立主題（Topic）&lt;/h2&gt;
&lt;p&gt;除了佇列（Queue）以外，Service Bus 還提供了另一種傳輸模式：主題（Topic）&lt;/p&gt;
&lt;p&gt;讓我們看一下微軟把拔提供的主題概念圖，可以和前面佇列的圖做一下比較：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/9DwGFgL.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;簡單來說就是傳送出去之後，會有&lt;strong&gt;多個接收者&lt;/strong&gt;等著收訊息。&lt;/p&gt;
&lt;p&gt;現在就讓我們回到 Azure Service Bus 的頁面，點選上方的「＋主題」來建立新主題吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/pHdPOvz.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小提示：主題（Topic）是標準定價層才提供的功能。如果是使用最便宜的基本定價層的朋友，「＋主題」的按鈕應該會反灰的，這時候就要需要從 Service Bus 概觀頁面的「定價層」變更到標準（Standard）才能建立主題。&lt;/p&gt;
&lt;p&gt;當然不同定價層的價格也會不一樣，要記得確認一下價格呦！&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;接著就和前面的佇列一樣取個好名字：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/r51t3f8.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;建立完就會出現在我們的 ServiceBus 服務中囉：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/kF998IO.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;和單純一對一的佇列不一樣，我們還會需要替主題建立訂用帳戶（Subscriptions）&lt;/strong&gt;，這樣主題才知道它到底要把訊息送給哪些對象。&lt;/p&gt;
&lt;p&gt;現在讓我們進入主題的頁面，並找到訂用帳戶：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/vNJpXfl.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;進去之後讓我們來新增訂用帳戶：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/wRUeMO2.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;首先當然是要取個好名字，這邊就先用 Sub1 來當作一號訂閱者的暱稱吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/rQvOrlM.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這邊和佇列的時候一樣，要注意「最大傳遞計數」（Maximum Delivery Count），簡單來說就是這封訊息會嘗試傳遞幾次，如果超過次數都沒有傳遞成功就會被丟到無效信件。可以參閱 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/service-bus-messaging/service-bus-dead-letter-queues#maximum-delivery-count&#34;&gt;服務匯流排寄不出的信件佇列的概觀&lt;/a&gt;。&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;另一個要注意的部份是「啟用工作階段」（Session）：簡單來說就是保證訊息的先進先出（FIFO），藉由在訊息中傳遞 SessionID，然後根據訊息的 SessionID 和接收者建立連線之後發送，讓同個工作階段的訊息按照順序發送到同個對象進行處理。&lt;/p&gt;
&lt;p&gt;這功能在佇列和主題都可以使用，但要定價層在標準和以上才支援。當你有多台機器在接收訊息時會對工作階段比較有感覺（例如說 SessionID 寫死然後開了很多台來處理訊息，結果因為工作階段會全部卡在同一台囧）&lt;/p&gt;
&lt;p&gt;詳細可以參閱 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/service-bus-messaging/message-sessions#session-features&#34;&gt;Azure 服務匯流排訊息工作階段&lt;/a&gt;，圖片說明會比較好理解。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;建立完畢之後回到訂用帳戶就會看到囉，這邊為了等等能夠示範傳遞訊息給多個訂用者，所以也順便開了 Sub2：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/q3xkzdQ.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;這樣就完成了主題的建立啦！接著讓我們回到程式中來撰寫訊息吧～&lt;/p&gt;
&lt;h3 id=&#34;將訊息放入主題&#34;&gt;將訊息放入主題&lt;/h3&gt;
&lt;p&gt;基本上來說，訊息放入主題的方式就和放入佇列的方式一樣：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// 將訊息放入主題&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[HttpPost]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task Enqueue([FromBody] &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; context)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 用 ServiceBus 的連線字串建立 Client&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 連線字串可以在 Azure ServiceBus 頁面的共用存取原則找到&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ServiceBusClient 用完記得要呼叫 DisposeAsync() 來關掉&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 或是直接使用 await using 包起來&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; connectionString = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR SERVICE BUS CONNECTION STRING&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var client = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ServiceBusClient(connectionString);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 傳遞 Topic 的名字給 CreateSender 方法來建立 Sender&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 和 ServiceBusClient 一樣，有提供 DisposeAsync 方法來關閉&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 或是直接使用 await using 包起來&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; topicName = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR TOPIC NAME&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var sender = client.CreateSender(topicName);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 將要傳送的訊息包裝成 ServiceBusMessage&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 並使用 ServiceBusSender.SendMessageAsync 傳送出去&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ServiceBusMessage(context);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; sender.SendMessageAsync(message);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;不用當成大家來找碴，因為真的就是一樣的放法。畢竟 &lt;code&gt;CreateSender&lt;/code&gt; 的參數名稱是這樣的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/nvj36PO.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;事不宜遲，我們馬上就來傳一封訊息試試：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/oiL6TD9.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;這時候再到我們的主題下的訂用帳戶，可以看見訂用帳戶中已經有訊息囉：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/quyH7n9.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;因為主題會傳送給所有訂用帳戶，所以兩個訂用帳戶都會分別收到這則訊息，讓我們也確認一眼吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/uoy84gu.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;看來我們很順利地把訊息傳送出去啦！那因為整批放入的方式也和佇列一樣，這邊就不再贅述。接下來就讓我們把訊息取出來試試吧～&lt;/p&gt;
&lt;h3 id=&#34;從主題中讀取訊息&#34;&gt;從主題中讀取訊息&lt;/h3&gt;
&lt;p&gt;就像前面寫入訊息到主題和寫入佇列長得九成像一樣，讀取也是差不多的。最大的差別是在&lt;strong&gt;建立 Processor 時，需要多給訂用帳戶名稱&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 需要同時告訴 Processor 主題名稱和訂用帳戶名稱&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; queueName = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR QUEUE NAME&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; subscriptionName = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Sub1&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var processor = client.CreateProcessor(topicName, subscriptionName);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;讓我們修改成 Topic 名稱以及剛剛的訂用帳戶 Sub1 之後執行看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/udHkpxn.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看見訂用帳戶 Sub1 的訊息也消耗掉了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/lpLy4Rd.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;而訂用帳戶 Sub2 的訊息還在，當我們使用 Sub2 來建立 Processor 並接收訊息之後才會消失：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/MvOgIL5.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;其餘的部份都和處理佇列的時候一樣。但為了版面一致 &lt;del&gt;我之後回來複製的時候方便&lt;/del&gt; 這邊還是附上程式碼：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// 取出主題中的訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[HttpGet]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task Dequeue()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 和發送訊息的場合差不多：先建立 Client 及 Processor&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; connectionString = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR SERVICE BUS CONNECTION STRING&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var client = &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ServiceBusClient(connectionString);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 和前面的 ServiceBusSender 一樣，有提供 DisposeAsync 方法讓我們用完時關閉&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 或是直接使用 await using 包起來&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 和佇列不一樣的是：需要同時告訴 Processor 主題名稱和訂用帳戶名稱&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; topicName = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR TOPIC NAME&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; subscriptionName = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR SUBSCRIPTION NAME&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var processor = client.CreateProcessor(topicName, subscriptionName);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 告訴 Processor 我們想怎麼處理訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    processor.ProcessMessageAsync += MessageHandler;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    processor.ProcessErrorAsync += ErrorHandler;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 讓 Processor 上工，開始接收訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; processor.StartProcessingAsync();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 實際上會掛著讓 processor 一直處理送來的訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 這邊就意思意思跑個一下下&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; Task.Delay(&lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 讓 Processor 下班休息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; processor.StopProcessingAsync();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// 處理主題訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task MessageHandler(ProcessMessageEventArgs args)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 從訊息的 Body 取出我們發送時塞進去的內容&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; message = args.Message.Body.ToString();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 對訊息內容做你想做的事。這邊就印出來看個一眼意思意思&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Console.WriteLine(message);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 告訴 Service Bus 這個訊息有成功處理了&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; args.CompleteMessageAsync(args.Message);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// 處理主題錯誤訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; Task ErrorHandler(ProcessErrorEventArgs args)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 從訊息中取出錯誤訊息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; exception = args.Exception.ToString();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 對訊息做錯誤處理，例如存到日誌系統之類的。這邊也印出來看個一眼意思意思&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Console.WriteLine(exception);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;稍作整理&#34;&gt;稍作整理&lt;/h2&gt;
&lt;p&gt;我們已經介紹完了 ServiceBus 的兩種主要工具：佇列和主題的基本操作。&lt;/p&gt;
&lt;p&gt;接下來我將稍微對現在的範例程式碼做點簡單的整理，給有興趣的朋友參考。&lt;/p&gt;
&lt;p&gt;其餘的朋友可以直接跳到最後的&lt;a href=&#34;#%E5%B0%8F%E7%B5%90&#34;&gt;小結&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;使用-iazureclientfactory-搭配依賴注入來建立-azure-client&#34;&gt;使用 IAzureClientFactory 搭配依賴注入來建立 Azure Client&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;這一小節會用到 .Net Core 的依賴注入，還沒有概念的朋友可以參照 &lt;a href=&#34;https://igouist.github.io/post/2021/11/newbie-6-dependency-injection&#34;&gt;使用 依賴注入 (Dependency Injection) 來解除強耦合吧&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;在範例中我們總是直接 &lt;code&gt;new ServiceBusClient&lt;/code&gt;。但根據&lt;a href=&#34;https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-performance-improvements?tabs=net-standard-sdk-2#reusing-factories-and-clients&#34;&gt;官方建議&lt;/a&gt;，ServiceBusClient 應該只建立一份並重複使用，以避免重新連線之類的效能損失。&lt;/p&gt;
&lt;p&gt;針對 &lt;code&gt;ServiceBusClient&lt;/code&gt; 的建立和管理，我們可以使用 &lt;code&gt;IAzureClientFactory&lt;/code&gt; 來讓它自動控制，替我們管理 Client 的實例和連線，用起來就像 &lt;code&gt;HttpClientFactory&lt;/code&gt; 一樣。&lt;/p&gt;
&lt;p&gt;要使用 &lt;code&gt;IAzureClientFactory&lt;/code&gt;，我們需要先安裝 &lt;code&gt;Microsoft.Extensions.Azure&lt;/code&gt; 套件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/vvFZGCE.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;現在讓我們移動到 &lt;code&gt;Program.cs&lt;/code&gt; 並加上 ServiceBusClient 的註冊：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;builder.Services.AddAzureClients(clientsBuilder =&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; connectionString = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR SERVICE BUS CONNECTION STRING&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    clientsBuilder
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .AddServiceBusClient(connectionString)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .WithName(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ServiceBusClient&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;看起來應該會像這樣：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.igouist.net/Uo0IR1g.webp&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;註：示範專案是使用 .Net 6。如果是使用其他版本或其他 DI 工具的朋友，請再按照自己的狀況調整吧！&lt;/p&gt;
&lt;p&gt;例如在 &lt;code&gt;HostBuilder&lt;/code&gt; 的場合，可能就要在 &lt;code&gt;ConfigureServices&lt;/code&gt; 中進行配置等等，只能祝各位好運。&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;註：除了 &lt;code&gt;WithName&lt;/code&gt; 替 Client 實例取名以外，也可以呼叫 &lt;code&gt;ConfigureOptions&lt;/code&gt; 來對 ServiceBusClient 進行各式各樣的設定&lt;/p&gt;
&lt;p&gt;關於 ServiceBusClient 的設定內容可以參閱 &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/api/azure.messaging.servicebus.servicebusclientoptions&#34;&gt;ServiceBusClientOptions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而關於 AddAzureClients 的註冊則可以參閱 &lt;a href=&#34;https://stackoverflow.com/questions/68688838/how-to-register-servicebusclient-for-dependency-injection&#34;&gt;How to register ServiceBusClient for dependency injection? - stackoverflow&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;現在我們註冊完了。接著只需要回到使用的類別讓 &lt;code&gt;IAzureClientFactory&lt;/code&gt; 注入進來就可以囉：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// Service Bus Queue + IAzureClientFactory 示範用 Controller&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[ApiController]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[Route(&amp;#34;[controller]&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;)]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;QueueWithDiController&lt;/span&gt; : ControllerBase
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;readonly&lt;/span&gt; ServiceBusClient _serviceBusClient;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; QueueWithDiController(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        IAzureClientFactory&amp;lt;ServiceBusClient&amp;gt; azureClientFactory)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 使用注入進來的 IAzureClientFactory 來建立 ServiceBusClient&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        _serviceBusClient = azureClientFactory.CreateClient(name: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ServiceBusClient&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接著我們就可以把原本範例中的呼叫也改成使用這個 Client 來操作囉：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; queueName = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR QUEUE NAME&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; var sender = _serviceBusClient.CreateSender(queueName);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;註：在前面的&lt;a href=&#34;https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-performance-improvements?tabs=net-standard-sdk-2#reusing-factories-and-clients&#34;&gt;官方建議&lt;/a&gt;中，除了 &lt;code&gt;ServiceBusClient&lt;/code&gt; 以外，其實也建議 &lt;code&gt;ServiceBusSender&lt;/code&gt;、&lt;code&gt;ServiceBusReceiver&lt;/code&gt;、&lt;code&gt;ServiceBusProcessor&lt;/code&gt; 這幾個也應該要維持單例，保持和伺服器的連線以減少建立連線的效能和時間損失。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ServiceBusClient&lt;/code&gt; 已經藉由前面提到的 &lt;code&gt;IAzureClientFactory&lt;/code&gt; 來解決；而像是 &lt;code&gt;ServiceBusSender&lt;/code&gt; 的後面三項，我們就需要根據專案的狀況來規劃如何重複使用。&lt;/p&gt;
&lt;p&gt;例如只需要一個 Sender 的場合，我們可以直接在注入的時候註冊成單例；而要和多個 Queue 連線所以需要多個 Sender 的時候，就可以考慮建立一個工廠來管理，並且在工廠裡面優先返回已經建好的實例等等。這部份就請再各位朋友保持柔軟的彈性來處理。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;將連線字串抽取到-config&#34;&gt;將連線字串抽取到 Config&lt;/h3&gt;
&lt;p&gt;把鏡頭回到我們註冊的地方：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;builder.Services.AddAzureClients(clientsBuilder =&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; connectionString = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR SERVICE BUS CONNECTION STRING&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    clientsBuilder
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .AddServiceBusClient(connectionString)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .WithName(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ServiceBusClient&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到現在的連線字串是寫死在 &lt;code&gt;Program.cs&lt;/code&gt; 中的（即使是前面的範例也是直接寫死在 Controller）&lt;/p&gt;
&lt;p&gt;但實務上我們大多會將連線字串放在設定檔，例如 Config 或 Appsettings，方便在正式環境或是 Azure 服務上運行時，能夠由外部去設定 or 變更組態來置換連線字串。因此這邊也應該要改成從組態中進行讀取。&lt;/p&gt;
&lt;p&gt;首先讓我們把連線字串丟到 &lt;code&gt;appsettings.json&lt;/code&gt; 的 &lt;code&gt;ConnectionStrings&lt;/code&gt; 區塊：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ConnectionStrings&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;:&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;ServiceBus&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;YOUR SERVICE BUS CONNECTION STRING&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那麼我們就可以更彈性靈活地使用連線字串來註冊 Client 囉：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;builder.Services.AddAzureClients(clientsBuilder =&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; connectionString = builder.Configuration
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .GetConnectionString(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ServiceBus&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    clientsBuilder
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .AddServiceBusClient(connectionString)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .WithName(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ServiceBusClient&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;小結&#34;&gt;小結&lt;/h2&gt;
&lt;p&gt;這篇我們稍微紀錄了訊息佇列（Message Queue）的用途：拆分生產者和消費者的直接依賴，在中間架設佇列來傳遞訊息。以及這樣做的幾個好處：解除耦合、提高擴展、非同步和提供了緩衝區。&lt;/p&gt;
&lt;p&gt;接著介紹了 Azure 的訊息佇列服務：Azure Service Bus，並對其中的兩種模式：佇列和主題，各做了簡單的操作範例。&lt;/p&gt;
&lt;p&gt;最後補充了一些範例能優化的方向；使用 IAzureClientFactory 來注入 Client、保持 Sender 等連線重複使用，以及將連線字串拆出到組態處理。&lt;/p&gt;
&lt;p&gt;當然還有一些進階的使用場景，例如&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/service-bus-messaging/service-bus-transactions&#34;&gt;交易處理&lt;/a&gt;、&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/service-bus-messaging/service-bus-geo-dr&#34;&gt;異地複寫&lt;/a&gt;等等，但因為這邊還沒有接觸過，就交給需要深入了解的朋朋自行研究囉。&lt;/p&gt;
&lt;p&gt;這算是我第一次接觸 Azure 相關的工具，加減筆記一下簡單的使用場景（傳入訊息到佇列／從佇列取出訊息），範例也已經丟到 &lt;a href=&#34;https://github.com/Igouist/Demo.AzureServiceBus&#34;&gt;Github&lt;/a&gt; 上囉，有缺漏的也歡迎各位朋朋幫忙補充，感謝感謝。&lt;/p&gt;
&lt;p&gt;那麼今天的紀錄就到這邊囉，希望以後還能回來抄。&lt;del&gt;總不會筆記寫完就要改用 RabbitMQ 了吧囧&lt;/del&gt;&lt;/p&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.dotblogs.com.tw/supershowwei/2022/02/13/221639&#34;&gt;[食譜好菜] 比 Azure Queue Storage 功能更完整的 Message Queue 服務 - Azure Service Bus | 軟體主廚的程式料理廚房 - 點部落 (dotblogs.com.tw)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10240878&#34;&gt;訊息服務站 - ServiceBus - iT 邦幫忙：：一起幫忙解決難題，拯救 IT 人的一天 (ithome.com.tw)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/service-bus-messaging/service-bus-dotnet-get-started-with-queues&#34;&gt;開始使用 Azure 服務匯流排佇列 (.NET) - Azure Service Bus | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/MicrosoftDocs/azure-docs.zh-tw/blob/master/articles/service-bus-messaging/service-bus-dotnet-get-started-with-queues.md&#34;&gt;在 Azure 服務匯流排佇列 (.NET) 中傳送和接收訊息 (github.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10161086&#34;&gt;使用 Python 操作 Azure Service Bus Queues - iT 邦幫忙 (ithome.com.tw)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10161209&#34;&gt;使用 Python 操作 Service Bus Topics/Subscriptions - iT 邦幫忙 (ithome.com.tw)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/AllenMaster/p/14000933.html&#34;&gt;Azure Service Bus（一）入门简介 - Grant_Allen - 博客园 (cnblogs.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/AceLee/2019/07/18/195448&#34;&gt;建立 Azure Service Bus | 程式碼學習不歸路 - 點部落 (dotblogs.com.tw)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/AceLee/2019/07/18/205733&#34;&gt;透過 Service Bus Queue trigger Azure Function | 程式碼學習不歸路 - 點部落 (dotblogs.com.tw)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/service-bus-messaging/service-bus-azure-and-service-bus-queues-compared-contrasted&#34;&gt;比較 Azure 佇列儲存體和服務匯流排佇列 - Azure Service Bus | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/azure/event-grid/compare-messaging-services&#34;&gt;比較 Azure 傳訊服務 - Azure Event Grid | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>